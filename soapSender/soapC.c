/* soapC.c
   Generated by gSOAP 2.8.44 for SOF_interface.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.44 2017-06-07 10:36:53 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse:
		return soap_in_ns1__SOF_USCOREEncryptDataResponse(soap, NULL, NULL, "ns1:SOF_EncryptDataResponse");
	case SOAP_TYPE_ns1__SOF_USCOREEncryptData:
		return soap_in_ns1__SOF_USCOREEncryptData(soap, NULL, NULL, "ns1:SOF_EncryptData");
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse:
		return soap_in_ns1__SOF_USCOREGetCertInfoResponse(soap, NULL, NULL, "ns1:SOF_GetCertInfoResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfo:
		return soap_in_ns1__SOF_USCOREGetCertInfo(soap, NULL, NULL, "ns1:SOF_GetCertInfo");
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return soap_in_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, NULL, NULL, "ns1:SOF_QueryCertTrustListAltNamesResponse");
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames:
		return soap_in_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, NULL, NULL, "ns1:SOF_QueryCertTrustListAltNames");
	case SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse:
		return soap_in_ns1__SOF_USCOREDecryptDataResponse(soap, NULL, NULL, "ns1:SOF_DecryptDataResponse");
	case SOAP_TYPE_ns1__SOF_USCOREDecryptData:
		return soap_in_ns1__SOF_USCOREDecryptData(soap, NULL, NULL, "ns1:SOF_DecryptData");
	case SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse:
		return soap_in_ns1__SOF_USCORESignDataXMLResponse(soap, NULL, NULL, "ns1:SOF_SignDataXMLResponse");
	case SOAP_TYPE_ns1__SOF_USCORESignDataXML:
		return soap_in_ns1__SOF_USCORESignDataXML(soap, NULL, NULL, "ns1:SOF_SignDataXML");
	case SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse:
		return soap_in_ns1__SOF_USCOREEncryptFileResponse(soap, NULL, NULL, "ns1:SOF_EncryptFileResponse");
	case SOAP_TYPE_ns1__SOF_USCOREEncryptFile:
		return soap_in_ns1__SOF_USCOREEncryptFile(soap, NULL, NULL, "ns1:SOF_EncryptFile");
	case SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response:
		return soap_in_ns1__SOF_USCORESignDataByP7Response(soap, NULL, NULL, "ns1:SOF_SignDataByP7Response");
	case SOAP_TYPE_ns1__SOF_USCORESignDataByP7:
		return soap_in_ns1__SOF_USCORESignDataByP7(soap, NULL, NULL, "ns1:SOF_SignDataByP7");
	case SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse:
		return soap_in_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, NULL, NULL, "ns1:SOF_GetTimeStampInfoResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo:
		return soap_in_ns1__SOF_USCOREGetTimeStampInfo(soap, NULL, NULL, "ns1:SOF_GetTimeStampInfo");
	case SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse:
		return soap_in_ns1__SOF_USCORESetSignMethodResponse(soap, NULL, NULL, "ns1:SOF_SetSignMethodResponse");
	case SOAP_TYPE_ns1__SOF_USCORESetSignMethod:
		return soap_in_ns1__SOF_USCORESetSignMethod(soap, NULL, NULL, "ns1:SOF_SetSignMethod");
	case SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse:
		return soap_in_ns1__SOF_USCOREDecryptFileResponse(soap, NULL, NULL, "ns1:SOF_DecryptFileResponse");
	case SOAP_TYPE_ns1__SOF_USCOREDecryptFile:
		return soap_in_ns1__SOF_USCOREDecryptFile(soap, NULL, NULL, "ns1:SOF_DecryptFile");
	case SOAP_TYPE_ns1__GetFileResponse:
		return soap_in_ns1__GetFileResponse(soap, NULL, NULL, "ns1:GetFileResponse");
	case SOAP_TYPE_ns1__GetFile:
		return soap_in_ns1__GetFile(soap, NULL, NULL, "ns1:GetFile");
	case SOAP_TYPE_ns1__DeleteFileResponse:
		return soap_in_ns1__DeleteFileResponse(soap, NULL, NULL, "ns1:DeleteFileResponse");
	case SOAP_TYPE_ns1__DeleteFile:
		return soap_in_ns1__DeleteFile(soap, NULL, NULL, "ns1:DeleteFile");
	case SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse:
		return soap_in_ns1__SOF_USCOREValidateCertResponse(soap, NULL, NULL, "ns1:SOF_ValidateCertResponse");
	case SOAP_TYPE_ns1__SOF_USCOREValidateCert:
		return soap_in_ns1__SOF_USCOREValidateCert(soap, NULL, NULL, "ns1:SOF_ValidateCert");
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse:
		return soap_in_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, NULL, NULL, "ns1:SOF_CreateTimeStampResponseResponse");
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse:
		return soap_in_ns1__SOF_USCORECreateTimeStampResponse(soap, NULL, NULL, "ns1:SOF_CreateTimeStampResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse:
		return soap_in_ns1__SOF_USCOREGetEncryptMethodResponse(soap, NULL, NULL, "ns1:SOF_GetEncryptMethodResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod:
		return soap_in_ns1__SOF_USCOREGetEncryptMethod(soap, NULL, NULL, "ns1:SOF_GetEncryptMethod");
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse:
		return soap_in_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, NULL, NULL, "ns1:SOF_CreateTimeStampRequestResponse");
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest:
		return soap_in_ns1__SOF_USCORECreateTimeStampRequest(soap, NULL, NULL, "ns1:SOF_CreateTimeStampRequest");
	case SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse:
		return soap_in_ns1__SOF_USCORESetEncryptMethodResponse(soap, NULL, NULL, "ns1:SOF_SetEncryptMethodResponse");
	case SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod:
		return soap_in_ns1__SOF_USCORESetEncryptMethod(soap, NULL, NULL, "ns1:SOF_SetEncryptMethod");
	case SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse:
		return soap_in_ns1__SOF_USCOREGetSignMethodResponse(soap, NULL, NULL, "ns1:SOF_GetSignMethodResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetSignMethod:
		return soap_in_ns1__SOF_USCOREGetSignMethod(soap, NULL, NULL, "ns1:SOF_GetSignMethod");
	case SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse:
		return soap_in_ns1__SOF_USCORESetWebAppNameResponse(soap, NULL, NULL, "ns1:SOF_SetWebAppNameResponse");
	case SOAP_TYPE_ns1__SOF_USCORESetWebAppName:
		return soap_in_ns1__SOF_USCORESetWebAppName(soap, NULL, NULL, "ns1:SOF_SetWebAppName");
	case SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse:
		return soap_in_ns1__SOF_USCOREGenRandomResponse(soap, NULL, NULL, "ns1:SOF_GenRandomResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGenRandom:
		return soap_in_ns1__SOF_USCOREGenRandom(soap, NULL, NULL, "ns1:SOF_GenRandom");
	case SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse:
		return soap_in_ns1__SOF_USCOREPriKeyDecryptResponse(soap, NULL, NULL, "ns1:SOF_PriKeyDecryptResponse");
	case SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt:
		return soap_in_ns1__SOF_USCOREPriKeyDecrypt(soap, NULL, NULL, "ns1:SOF_PriKeyDecrypt");
	case SOAP_TYPE_ns1__sofSecurityEngineDeal:
		return soap_in_ns1__sofSecurityEngineDeal(soap, NULL, NULL, "ns1:sofSecurityEngineDeal");
	case SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse:
		return soap_in_ns1__SOF_USCOREGetInstanceResponse(soap, NULL, NULL, "ns1:SOF_GetInstanceResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetInstance:
		return soap_in_ns1__SOF_USCOREGetInstance(soap, NULL, NULL, "ns1:SOF_GetInstance");
	case SOAP_TYPE_ns1__SOF_USCORESignFileResponse:
		return soap_in_ns1__SOF_USCORESignFileResponse(soap, NULL, NULL, "ns1:SOF_SignFileResponse");
	case SOAP_TYPE_ns1__SOF_USCORESignFile:
		return soap_in_ns1__SOF_USCORESignFile(soap, NULL, NULL, "ns1:SOF_SignFile");
	case SOAP_TYPE_ns1__SOF_USCORESignDataResponse:
		return soap_in_ns1__SOF_USCORESignDataResponse(soap, NULL, NULL, "ns1:SOF_SignDataResponse");
	case SOAP_TYPE_ns1__SOF_USCORESignData:
		return soap_in_ns1__SOF_USCORESignData(soap, NULL, NULL, "ns1:SOF_SignData");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse:
		return soap_in_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, NULL, NULL, "ns1:SOF_VerifySignedDataXMLResponse");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML:
		return soap_in_ns1__SOF_USCOREVerifySignedDataXML(soap, NULL, NULL, "ns1:SOF_VerifySignedDataXML");
	case SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse:
		return soap_in_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, NULL, NULL, "ns1:SOF_GetXMLSignatureInfoResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo:
		return soap_in_ns1__SOF_USCOREGetXMLSignatureInfo(soap, NULL, NULL, "ns1:SOF_GetXMLSignatureInfo");
	case SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse:
		return soap_in_ns1__SOF_USCOREDelCertTrustListResponse(soap, NULL, NULL, "ns1:SOF_DelCertTrustListResponse");
	case SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList:
		return soap_in_ns1__SOF_USCOREDelCertTrustList(soap, NULL, NULL, "ns1:SOF_DelCertTrustList");
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse:
		return soap_in_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, NULL, NULL, "ns1:SOF_GetCertInfoByOidResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid:
		return soap_in_ns1__SOF_USCOREGetCertInfoByOid(soap, NULL, NULL, "ns1:SOF_GetCertInfoByOid");
	case SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse:
		return soap_in_ns1__SOF_USCOREGetServerCertificateResponse(soap, NULL, NULL, "ns1:SOF_GetServerCertificateResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate:
		return soap_in_ns1__SOF_USCOREGetServerCertificate(soap, NULL, NULL, "ns1:SOF_GetServerCertificate");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse:
		return soap_in_ns1__SOF_USCOREVerifySignedFileResponse(soap, NULL, NULL, "ns1:SOF_VerifySignedFileResponse");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile:
		return soap_in_ns1__SOF_USCOREVerifySignedFile(soap, NULL, NULL, "ns1:SOF_VerifySignedFile");
	case SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse:
		return soap_in_ns1__SOF_USCOREPubKeyEncryptResponse(soap, NULL, NULL, "ns1:SOF_PubKeyEncryptResponse");
	case SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt:
		return soap_in_ns1__SOF_USCOREPubKeyEncrypt(soap, NULL, NULL, "ns1:SOF_PubKeyEncrypt");
	case SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse:
		return soap_in_ns1__SOF_USCOREVerifyTimeStampResponse(soap, NULL, NULL, "ns1:SOF_VerifyTimeStampResponse");
	case SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp:
		return soap_in_ns1__SOF_USCOREVerifyTimeStamp(soap, NULL, NULL, "ns1:SOF_VerifyTimeStamp");
	case SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse:
		return soap_in_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, NULL, NULL, "ns1:SOF_GetP7SignDataInfoResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo:
		return soap_in_ns1__SOF_USCOREGetP7SignDataInfo(soap, NULL, NULL, "ns1:SOF_GetP7SignDataInfo");
	case SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse:
		return soap_in_ns1__SOF_USCORESetCertTrustListResponse(soap, NULL, NULL, "ns1:SOF_SetCertTrustListResponse");
	case SOAP_TYPE_ns1__SOF_USCORESetCertTrustList:
		return soap_in_ns1__SOF_USCORESetCertTrustList(soap, NULL, NULL, "ns1:SOF_SetCertTrustList");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response:
		return soap_in_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, NULL, NULL, "ns1:SOF_VerifySignedDataByP7Response");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7:
		return soap_in_ns1__SOF_USCOREVerifySignedDataByP7(soap, NULL, NULL, "ns1:SOF_VerifySignedDataByP7");
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse:
		return soap_in_ns1__SOF_USCOREQueryCertTrustListResponse(soap, NULL, NULL, "ns1:SOF_QueryCertTrustListResponse");
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList:
		return soap_in_ns1__SOF_USCOREQueryCertTrustList(soap, NULL, NULL, "ns1:SOF_QueryCertTrustList");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse:
		return soap_in_ns1__SOF_USCOREVerifySignedDataResponse(soap, NULL, NULL, "ns1:SOF_VerifySignedDataResponse");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedData:
		return soap_in_ns1__SOF_USCOREVerifySignedData(soap, NULL, NULL, "ns1:SOF_VerifySignedData");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptDataResponse:
		return soap_in_PointerTons1__SOF_USCOREEncryptDataResponse(soap, NULL, NULL, "ns1:SOF_EncryptDataResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptData:
		return soap_in_PointerTons1__SOF_USCOREEncryptData(soap, NULL, NULL, "ns1:SOF_EncryptData");
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return soap_in_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, NULL, NULL, "ns1:SOF_QueryCertTrustListAltNamesResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListAltNames:
		return soap_in_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(soap, NULL, NULL, "ns1:SOF_QueryCertTrustListAltNames");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoResponse:
		return soap_in_PointerTons1__SOF_USCOREGetCertInfoResponse(soap, NULL, NULL, "ns1:SOF_GetCertInfoResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfo:
		return soap_in_PointerTons1__SOF_USCOREGetCertInfo(soap, NULL, NULL, "ns1:SOF_GetCertInfo");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataXMLResponse:
		return soap_in_PointerTons1__SOF_USCORESignDataXMLResponse(soap, NULL, NULL, "ns1:SOF_SignDataXMLResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataXML:
		return soap_in_PointerTons1__SOF_USCORESignDataXML(soap, NULL, NULL, "ns1:SOF_SignDataXML");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptDataResponse:
		return soap_in_PointerTons1__SOF_USCOREDecryptDataResponse(soap, NULL, NULL, "ns1:SOF_DecryptDataResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptData:
		return soap_in_PointerTons1__SOF_USCOREDecryptData(soap, NULL, NULL, "ns1:SOF_DecryptData");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataByP7Response:
		return soap_in_PointerTons1__SOF_USCORESignDataByP7Response(soap, NULL, NULL, "ns1:SOF_SignDataByP7Response");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataByP7:
		return soap_in_PointerTons1__SOF_USCORESignDataByP7(soap, NULL, NULL, "ns1:SOF_SignDataByP7");
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptFileResponse:
		return soap_in_PointerTons1__SOF_USCOREEncryptFileResponse(soap, NULL, NULL, "ns1:SOF_EncryptFileResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptFile:
		return soap_in_PointerTons1__SOF_USCOREEncryptFile(soap, NULL, NULL, "ns1:SOF_EncryptFile");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetTimeStampInfoResponse:
		return soap_in_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(soap, NULL, NULL, "ns1:SOF_GetTimeStampInfoResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetTimeStampInfo:
		return soap_in_PointerTons1__SOF_USCOREGetTimeStampInfo(soap, NULL, NULL, "ns1:SOF_GetTimeStampInfo");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetSignMethodResponse:
		return soap_in_PointerTons1__SOF_USCORESetSignMethodResponse(soap, NULL, NULL, "ns1:SOF_SetSignMethodResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetSignMethod:
		return soap_in_PointerTons1__SOF_USCORESetSignMethod(soap, NULL, NULL, "ns1:SOF_SetSignMethod");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptFileResponse:
		return soap_in_PointerTons1__SOF_USCOREDecryptFileResponse(soap, NULL, NULL, "ns1:SOF_DecryptFileResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptFile:
		return soap_in_PointerTons1__SOF_USCOREDecryptFile(soap, NULL, NULL, "ns1:SOF_DecryptFile");
	case SOAP_TYPE_PointerTons1__GetFileResponse:
		return soap_in_PointerTons1__GetFileResponse(soap, NULL, NULL, "ns1:GetFileResponse");
	case SOAP_TYPE_PointerTons1__GetFile:
		return soap_in_PointerTons1__GetFile(soap, NULL, NULL, "ns1:GetFile");
	case SOAP_TYPE_PointerTons1__DeleteFileResponse:
		return soap_in_PointerTons1__DeleteFileResponse(soap, NULL, NULL, "ns1:DeleteFileResponse");
	case SOAP_TYPE_PointerTons1__DeleteFile:
		return soap_in_PointerTons1__DeleteFile(soap, NULL, NULL, "ns1:DeleteFile");
	case SOAP_TYPE_PointerTons1__SOF_USCOREValidateCertResponse:
		return soap_in_PointerTons1__SOF_USCOREValidateCertResponse(soap, NULL, NULL, "ns1:SOF_ValidateCertResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREValidateCert:
		return soap_in_PointerTons1__SOF_USCOREValidateCert(soap, NULL, NULL, "ns1:SOF_ValidateCert");
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampResponseResponse:
		return soap_in_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(soap, NULL, NULL, "ns1:SOF_CreateTimeStampResponseResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampResponse:
		return soap_in_PointerTons1__SOF_USCORECreateTimeStampResponse(soap, NULL, NULL, "ns1:SOF_CreateTimeStampResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetEncryptMethodResponse:
		return soap_in_PointerTons1__SOF_USCOREGetEncryptMethodResponse(soap, NULL, NULL, "ns1:SOF_GetEncryptMethodResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetEncryptMethod:
		return soap_in_PointerTons1__SOF_USCOREGetEncryptMethod(soap, NULL, NULL, "ns1:SOF_GetEncryptMethod");
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampRequestResponse:
		return soap_in_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(soap, NULL, NULL, "ns1:SOF_CreateTimeStampRequestResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampRequest:
		return soap_in_PointerTons1__SOF_USCORECreateTimeStampRequest(soap, NULL, NULL, "ns1:SOF_CreateTimeStampRequest");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetEncryptMethodResponse:
		return soap_in_PointerTons1__SOF_USCORESetEncryptMethodResponse(soap, NULL, NULL, "ns1:SOF_SetEncryptMethodResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetEncryptMethod:
		return soap_in_PointerTons1__SOF_USCORESetEncryptMethod(soap, NULL, NULL, "ns1:SOF_SetEncryptMethod");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetWebAppNameResponse:
		return soap_in_PointerTons1__SOF_USCORESetWebAppNameResponse(soap, NULL, NULL, "ns1:SOF_SetWebAppNameResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetWebAppName:
		return soap_in_PointerTons1__SOF_USCORESetWebAppName(soap, NULL, NULL, "ns1:SOF_SetWebAppName");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetSignMethodResponse:
		return soap_in_PointerTons1__SOF_USCOREGetSignMethodResponse(soap, NULL, NULL, "ns1:SOF_GetSignMethodResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetSignMethod:
		return soap_in_PointerTons1__SOF_USCOREGetSignMethod(soap, NULL, NULL, "ns1:SOF_GetSignMethod");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGenRandomResponse:
		return soap_in_PointerTons1__SOF_USCOREGenRandomResponse(soap, NULL, NULL, "ns1:SOF_GenRandomResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGenRandom:
		return soap_in_PointerTons1__SOF_USCOREGenRandom(soap, NULL, NULL, "ns1:SOF_GenRandom");
	case SOAP_TYPE_PointerTons1__SOF_USCOREPriKeyDecryptResponse:
		return soap_in_PointerTons1__SOF_USCOREPriKeyDecryptResponse(soap, NULL, NULL, "ns1:SOF_PriKeyDecryptResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREPriKeyDecrypt:
		return soap_in_PointerTons1__SOF_USCOREPriKeyDecrypt(soap, NULL, NULL, "ns1:SOF_PriKeyDecrypt");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetInstanceResponse:
		return soap_in_PointerTons1__SOF_USCOREGetInstanceResponse(soap, NULL, NULL, "ns1:SOF_GetInstanceResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetInstance:
		return soap_in_PointerTons1__SOF_USCOREGetInstance(soap, NULL, NULL, "ns1:SOF_GetInstance");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignFileResponse:
		return soap_in_PointerTons1__SOF_USCORESignFileResponse(soap, NULL, NULL, "ns1:SOF_SignFileResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignFile:
		return soap_in_PointerTons1__SOF_USCORESignFile(soap, NULL, NULL, "ns1:SOF_SignFile");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse:
		return soap_in_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(soap, NULL, NULL, "ns1:SOF_VerifySignedDataXMLResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataXML:
		return soap_in_PointerTons1__SOF_USCOREVerifySignedDataXML(soap, NULL, NULL, "ns1:SOF_VerifySignedDataXML");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataResponse:
		return soap_in_PointerTons1__SOF_USCORESignDataResponse(soap, NULL, NULL, "ns1:SOF_SignDataResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignData:
		return soap_in_PointerTons1__SOF_USCORESignData(soap, NULL, NULL, "ns1:SOF_SignData");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse:
		return soap_in_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(soap, NULL, NULL, "ns1:SOF_GetXMLSignatureInfoResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetXMLSignatureInfo:
		return soap_in_PointerTons1__SOF_USCOREGetXMLSignatureInfo(soap, NULL, NULL, "ns1:SOF_GetXMLSignatureInfo");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDelCertTrustListResponse:
		return soap_in_PointerTons1__SOF_USCOREDelCertTrustListResponse(soap, NULL, NULL, "ns1:SOF_DelCertTrustListResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDelCertTrustList:
		return soap_in_PointerTons1__SOF_USCOREDelCertTrustList(soap, NULL, NULL, "ns1:SOF_DelCertTrustList");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetServerCertificateResponse:
		return soap_in_PointerTons1__SOF_USCOREGetServerCertificateResponse(soap, NULL, NULL, "ns1:SOF_GetServerCertificateResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetServerCertificate:
		return soap_in_PointerTons1__SOF_USCOREGetServerCertificate(soap, NULL, NULL, "ns1:SOF_GetServerCertificate");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoByOidResponse:
		return soap_in_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(soap, NULL, NULL, "ns1:SOF_GetCertInfoByOidResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoByOid:
		return soap_in_PointerTons1__SOF_USCOREGetCertInfoByOid(soap, NULL, NULL, "ns1:SOF_GetCertInfoByOid");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedFileResponse:
		return soap_in_PointerTons1__SOF_USCOREVerifySignedFileResponse(soap, NULL, NULL, "ns1:SOF_VerifySignedFileResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedFile:
		return soap_in_PointerTons1__SOF_USCOREVerifySignedFile(soap, NULL, NULL, "ns1:SOF_VerifySignedFile");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifyTimeStampResponse:
		return soap_in_PointerTons1__SOF_USCOREVerifyTimeStampResponse(soap, NULL, NULL, "ns1:SOF_VerifyTimeStampResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifyTimeStamp:
		return soap_in_PointerTons1__SOF_USCOREVerifyTimeStamp(soap, NULL, NULL, "ns1:SOF_VerifyTimeStamp");
	case SOAP_TYPE_PointerTons1__SOF_USCOREPubKeyEncryptResponse:
		return soap_in_PointerTons1__SOF_USCOREPubKeyEncryptResponse(soap, NULL, NULL, "ns1:SOF_PubKeyEncryptResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREPubKeyEncrypt:
		return soap_in_PointerTons1__SOF_USCOREPubKeyEncrypt(soap, NULL, NULL, "ns1:SOF_PubKeyEncrypt");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataByP7Response:
		return soap_in_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(soap, NULL, NULL, "ns1:SOF_VerifySignedDataByP7Response");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataByP7:
		return soap_in_PointerTons1__SOF_USCOREVerifySignedDataByP7(soap, NULL, NULL, "ns1:SOF_VerifySignedDataByP7");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetCertTrustListResponse:
		return soap_in_PointerTons1__SOF_USCORESetCertTrustListResponse(soap, NULL, NULL, "ns1:SOF_SetCertTrustListResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetCertTrustList:
		return soap_in_PointerTons1__SOF_USCORESetCertTrustList(soap, NULL, NULL, "ns1:SOF_SetCertTrustList");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse:
		return soap_in_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(soap, NULL, NULL, "ns1:SOF_GetP7SignDataInfoResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetP7SignDataInfo:
		return soap_in_PointerTons1__SOF_USCOREGetP7SignDataInfo(soap, NULL, NULL, "ns1:SOF_GetP7SignDataInfo");
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListResponse:
		return soap_in_PointerTons1__SOF_USCOREQueryCertTrustListResponse(soap, NULL, NULL, "ns1:SOF_QueryCertTrustListResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustList:
		return soap_in_PointerTons1__SOF_USCOREQueryCertTrustList(soap, NULL, NULL, "ns1:SOF_QueryCertTrustList");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataResponse:
		return soap_in_PointerTons1__SOF_USCOREVerifySignedDataResponse(soap, NULL, NULL, "ns1:SOF_VerifySignedDataResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedData:
		return soap_in_PointerTons1__SOF_USCOREVerifySignedData(soap, NULL, NULL, "ns1:SOF_VerifySignedData");
	case SOAP_TYPE_PointerTons1__sofSecurityEngineDeal:
		return soap_in_PointerTons1__sofSecurityEngineDeal(soap, NULL, NULL, "ns1:sofSecurityEngineDeal");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_EncryptDataResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse;
			return soap_in_ns1__SOF_USCOREEncryptDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_EncryptData"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREEncryptData;
			return soap_in_ns1__SOF_USCOREEncryptData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetCertInfoResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse;
			return soap_in_ns1__SOF_USCOREGetCertInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetCertInfo"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetCertInfo;
			return soap_in_ns1__SOF_USCOREGetCertInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_QueryCertTrustListAltNamesResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse;
			return soap_in_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_QueryCertTrustListAltNames"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames;
			return soap_in_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_DecryptDataResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse;
			return soap_in_ns1__SOF_USCOREDecryptDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_DecryptData"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREDecryptData;
			return soap_in_ns1__SOF_USCOREDecryptData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SignDataXMLResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse;
			return soap_in_ns1__SOF_USCORESignDataXMLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SignDataXML"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESignDataXML;
			return soap_in_ns1__SOF_USCORESignDataXML(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_EncryptFileResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse;
			return soap_in_ns1__SOF_USCOREEncryptFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_EncryptFile"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREEncryptFile;
			return soap_in_ns1__SOF_USCOREEncryptFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SignDataByP7Response"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response;
			return soap_in_ns1__SOF_USCORESignDataByP7Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SignDataByP7"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESignDataByP7;
			return soap_in_ns1__SOF_USCORESignDataByP7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetTimeStampInfoResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse;
			return soap_in_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetTimeStampInfo"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo;
			return soap_in_ns1__SOF_USCOREGetTimeStampInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SetSignMethodResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse;
			return soap_in_ns1__SOF_USCORESetSignMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SetSignMethod"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESetSignMethod;
			return soap_in_ns1__SOF_USCORESetSignMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_DecryptFileResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse;
			return soap_in_ns1__SOF_USCOREDecryptFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_DecryptFile"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREDecryptFile;
			return soap_in_ns1__SOF_USCOREDecryptFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFileResponse"))
		{	*type = SOAP_TYPE_ns1__GetFileResponse;
			return soap_in_ns1__GetFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFile"))
		{	*type = SOAP_TYPE_ns1__GetFile;
			return soap_in_ns1__GetFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteFileResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteFileResponse;
			return soap_in_ns1__DeleteFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteFile"))
		{	*type = SOAP_TYPE_ns1__DeleteFile;
			return soap_in_ns1__DeleteFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_ValidateCertResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse;
			return soap_in_ns1__SOF_USCOREValidateCertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_ValidateCert"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREValidateCert;
			return soap_in_ns1__SOF_USCOREValidateCert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_CreateTimeStampResponseResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse;
			return soap_in_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_CreateTimeStampResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse;
			return soap_in_ns1__SOF_USCORECreateTimeStampResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetEncryptMethodResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse;
			return soap_in_ns1__SOF_USCOREGetEncryptMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetEncryptMethod"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod;
			return soap_in_ns1__SOF_USCOREGetEncryptMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_CreateTimeStampRequestResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse;
			return soap_in_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_CreateTimeStampRequest"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest;
			return soap_in_ns1__SOF_USCORECreateTimeStampRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SetEncryptMethodResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse;
			return soap_in_ns1__SOF_USCORESetEncryptMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SetEncryptMethod"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod;
			return soap_in_ns1__SOF_USCORESetEncryptMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetSignMethodResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse;
			return soap_in_ns1__SOF_USCOREGetSignMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetSignMethod"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetSignMethod;
			return soap_in_ns1__SOF_USCOREGetSignMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SetWebAppNameResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse;
			return soap_in_ns1__SOF_USCORESetWebAppNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SetWebAppName"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESetWebAppName;
			return soap_in_ns1__SOF_USCORESetWebAppName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GenRandomResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse;
			return soap_in_ns1__SOF_USCOREGenRandomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GenRandom"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGenRandom;
			return soap_in_ns1__SOF_USCOREGenRandom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_PriKeyDecryptResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse;
			return soap_in_ns1__SOF_USCOREPriKeyDecryptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_PriKeyDecrypt"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt;
			return soap_in_ns1__SOF_USCOREPriKeyDecrypt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sofSecurityEngineDeal"))
		{	*type = SOAP_TYPE_ns1__sofSecurityEngineDeal;
			return soap_in_ns1__sofSecurityEngineDeal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetInstanceResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse;
			return soap_in_ns1__SOF_USCOREGetInstanceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetInstance"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetInstance;
			return soap_in_ns1__SOF_USCOREGetInstance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SignFileResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESignFileResponse;
			return soap_in_ns1__SOF_USCORESignFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SignFile"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESignFile;
			return soap_in_ns1__SOF_USCORESignFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SignDataResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESignDataResponse;
			return soap_in_ns1__SOF_USCORESignDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SignData"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESignData;
			return soap_in_ns1__SOF_USCORESignData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifySignedDataXMLResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse;
			return soap_in_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifySignedDataXML"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML;
			return soap_in_ns1__SOF_USCOREVerifySignedDataXML(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetXMLSignatureInfoResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse;
			return soap_in_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetXMLSignatureInfo"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo;
			return soap_in_ns1__SOF_USCOREGetXMLSignatureInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_DelCertTrustListResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse;
			return soap_in_ns1__SOF_USCOREDelCertTrustListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_DelCertTrustList"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList;
			return soap_in_ns1__SOF_USCOREDelCertTrustList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetCertInfoByOidResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse;
			return soap_in_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetCertInfoByOid"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid;
			return soap_in_ns1__SOF_USCOREGetCertInfoByOid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetServerCertificateResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse;
			return soap_in_ns1__SOF_USCOREGetServerCertificateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetServerCertificate"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate;
			return soap_in_ns1__SOF_USCOREGetServerCertificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifySignedFileResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse;
			return soap_in_ns1__SOF_USCOREVerifySignedFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifySignedFile"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile;
			return soap_in_ns1__SOF_USCOREVerifySignedFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_PubKeyEncryptResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse;
			return soap_in_ns1__SOF_USCOREPubKeyEncryptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_PubKeyEncrypt"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt;
			return soap_in_ns1__SOF_USCOREPubKeyEncrypt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifyTimeStampResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse;
			return soap_in_ns1__SOF_USCOREVerifyTimeStampResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifyTimeStamp"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp;
			return soap_in_ns1__SOF_USCOREVerifyTimeStamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetP7SignDataInfoResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse;
			return soap_in_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_GetP7SignDataInfo"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo;
			return soap_in_ns1__SOF_USCOREGetP7SignDataInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SetCertTrustListResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse;
			return soap_in_ns1__SOF_USCORESetCertTrustListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_SetCertTrustList"))
		{	*type = SOAP_TYPE_ns1__SOF_USCORESetCertTrustList;
			return soap_in_ns1__SOF_USCORESetCertTrustList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifySignedDataByP7Response"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response;
			return soap_in_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifySignedDataByP7"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7;
			return soap_in_ns1__SOF_USCOREVerifySignedDataByP7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_QueryCertTrustListResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse;
			return soap_in_ns1__SOF_USCOREQueryCertTrustListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_QueryCertTrustList"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList;
			return soap_in_ns1__SOF_USCOREQueryCertTrustList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifySignedDataResponse"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse;
			return soap_in_ns1__SOF_USCOREVerifySignedDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SOF_VerifySignedData"))
		{	*type = SOAP_TYPE_ns1__SOF_USCOREVerifySignedData;
			return soap_in_ns1__SOF_USCOREVerifySignedData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse:
		return soap_out_ns1__SOF_USCOREEncryptDataResponse(soap, tag, id, (const struct ns1__SOF_USCOREEncryptDataResponse *)ptr, "ns1:SOF_EncryptDataResponse");
	case SOAP_TYPE_ns1__SOF_USCOREEncryptData:
		return soap_out_ns1__SOF_USCOREEncryptData(soap, tag, id, (const struct ns1__SOF_USCOREEncryptData *)ptr, "ns1:SOF_EncryptData");
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse:
		return soap_out_ns1__SOF_USCOREGetCertInfoResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetCertInfoResponse *)ptr, "ns1:SOF_GetCertInfoResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfo:
		return soap_out_ns1__SOF_USCOREGetCertInfo(soap, tag, id, (const struct ns1__SOF_USCOREGetCertInfo *)ptr, "ns1:SOF_GetCertInfo");
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return soap_out_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, id, (const struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *)ptr, "ns1:SOF_QueryCertTrustListAltNamesResponse");
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames:
		return soap_out_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, id, (const struct ns1__SOF_USCOREQueryCertTrustListAltNames *)ptr, "ns1:SOF_QueryCertTrustListAltNames");
	case SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse:
		return soap_out_ns1__SOF_USCOREDecryptDataResponse(soap, tag, id, (const struct ns1__SOF_USCOREDecryptDataResponse *)ptr, "ns1:SOF_DecryptDataResponse");
	case SOAP_TYPE_ns1__SOF_USCOREDecryptData:
		return soap_out_ns1__SOF_USCOREDecryptData(soap, tag, id, (const struct ns1__SOF_USCOREDecryptData *)ptr, "ns1:SOF_DecryptData");
	case SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse:
		return soap_out_ns1__SOF_USCORESignDataXMLResponse(soap, tag, id, (const struct ns1__SOF_USCORESignDataXMLResponse *)ptr, "ns1:SOF_SignDataXMLResponse");
	case SOAP_TYPE_ns1__SOF_USCORESignDataXML:
		return soap_out_ns1__SOF_USCORESignDataXML(soap, tag, id, (const struct ns1__SOF_USCORESignDataXML *)ptr, "ns1:SOF_SignDataXML");
	case SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse:
		return soap_out_ns1__SOF_USCOREEncryptFileResponse(soap, tag, id, (const struct ns1__SOF_USCOREEncryptFileResponse *)ptr, "ns1:SOF_EncryptFileResponse");
	case SOAP_TYPE_ns1__SOF_USCOREEncryptFile:
		return soap_out_ns1__SOF_USCOREEncryptFile(soap, tag, id, (const struct ns1__SOF_USCOREEncryptFile *)ptr, "ns1:SOF_EncryptFile");
	case SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response:
		return soap_out_ns1__SOF_USCORESignDataByP7Response(soap, tag, id, (const struct ns1__SOF_USCORESignDataByP7Response *)ptr, "ns1:SOF_SignDataByP7Response");
	case SOAP_TYPE_ns1__SOF_USCORESignDataByP7:
		return soap_out_ns1__SOF_USCORESignDataByP7(soap, tag, id, (const struct ns1__SOF_USCORESignDataByP7 *)ptr, "ns1:SOF_SignDataByP7");
	case SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse:
		return soap_out_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetTimeStampInfoResponse *)ptr, "ns1:SOF_GetTimeStampInfoResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo:
		return soap_out_ns1__SOF_USCOREGetTimeStampInfo(soap, tag, id, (const struct ns1__SOF_USCOREGetTimeStampInfo *)ptr, "ns1:SOF_GetTimeStampInfo");
	case SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse:
		return soap_out_ns1__SOF_USCORESetSignMethodResponse(soap, tag, id, (const struct ns1__SOF_USCORESetSignMethodResponse *)ptr, "ns1:SOF_SetSignMethodResponse");
	case SOAP_TYPE_ns1__SOF_USCORESetSignMethod:
		return soap_out_ns1__SOF_USCORESetSignMethod(soap, tag, id, (const struct ns1__SOF_USCORESetSignMethod *)ptr, "ns1:SOF_SetSignMethod");
	case SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse:
		return soap_out_ns1__SOF_USCOREDecryptFileResponse(soap, tag, id, (const struct ns1__SOF_USCOREDecryptFileResponse *)ptr, "ns1:SOF_DecryptFileResponse");
	case SOAP_TYPE_ns1__SOF_USCOREDecryptFile:
		return soap_out_ns1__SOF_USCOREDecryptFile(soap, tag, id, (const struct ns1__SOF_USCOREDecryptFile *)ptr, "ns1:SOF_DecryptFile");
	case SOAP_TYPE_ns1__GetFileResponse:
		return soap_out_ns1__GetFileResponse(soap, tag, id, (const struct ns1__GetFileResponse *)ptr, "ns1:GetFileResponse");
	case SOAP_TYPE_ns1__GetFile:
		return soap_out_ns1__GetFile(soap, tag, id, (const struct ns1__GetFile *)ptr, "ns1:GetFile");
	case SOAP_TYPE_ns1__DeleteFileResponse:
		return soap_out_ns1__DeleteFileResponse(soap, tag, id, (const struct ns1__DeleteFileResponse *)ptr, "ns1:DeleteFileResponse");
	case SOAP_TYPE_ns1__DeleteFile:
		return soap_out_ns1__DeleteFile(soap, tag, id, (const struct ns1__DeleteFile *)ptr, "ns1:DeleteFile");
	case SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse:
		return soap_out_ns1__SOF_USCOREValidateCertResponse(soap, tag, id, (const struct ns1__SOF_USCOREValidateCertResponse *)ptr, "ns1:SOF_ValidateCertResponse");
	case SOAP_TYPE_ns1__SOF_USCOREValidateCert:
		return soap_out_ns1__SOF_USCOREValidateCert(soap, tag, id, (const struct ns1__SOF_USCOREValidateCert *)ptr, "ns1:SOF_ValidateCert");
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse:
		return soap_out_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, id, (const struct ns1__SOF_USCORECreateTimeStampResponseResponse *)ptr, "ns1:SOF_CreateTimeStampResponseResponse");
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse:
		return soap_out_ns1__SOF_USCORECreateTimeStampResponse(soap, tag, id, (const struct ns1__SOF_USCORECreateTimeStampResponse *)ptr, "ns1:SOF_CreateTimeStampResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse:
		return soap_out_ns1__SOF_USCOREGetEncryptMethodResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetEncryptMethodResponse *)ptr, "ns1:SOF_GetEncryptMethodResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod:
		return soap_out_ns1__SOF_USCOREGetEncryptMethod(soap, tag, id, (const struct ns1__SOF_USCOREGetEncryptMethod *)ptr, "ns1:SOF_GetEncryptMethod");
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse:
		return soap_out_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, id, (const struct ns1__SOF_USCORECreateTimeStampRequestResponse *)ptr, "ns1:SOF_CreateTimeStampRequestResponse");
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest:
		return soap_out_ns1__SOF_USCORECreateTimeStampRequest(soap, tag, id, (const struct ns1__SOF_USCORECreateTimeStampRequest *)ptr, "ns1:SOF_CreateTimeStampRequest");
	case SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse:
		return soap_out_ns1__SOF_USCORESetEncryptMethodResponse(soap, tag, id, (const struct ns1__SOF_USCORESetEncryptMethodResponse *)ptr, "ns1:SOF_SetEncryptMethodResponse");
	case SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod:
		return soap_out_ns1__SOF_USCORESetEncryptMethod(soap, tag, id, (const struct ns1__SOF_USCORESetEncryptMethod *)ptr, "ns1:SOF_SetEncryptMethod");
	case SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse:
		return soap_out_ns1__SOF_USCOREGetSignMethodResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetSignMethodResponse *)ptr, "ns1:SOF_GetSignMethodResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetSignMethod:
		return soap_out_ns1__SOF_USCOREGetSignMethod(soap, tag, id, (const struct ns1__SOF_USCOREGetSignMethod *)ptr, "ns1:SOF_GetSignMethod");
	case SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse:
		return soap_out_ns1__SOF_USCORESetWebAppNameResponse(soap, tag, id, (const struct ns1__SOF_USCORESetWebAppNameResponse *)ptr, "ns1:SOF_SetWebAppNameResponse");
	case SOAP_TYPE_ns1__SOF_USCORESetWebAppName:
		return soap_out_ns1__SOF_USCORESetWebAppName(soap, tag, id, (const struct ns1__SOF_USCORESetWebAppName *)ptr, "ns1:SOF_SetWebAppName");
	case SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse:
		return soap_out_ns1__SOF_USCOREGenRandomResponse(soap, tag, id, (const struct ns1__SOF_USCOREGenRandomResponse *)ptr, "ns1:SOF_GenRandomResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGenRandom:
		return soap_out_ns1__SOF_USCOREGenRandom(soap, tag, id, (const struct ns1__SOF_USCOREGenRandom *)ptr, "ns1:SOF_GenRandom");
	case SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse:
		return soap_out_ns1__SOF_USCOREPriKeyDecryptResponse(soap, tag, id, (const struct ns1__SOF_USCOREPriKeyDecryptResponse *)ptr, "ns1:SOF_PriKeyDecryptResponse");
	case SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt:
		return soap_out_ns1__SOF_USCOREPriKeyDecrypt(soap, tag, id, (const struct ns1__SOF_USCOREPriKeyDecrypt *)ptr, "ns1:SOF_PriKeyDecrypt");
	case SOAP_TYPE_ns1__sofSecurityEngineDeal:
		return soap_out_ns1__sofSecurityEngineDeal(soap, tag, id, (const struct ns1__sofSecurityEngineDeal *)ptr, "ns1:sofSecurityEngineDeal");
	case SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse:
		return soap_out_ns1__SOF_USCOREGetInstanceResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetInstanceResponse *)ptr, "ns1:SOF_GetInstanceResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetInstance:
		return soap_out_ns1__SOF_USCOREGetInstance(soap, tag, id, (const struct ns1__SOF_USCOREGetInstance *)ptr, "ns1:SOF_GetInstance");
	case SOAP_TYPE_ns1__SOF_USCORESignFileResponse:
		return soap_out_ns1__SOF_USCORESignFileResponse(soap, tag, id, (const struct ns1__SOF_USCORESignFileResponse *)ptr, "ns1:SOF_SignFileResponse");
	case SOAP_TYPE_ns1__SOF_USCORESignFile:
		return soap_out_ns1__SOF_USCORESignFile(soap, tag, id, (const struct ns1__SOF_USCORESignFile *)ptr, "ns1:SOF_SignFile");
	case SOAP_TYPE_ns1__SOF_USCORESignDataResponse:
		return soap_out_ns1__SOF_USCORESignDataResponse(soap, tag, id, (const struct ns1__SOF_USCORESignDataResponse *)ptr, "ns1:SOF_SignDataResponse");
	case SOAP_TYPE_ns1__SOF_USCORESignData:
		return soap_out_ns1__SOF_USCORESignData(soap, tag, id, (const struct ns1__SOF_USCORESignData *)ptr, "ns1:SOF_SignData");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse:
		return soap_out_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, id, (const struct ns1__SOF_USCOREVerifySignedDataXMLResponse *)ptr, "ns1:SOF_VerifySignedDataXMLResponse");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML:
		return soap_out_ns1__SOF_USCOREVerifySignedDataXML(soap, tag, id, (const struct ns1__SOF_USCOREVerifySignedDataXML *)ptr, "ns1:SOF_VerifySignedDataXML");
	case SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse:
		return soap_out_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *)ptr, "ns1:SOF_GetXMLSignatureInfoResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo:
		return soap_out_ns1__SOF_USCOREGetXMLSignatureInfo(soap, tag, id, (const struct ns1__SOF_USCOREGetXMLSignatureInfo *)ptr, "ns1:SOF_GetXMLSignatureInfo");
	case SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse:
		return soap_out_ns1__SOF_USCOREDelCertTrustListResponse(soap, tag, id, (const struct ns1__SOF_USCOREDelCertTrustListResponse *)ptr, "ns1:SOF_DelCertTrustListResponse");
	case SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList:
		return soap_out_ns1__SOF_USCOREDelCertTrustList(soap, tag, id, (const struct ns1__SOF_USCOREDelCertTrustList *)ptr, "ns1:SOF_DelCertTrustList");
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse:
		return soap_out_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetCertInfoByOidResponse *)ptr, "ns1:SOF_GetCertInfoByOidResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid:
		return soap_out_ns1__SOF_USCOREGetCertInfoByOid(soap, tag, id, (const struct ns1__SOF_USCOREGetCertInfoByOid *)ptr, "ns1:SOF_GetCertInfoByOid");
	case SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse:
		return soap_out_ns1__SOF_USCOREGetServerCertificateResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetServerCertificateResponse *)ptr, "ns1:SOF_GetServerCertificateResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate:
		return soap_out_ns1__SOF_USCOREGetServerCertificate(soap, tag, id, (const struct ns1__SOF_USCOREGetServerCertificate *)ptr, "ns1:SOF_GetServerCertificate");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse:
		return soap_out_ns1__SOF_USCOREVerifySignedFileResponse(soap, tag, id, (const struct ns1__SOF_USCOREVerifySignedFileResponse *)ptr, "ns1:SOF_VerifySignedFileResponse");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile:
		return soap_out_ns1__SOF_USCOREVerifySignedFile(soap, tag, id, (const struct ns1__SOF_USCOREVerifySignedFile *)ptr, "ns1:SOF_VerifySignedFile");
	case SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse:
		return soap_out_ns1__SOF_USCOREPubKeyEncryptResponse(soap, tag, id, (const struct ns1__SOF_USCOREPubKeyEncryptResponse *)ptr, "ns1:SOF_PubKeyEncryptResponse");
	case SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt:
		return soap_out_ns1__SOF_USCOREPubKeyEncrypt(soap, tag, id, (const struct ns1__SOF_USCOREPubKeyEncrypt *)ptr, "ns1:SOF_PubKeyEncrypt");
	case SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse:
		return soap_out_ns1__SOF_USCOREVerifyTimeStampResponse(soap, tag, id, (const struct ns1__SOF_USCOREVerifyTimeStampResponse *)ptr, "ns1:SOF_VerifyTimeStampResponse");
	case SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp:
		return soap_out_ns1__SOF_USCOREVerifyTimeStamp(soap, tag, id, (const struct ns1__SOF_USCOREVerifyTimeStamp *)ptr, "ns1:SOF_VerifyTimeStamp");
	case SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse:
		return soap_out_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, id, (const struct ns1__SOF_USCOREGetP7SignDataInfoResponse *)ptr, "ns1:SOF_GetP7SignDataInfoResponse");
	case SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo:
		return soap_out_ns1__SOF_USCOREGetP7SignDataInfo(soap, tag, id, (const struct ns1__SOF_USCOREGetP7SignDataInfo *)ptr, "ns1:SOF_GetP7SignDataInfo");
	case SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse:
		return soap_out_ns1__SOF_USCORESetCertTrustListResponse(soap, tag, id, (const struct ns1__SOF_USCORESetCertTrustListResponse *)ptr, "ns1:SOF_SetCertTrustListResponse");
	case SOAP_TYPE_ns1__SOF_USCORESetCertTrustList:
		return soap_out_ns1__SOF_USCORESetCertTrustList(soap, tag, id, (const struct ns1__SOF_USCORESetCertTrustList *)ptr, "ns1:SOF_SetCertTrustList");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response:
		return soap_out_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, id, (const struct ns1__SOF_USCOREVerifySignedDataByP7Response *)ptr, "ns1:SOF_VerifySignedDataByP7Response");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7:
		return soap_out_ns1__SOF_USCOREVerifySignedDataByP7(soap, tag, id, (const struct ns1__SOF_USCOREVerifySignedDataByP7 *)ptr, "ns1:SOF_VerifySignedDataByP7");
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse:
		return soap_out_ns1__SOF_USCOREQueryCertTrustListResponse(soap, tag, id, (const struct ns1__SOF_USCOREQueryCertTrustListResponse *)ptr, "ns1:SOF_QueryCertTrustListResponse");
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList:
		return soap_out_ns1__SOF_USCOREQueryCertTrustList(soap, tag, id, (const struct ns1__SOF_USCOREQueryCertTrustList *)ptr, "ns1:SOF_QueryCertTrustList");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse:
		return soap_out_ns1__SOF_USCOREVerifySignedDataResponse(soap, tag, id, (const struct ns1__SOF_USCOREVerifySignedDataResponse *)ptr, "ns1:SOF_VerifySignedDataResponse");
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedData:
		return soap_out_ns1__SOF_USCOREVerifySignedData(soap, tag, id, (const struct ns1__SOF_USCOREVerifySignedData *)ptr, "ns1:SOF_VerifySignedData");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_out_xsd__base64Binary(soap, tag, id, (const struct xsd__base64Binary *)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptDataResponse:
		return soap_out_PointerTons1__SOF_USCOREEncryptDataResponse(soap, tag, id, (struct ns1__SOF_USCOREEncryptDataResponse *const*)ptr, "ns1:SOF_EncryptDataResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptData:
		return soap_out_PointerTons1__SOF_USCOREEncryptData(soap, tag, id, (struct ns1__SOF_USCOREEncryptData *const*)ptr, "ns1:SOF_EncryptData");
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return soap_out_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, id, (struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*)ptr, "ns1:SOF_QueryCertTrustListAltNamesResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListAltNames:
		return soap_out_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, id, (struct ns1__SOF_USCOREQueryCertTrustListAltNames *const*)ptr, "ns1:SOF_QueryCertTrustListAltNames");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoResponse:
		return soap_out_PointerTons1__SOF_USCOREGetCertInfoResponse(soap, tag, id, (struct ns1__SOF_USCOREGetCertInfoResponse *const*)ptr, "ns1:SOF_GetCertInfoResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfo:
		return soap_out_PointerTons1__SOF_USCOREGetCertInfo(soap, tag, id, (struct ns1__SOF_USCOREGetCertInfo *const*)ptr, "ns1:SOF_GetCertInfo");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataXMLResponse:
		return soap_out_PointerTons1__SOF_USCORESignDataXMLResponse(soap, tag, id, (struct ns1__SOF_USCORESignDataXMLResponse *const*)ptr, "ns1:SOF_SignDataXMLResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataXML:
		return soap_out_PointerTons1__SOF_USCORESignDataXML(soap, tag, id, (struct ns1__SOF_USCORESignDataXML *const*)ptr, "ns1:SOF_SignDataXML");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptDataResponse:
		return soap_out_PointerTons1__SOF_USCOREDecryptDataResponse(soap, tag, id, (struct ns1__SOF_USCOREDecryptDataResponse *const*)ptr, "ns1:SOF_DecryptDataResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptData:
		return soap_out_PointerTons1__SOF_USCOREDecryptData(soap, tag, id, (struct ns1__SOF_USCOREDecryptData *const*)ptr, "ns1:SOF_DecryptData");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataByP7Response:
		return soap_out_PointerTons1__SOF_USCORESignDataByP7Response(soap, tag, id, (struct ns1__SOF_USCORESignDataByP7Response *const*)ptr, "ns1:SOF_SignDataByP7Response");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataByP7:
		return soap_out_PointerTons1__SOF_USCORESignDataByP7(soap, tag, id, (struct ns1__SOF_USCORESignDataByP7 *const*)ptr, "ns1:SOF_SignDataByP7");
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptFileResponse:
		return soap_out_PointerTons1__SOF_USCOREEncryptFileResponse(soap, tag, id, (struct ns1__SOF_USCOREEncryptFileResponse *const*)ptr, "ns1:SOF_EncryptFileResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptFile:
		return soap_out_PointerTons1__SOF_USCOREEncryptFile(soap, tag, id, (struct ns1__SOF_USCOREEncryptFile *const*)ptr, "ns1:SOF_EncryptFile");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetTimeStampInfoResponse:
		return soap_out_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, id, (struct ns1__SOF_USCOREGetTimeStampInfoResponse *const*)ptr, "ns1:SOF_GetTimeStampInfoResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetTimeStampInfo:
		return soap_out_PointerTons1__SOF_USCOREGetTimeStampInfo(soap, tag, id, (struct ns1__SOF_USCOREGetTimeStampInfo *const*)ptr, "ns1:SOF_GetTimeStampInfo");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetSignMethodResponse:
		return soap_out_PointerTons1__SOF_USCORESetSignMethodResponse(soap, tag, id, (struct ns1__SOF_USCORESetSignMethodResponse *const*)ptr, "ns1:SOF_SetSignMethodResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetSignMethod:
		return soap_out_PointerTons1__SOF_USCORESetSignMethod(soap, tag, id, (struct ns1__SOF_USCORESetSignMethod *const*)ptr, "ns1:SOF_SetSignMethod");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptFileResponse:
		return soap_out_PointerTons1__SOF_USCOREDecryptFileResponse(soap, tag, id, (struct ns1__SOF_USCOREDecryptFileResponse *const*)ptr, "ns1:SOF_DecryptFileResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptFile:
		return soap_out_PointerTons1__SOF_USCOREDecryptFile(soap, tag, id, (struct ns1__SOF_USCOREDecryptFile *const*)ptr, "ns1:SOF_DecryptFile");
	case SOAP_TYPE_PointerTons1__GetFileResponse:
		return soap_out_PointerTons1__GetFileResponse(soap, tag, id, (struct ns1__GetFileResponse *const*)ptr, "ns1:GetFileResponse");
	case SOAP_TYPE_PointerTons1__GetFile:
		return soap_out_PointerTons1__GetFile(soap, tag, id, (struct ns1__GetFile *const*)ptr, "ns1:GetFile");
	case SOAP_TYPE_PointerTons1__DeleteFileResponse:
		return soap_out_PointerTons1__DeleteFileResponse(soap, tag, id, (struct ns1__DeleteFileResponse *const*)ptr, "ns1:DeleteFileResponse");
	case SOAP_TYPE_PointerTons1__DeleteFile:
		return soap_out_PointerTons1__DeleteFile(soap, tag, id, (struct ns1__DeleteFile *const*)ptr, "ns1:DeleteFile");
	case SOAP_TYPE_PointerTons1__SOF_USCOREValidateCertResponse:
		return soap_out_PointerTons1__SOF_USCOREValidateCertResponse(soap, tag, id, (struct ns1__SOF_USCOREValidateCertResponse *const*)ptr, "ns1:SOF_ValidateCertResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREValidateCert:
		return soap_out_PointerTons1__SOF_USCOREValidateCert(soap, tag, id, (struct ns1__SOF_USCOREValidateCert *const*)ptr, "ns1:SOF_ValidateCert");
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampResponseResponse:
		return soap_out_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, id, (struct ns1__SOF_USCORECreateTimeStampResponseResponse *const*)ptr, "ns1:SOF_CreateTimeStampResponseResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampResponse:
		return soap_out_PointerTons1__SOF_USCORECreateTimeStampResponse(soap, tag, id, (struct ns1__SOF_USCORECreateTimeStampResponse *const*)ptr, "ns1:SOF_CreateTimeStampResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetEncryptMethodResponse:
		return soap_out_PointerTons1__SOF_USCOREGetEncryptMethodResponse(soap, tag, id, (struct ns1__SOF_USCOREGetEncryptMethodResponse *const*)ptr, "ns1:SOF_GetEncryptMethodResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetEncryptMethod:
		return soap_out_PointerTons1__SOF_USCOREGetEncryptMethod(soap, tag, id, (struct ns1__SOF_USCOREGetEncryptMethod *const*)ptr, "ns1:SOF_GetEncryptMethod");
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampRequestResponse:
		return soap_out_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, id, (struct ns1__SOF_USCORECreateTimeStampRequestResponse *const*)ptr, "ns1:SOF_CreateTimeStampRequestResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampRequest:
		return soap_out_PointerTons1__SOF_USCORECreateTimeStampRequest(soap, tag, id, (struct ns1__SOF_USCORECreateTimeStampRequest *const*)ptr, "ns1:SOF_CreateTimeStampRequest");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetEncryptMethodResponse:
		return soap_out_PointerTons1__SOF_USCORESetEncryptMethodResponse(soap, tag, id, (struct ns1__SOF_USCORESetEncryptMethodResponse *const*)ptr, "ns1:SOF_SetEncryptMethodResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetEncryptMethod:
		return soap_out_PointerTons1__SOF_USCORESetEncryptMethod(soap, tag, id, (struct ns1__SOF_USCORESetEncryptMethod *const*)ptr, "ns1:SOF_SetEncryptMethod");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetWebAppNameResponse:
		return soap_out_PointerTons1__SOF_USCORESetWebAppNameResponse(soap, tag, id, (struct ns1__SOF_USCORESetWebAppNameResponse *const*)ptr, "ns1:SOF_SetWebAppNameResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetWebAppName:
		return soap_out_PointerTons1__SOF_USCORESetWebAppName(soap, tag, id, (struct ns1__SOF_USCORESetWebAppName *const*)ptr, "ns1:SOF_SetWebAppName");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetSignMethodResponse:
		return soap_out_PointerTons1__SOF_USCOREGetSignMethodResponse(soap, tag, id, (struct ns1__SOF_USCOREGetSignMethodResponse *const*)ptr, "ns1:SOF_GetSignMethodResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetSignMethod:
		return soap_out_PointerTons1__SOF_USCOREGetSignMethod(soap, tag, id, (struct ns1__SOF_USCOREGetSignMethod *const*)ptr, "ns1:SOF_GetSignMethod");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGenRandomResponse:
		return soap_out_PointerTons1__SOF_USCOREGenRandomResponse(soap, tag, id, (struct ns1__SOF_USCOREGenRandomResponse *const*)ptr, "ns1:SOF_GenRandomResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGenRandom:
		return soap_out_PointerTons1__SOF_USCOREGenRandom(soap, tag, id, (struct ns1__SOF_USCOREGenRandom *const*)ptr, "ns1:SOF_GenRandom");
	case SOAP_TYPE_PointerTons1__SOF_USCOREPriKeyDecryptResponse:
		return soap_out_PointerTons1__SOF_USCOREPriKeyDecryptResponse(soap, tag, id, (struct ns1__SOF_USCOREPriKeyDecryptResponse *const*)ptr, "ns1:SOF_PriKeyDecryptResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREPriKeyDecrypt:
		return soap_out_PointerTons1__SOF_USCOREPriKeyDecrypt(soap, tag, id, (struct ns1__SOF_USCOREPriKeyDecrypt *const*)ptr, "ns1:SOF_PriKeyDecrypt");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetInstanceResponse:
		return soap_out_PointerTons1__SOF_USCOREGetInstanceResponse(soap, tag, id, (struct ns1__SOF_USCOREGetInstanceResponse *const*)ptr, "ns1:SOF_GetInstanceResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetInstance:
		return soap_out_PointerTons1__SOF_USCOREGetInstance(soap, tag, id, (struct ns1__SOF_USCOREGetInstance *const*)ptr, "ns1:SOF_GetInstance");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignFileResponse:
		return soap_out_PointerTons1__SOF_USCORESignFileResponse(soap, tag, id, (struct ns1__SOF_USCORESignFileResponse *const*)ptr, "ns1:SOF_SignFileResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignFile:
		return soap_out_PointerTons1__SOF_USCORESignFile(soap, tag, id, (struct ns1__SOF_USCORESignFile *const*)ptr, "ns1:SOF_SignFile");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse:
		return soap_out_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, id, (struct ns1__SOF_USCOREVerifySignedDataXMLResponse *const*)ptr, "ns1:SOF_VerifySignedDataXMLResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataXML:
		return soap_out_PointerTons1__SOF_USCOREVerifySignedDataXML(soap, tag, id, (struct ns1__SOF_USCOREVerifySignedDataXML *const*)ptr, "ns1:SOF_VerifySignedDataXML");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataResponse:
		return soap_out_PointerTons1__SOF_USCORESignDataResponse(soap, tag, id, (struct ns1__SOF_USCORESignDataResponse *const*)ptr, "ns1:SOF_SignDataResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESignData:
		return soap_out_PointerTons1__SOF_USCORESignData(soap, tag, id, (struct ns1__SOF_USCORESignData *const*)ptr, "ns1:SOF_SignData");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse:
		return soap_out_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, id, (struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *const*)ptr, "ns1:SOF_GetXMLSignatureInfoResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetXMLSignatureInfo:
		return soap_out_PointerTons1__SOF_USCOREGetXMLSignatureInfo(soap, tag, id, (struct ns1__SOF_USCOREGetXMLSignatureInfo *const*)ptr, "ns1:SOF_GetXMLSignatureInfo");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDelCertTrustListResponse:
		return soap_out_PointerTons1__SOF_USCOREDelCertTrustListResponse(soap, tag, id, (struct ns1__SOF_USCOREDelCertTrustListResponse *const*)ptr, "ns1:SOF_DelCertTrustListResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREDelCertTrustList:
		return soap_out_PointerTons1__SOF_USCOREDelCertTrustList(soap, tag, id, (struct ns1__SOF_USCOREDelCertTrustList *const*)ptr, "ns1:SOF_DelCertTrustList");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetServerCertificateResponse:
		return soap_out_PointerTons1__SOF_USCOREGetServerCertificateResponse(soap, tag, id, (struct ns1__SOF_USCOREGetServerCertificateResponse *const*)ptr, "ns1:SOF_GetServerCertificateResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetServerCertificate:
		return soap_out_PointerTons1__SOF_USCOREGetServerCertificate(soap, tag, id, (struct ns1__SOF_USCOREGetServerCertificate *const*)ptr, "ns1:SOF_GetServerCertificate");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoByOidResponse:
		return soap_out_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, id, (struct ns1__SOF_USCOREGetCertInfoByOidResponse *const*)ptr, "ns1:SOF_GetCertInfoByOidResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoByOid:
		return soap_out_PointerTons1__SOF_USCOREGetCertInfoByOid(soap, tag, id, (struct ns1__SOF_USCOREGetCertInfoByOid *const*)ptr, "ns1:SOF_GetCertInfoByOid");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedFileResponse:
		return soap_out_PointerTons1__SOF_USCOREVerifySignedFileResponse(soap, tag, id, (struct ns1__SOF_USCOREVerifySignedFileResponse *const*)ptr, "ns1:SOF_VerifySignedFileResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedFile:
		return soap_out_PointerTons1__SOF_USCOREVerifySignedFile(soap, tag, id, (struct ns1__SOF_USCOREVerifySignedFile *const*)ptr, "ns1:SOF_VerifySignedFile");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifyTimeStampResponse:
		return soap_out_PointerTons1__SOF_USCOREVerifyTimeStampResponse(soap, tag, id, (struct ns1__SOF_USCOREVerifyTimeStampResponse *const*)ptr, "ns1:SOF_VerifyTimeStampResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifyTimeStamp:
		return soap_out_PointerTons1__SOF_USCOREVerifyTimeStamp(soap, tag, id, (struct ns1__SOF_USCOREVerifyTimeStamp *const*)ptr, "ns1:SOF_VerifyTimeStamp");
	case SOAP_TYPE_PointerTons1__SOF_USCOREPubKeyEncryptResponse:
		return soap_out_PointerTons1__SOF_USCOREPubKeyEncryptResponse(soap, tag, id, (struct ns1__SOF_USCOREPubKeyEncryptResponse *const*)ptr, "ns1:SOF_PubKeyEncryptResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREPubKeyEncrypt:
		return soap_out_PointerTons1__SOF_USCOREPubKeyEncrypt(soap, tag, id, (struct ns1__SOF_USCOREPubKeyEncrypt *const*)ptr, "ns1:SOF_PubKeyEncrypt");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataByP7Response:
		return soap_out_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, id, (struct ns1__SOF_USCOREVerifySignedDataByP7Response *const*)ptr, "ns1:SOF_VerifySignedDataByP7Response");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataByP7:
		return soap_out_PointerTons1__SOF_USCOREVerifySignedDataByP7(soap, tag, id, (struct ns1__SOF_USCOREVerifySignedDataByP7 *const*)ptr, "ns1:SOF_VerifySignedDataByP7");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetCertTrustListResponse:
		return soap_out_PointerTons1__SOF_USCORESetCertTrustListResponse(soap, tag, id, (struct ns1__SOF_USCORESetCertTrustListResponse *const*)ptr, "ns1:SOF_SetCertTrustListResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCORESetCertTrustList:
		return soap_out_PointerTons1__SOF_USCORESetCertTrustList(soap, tag, id, (struct ns1__SOF_USCORESetCertTrustList *const*)ptr, "ns1:SOF_SetCertTrustList");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse:
		return soap_out_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, id, (struct ns1__SOF_USCOREGetP7SignDataInfoResponse *const*)ptr, "ns1:SOF_GetP7SignDataInfoResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetP7SignDataInfo:
		return soap_out_PointerTons1__SOF_USCOREGetP7SignDataInfo(soap, tag, id, (struct ns1__SOF_USCOREGetP7SignDataInfo *const*)ptr, "ns1:SOF_GetP7SignDataInfo");
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListResponse:
		return soap_out_PointerTons1__SOF_USCOREQueryCertTrustListResponse(soap, tag, id, (struct ns1__SOF_USCOREQueryCertTrustListResponse *const*)ptr, "ns1:SOF_QueryCertTrustListResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustList:
		return soap_out_PointerTons1__SOF_USCOREQueryCertTrustList(soap, tag, id, (struct ns1__SOF_USCOREQueryCertTrustList *const*)ptr, "ns1:SOF_QueryCertTrustList");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataResponse:
		return soap_out_PointerTons1__SOF_USCOREVerifySignedDataResponse(soap, tag, id, (struct ns1__SOF_USCOREVerifySignedDataResponse *const*)ptr, "ns1:SOF_VerifySignedDataResponse");
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedData:
		return soap_out_PointerTons1__SOF_USCOREVerifySignedData(soap, tag, id, (struct ns1__SOF_USCOREVerifySignedData *const*)ptr, "ns1:SOF_VerifySignedData");
	case SOAP_TYPE_PointerTons1__sofSecurityEngineDeal:
		return soap_out_PointerTons1__sofSecurityEngineDeal(soap, tag, id, (struct ns1__sofSecurityEngineDeal *const*)ptr, "ns1:sofSecurityEngineDeal");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__SOF_USCOREEncryptData:
		soap_serialize___ns1__SOF_USCOREEncryptData(soap, (const struct __ns1__SOF_USCOREEncryptData *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREQueryCertTrustListAltNames:
		soap_serialize___ns1__SOF_USCOREQueryCertTrustListAltNames(soap, (const struct __ns1__SOF_USCOREQueryCertTrustListAltNames *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetCertInfo:
		soap_serialize___ns1__SOF_USCOREGetCertInfo(soap, (const struct __ns1__SOF_USCOREGetCertInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORESignDataXML:
		soap_serialize___ns1__SOF_USCORESignDataXML(soap, (const struct __ns1__SOF_USCORESignDataXML *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREDecryptData:
		soap_serialize___ns1__SOF_USCOREDecryptData(soap, (const struct __ns1__SOF_USCOREDecryptData *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORESignDataByP7:
		soap_serialize___ns1__SOF_USCORESignDataByP7(soap, (const struct __ns1__SOF_USCORESignDataByP7 *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREEncryptFile:
		soap_serialize___ns1__SOF_USCOREEncryptFile(soap, (const struct __ns1__SOF_USCOREEncryptFile *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetTimeStampInfo:
		soap_serialize___ns1__SOF_USCOREGetTimeStampInfo(soap, (const struct __ns1__SOF_USCOREGetTimeStampInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORESetSignMethod:
		soap_serialize___ns1__SOF_USCORESetSignMethod(soap, (const struct __ns1__SOF_USCORESetSignMethod *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREDecryptFile:
		soap_serialize___ns1__SOF_USCOREDecryptFile(soap, (const struct __ns1__SOF_USCOREDecryptFile *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFile:
		soap_serialize___ns1__GetFile(soap, (const struct __ns1__GetFile *)ptr);
		break;
	case SOAP_TYPE___ns1__DeleteFile:
		soap_serialize___ns1__DeleteFile(soap, (const struct __ns1__DeleteFile *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREValidateCert:
		soap_serialize___ns1__SOF_USCOREValidateCert(soap, (const struct __ns1__SOF_USCOREValidateCert *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORECreateTimeStampResponse:
		soap_serialize___ns1__SOF_USCORECreateTimeStampResponse(soap, (const struct __ns1__SOF_USCORECreateTimeStampResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetEncryptMethod:
		soap_serialize___ns1__SOF_USCOREGetEncryptMethod(soap, (const struct __ns1__SOF_USCOREGetEncryptMethod *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORECreateTimeStampRequest:
		soap_serialize___ns1__SOF_USCORECreateTimeStampRequest(soap, (const struct __ns1__SOF_USCORECreateTimeStampRequest *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORESetEncryptMethod:
		soap_serialize___ns1__SOF_USCORESetEncryptMethod(soap, (const struct __ns1__SOF_USCORESetEncryptMethod *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORESetWebAppName:
		soap_serialize___ns1__SOF_USCORESetWebAppName(soap, (const struct __ns1__SOF_USCORESetWebAppName *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetSignMethod:
		soap_serialize___ns1__SOF_USCOREGetSignMethod(soap, (const struct __ns1__SOF_USCOREGetSignMethod *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGenRandom:
		soap_serialize___ns1__SOF_USCOREGenRandom(soap, (const struct __ns1__SOF_USCOREGenRandom *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREPriKeyDecrypt:
		soap_serialize___ns1__SOF_USCOREPriKeyDecrypt(soap, (const struct __ns1__SOF_USCOREPriKeyDecrypt *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetInstance:
		soap_serialize___ns1__SOF_USCOREGetInstance(soap, (const struct __ns1__SOF_USCOREGetInstance *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORESignFile:
		soap_serialize___ns1__SOF_USCORESignFile(soap, (const struct __ns1__SOF_USCORESignFile *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREVerifySignedDataXML:
		soap_serialize___ns1__SOF_USCOREVerifySignedDataXML(soap, (const struct __ns1__SOF_USCOREVerifySignedDataXML *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORESignData:
		soap_serialize___ns1__SOF_USCORESignData(soap, (const struct __ns1__SOF_USCORESignData *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetXMLSignatureInfo:
		soap_serialize___ns1__SOF_USCOREGetXMLSignatureInfo(soap, (const struct __ns1__SOF_USCOREGetXMLSignatureInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREDelCertTrustList:
		soap_serialize___ns1__SOF_USCOREDelCertTrustList(soap, (const struct __ns1__SOF_USCOREDelCertTrustList *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetServerCertificate:
		soap_serialize___ns1__SOF_USCOREGetServerCertificate(soap, (const struct __ns1__SOF_USCOREGetServerCertificate *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetCertInfoByOid:
		soap_serialize___ns1__SOF_USCOREGetCertInfoByOid(soap, (const struct __ns1__SOF_USCOREGetCertInfoByOid *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREVerifySignedFile:
		soap_serialize___ns1__SOF_USCOREVerifySignedFile(soap, (const struct __ns1__SOF_USCOREVerifySignedFile *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREVerifyTimeStamp:
		soap_serialize___ns1__SOF_USCOREVerifyTimeStamp(soap, (const struct __ns1__SOF_USCOREVerifyTimeStamp *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREPubKeyEncrypt:
		soap_serialize___ns1__SOF_USCOREPubKeyEncrypt(soap, (const struct __ns1__SOF_USCOREPubKeyEncrypt *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREVerifySignedDataByP7:
		soap_serialize___ns1__SOF_USCOREVerifySignedDataByP7(soap, (const struct __ns1__SOF_USCOREVerifySignedDataByP7 *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCORESetCertTrustList:
		soap_serialize___ns1__SOF_USCORESetCertTrustList(soap, (const struct __ns1__SOF_USCORESetCertTrustList *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREGetP7SignDataInfo:
		soap_serialize___ns1__SOF_USCOREGetP7SignDataInfo(soap, (const struct __ns1__SOF_USCOREGetP7SignDataInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREQueryCertTrustList:
		soap_serialize___ns1__SOF_USCOREQueryCertTrustList(soap, (const struct __ns1__SOF_USCOREQueryCertTrustList *)ptr);
		break;
	case SOAP_TYPE___ns1__SOF_USCOREVerifySignedData:
		soap_serialize___ns1__SOF_USCOREVerifySignedData(soap, (const struct __ns1__SOF_USCOREVerifySignedData *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse:
		soap_serialize_ns1__SOF_USCOREEncryptDataResponse(soap, (const struct ns1__SOF_USCOREEncryptDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREEncryptData:
		soap_serialize_ns1__SOF_USCOREEncryptData(soap, (const struct ns1__SOF_USCOREEncryptData *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse:
		soap_serialize_ns1__SOF_USCOREGetCertInfoResponse(soap, (const struct ns1__SOF_USCOREGetCertInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfo:
		soap_serialize_ns1__SOF_USCOREGetCertInfo(soap, (const struct ns1__SOF_USCOREGetCertInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		soap_serialize_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, (const struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames:
		soap_serialize_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, (const struct ns1__SOF_USCOREQueryCertTrustListAltNames *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse:
		soap_serialize_ns1__SOF_USCOREDecryptDataResponse(soap, (const struct ns1__SOF_USCOREDecryptDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREDecryptData:
		soap_serialize_ns1__SOF_USCOREDecryptData(soap, (const struct ns1__SOF_USCOREDecryptData *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse:
		soap_serialize_ns1__SOF_USCORESignDataXMLResponse(soap, (const struct ns1__SOF_USCORESignDataXMLResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESignDataXML:
		soap_serialize_ns1__SOF_USCORESignDataXML(soap, (const struct ns1__SOF_USCORESignDataXML *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse:
		soap_serialize_ns1__SOF_USCOREEncryptFileResponse(soap, (const struct ns1__SOF_USCOREEncryptFileResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREEncryptFile:
		soap_serialize_ns1__SOF_USCOREEncryptFile(soap, (const struct ns1__SOF_USCOREEncryptFile *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response:
		soap_serialize_ns1__SOF_USCORESignDataByP7Response(soap, (const struct ns1__SOF_USCORESignDataByP7Response *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESignDataByP7:
		soap_serialize_ns1__SOF_USCORESignDataByP7(soap, (const struct ns1__SOF_USCORESignDataByP7 *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse:
		soap_serialize_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, (const struct ns1__SOF_USCOREGetTimeStampInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo:
		soap_serialize_ns1__SOF_USCOREGetTimeStampInfo(soap, (const struct ns1__SOF_USCOREGetTimeStampInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse:
		soap_serialize_ns1__SOF_USCORESetSignMethodResponse(soap, (const struct ns1__SOF_USCORESetSignMethodResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESetSignMethod:
		soap_serialize_ns1__SOF_USCORESetSignMethod(soap, (const struct ns1__SOF_USCORESetSignMethod *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse:
		soap_serialize_ns1__SOF_USCOREDecryptFileResponse(soap, (const struct ns1__SOF_USCOREDecryptFileResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREDecryptFile:
		soap_serialize_ns1__SOF_USCOREDecryptFile(soap, (const struct ns1__SOF_USCOREDecryptFile *)ptr);
		break;
	case SOAP_TYPE_ns1__GetFileResponse:
		soap_serialize_ns1__GetFileResponse(soap, (const struct ns1__GetFileResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetFile:
		soap_serialize_ns1__GetFile(soap, (const struct ns1__GetFile *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteFileResponse:
		soap_serialize_ns1__DeleteFileResponse(soap, (const struct ns1__DeleteFileResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteFile:
		soap_serialize_ns1__DeleteFile(soap, (const struct ns1__DeleteFile *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse:
		soap_serialize_ns1__SOF_USCOREValidateCertResponse(soap, (const struct ns1__SOF_USCOREValidateCertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREValidateCert:
		soap_serialize_ns1__SOF_USCOREValidateCert(soap, (const struct ns1__SOF_USCOREValidateCert *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse:
		soap_serialize_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, (const struct ns1__SOF_USCORECreateTimeStampResponseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse:
		soap_serialize_ns1__SOF_USCORECreateTimeStampResponse(soap, (const struct ns1__SOF_USCORECreateTimeStampResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse:
		soap_serialize_ns1__SOF_USCOREGetEncryptMethodResponse(soap, (const struct ns1__SOF_USCOREGetEncryptMethodResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod:
		soap_serialize_ns1__SOF_USCOREGetEncryptMethod(soap, (const struct ns1__SOF_USCOREGetEncryptMethod *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse:
		soap_serialize_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, (const struct ns1__SOF_USCORECreateTimeStampRequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest:
		soap_serialize_ns1__SOF_USCORECreateTimeStampRequest(soap, (const struct ns1__SOF_USCORECreateTimeStampRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse:
		soap_serialize_ns1__SOF_USCORESetEncryptMethodResponse(soap, (const struct ns1__SOF_USCORESetEncryptMethodResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod:
		soap_serialize_ns1__SOF_USCORESetEncryptMethod(soap, (const struct ns1__SOF_USCORESetEncryptMethod *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse:
		soap_serialize_ns1__SOF_USCOREGetSignMethodResponse(soap, (const struct ns1__SOF_USCOREGetSignMethodResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetSignMethod:
		soap_serialize_ns1__SOF_USCOREGetSignMethod(soap, (const struct ns1__SOF_USCOREGetSignMethod *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse:
		soap_serialize_ns1__SOF_USCORESetWebAppNameResponse(soap, (const struct ns1__SOF_USCORESetWebAppNameResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESetWebAppName:
		soap_serialize_ns1__SOF_USCORESetWebAppName(soap, (const struct ns1__SOF_USCORESetWebAppName *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse:
		soap_serialize_ns1__SOF_USCOREGenRandomResponse(soap, (const struct ns1__SOF_USCOREGenRandomResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGenRandom:
		soap_serialize_ns1__SOF_USCOREGenRandom(soap, (const struct ns1__SOF_USCOREGenRandom *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse:
		soap_serialize_ns1__SOF_USCOREPriKeyDecryptResponse(soap, (const struct ns1__SOF_USCOREPriKeyDecryptResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt:
		soap_serialize_ns1__SOF_USCOREPriKeyDecrypt(soap, (const struct ns1__SOF_USCOREPriKeyDecrypt *)ptr);
		break;
	case SOAP_TYPE_ns1__sofSecurityEngineDeal:
		soap_serialize_ns1__sofSecurityEngineDeal(soap, (const struct ns1__sofSecurityEngineDeal *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse:
		soap_serialize_ns1__SOF_USCOREGetInstanceResponse(soap, (const struct ns1__SOF_USCOREGetInstanceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetInstance:
		soap_serialize_ns1__SOF_USCOREGetInstance(soap, (const struct ns1__SOF_USCOREGetInstance *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESignFileResponse:
		soap_serialize_ns1__SOF_USCORESignFileResponse(soap, (const struct ns1__SOF_USCORESignFileResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESignFile:
		soap_serialize_ns1__SOF_USCORESignFile(soap, (const struct ns1__SOF_USCORESignFile *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESignDataResponse:
		soap_serialize_ns1__SOF_USCORESignDataResponse(soap, (const struct ns1__SOF_USCORESignDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESignData:
		soap_serialize_ns1__SOF_USCORESignData(soap, (const struct ns1__SOF_USCORESignData *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse:
		soap_serialize_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, (const struct ns1__SOF_USCOREVerifySignedDataXMLResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML:
		soap_serialize_ns1__SOF_USCOREVerifySignedDataXML(soap, (const struct ns1__SOF_USCOREVerifySignedDataXML *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse:
		soap_serialize_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, (const struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo:
		soap_serialize_ns1__SOF_USCOREGetXMLSignatureInfo(soap, (const struct ns1__SOF_USCOREGetXMLSignatureInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse:
		soap_serialize_ns1__SOF_USCOREDelCertTrustListResponse(soap, (const struct ns1__SOF_USCOREDelCertTrustListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList:
		soap_serialize_ns1__SOF_USCOREDelCertTrustList(soap, (const struct ns1__SOF_USCOREDelCertTrustList *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse:
		soap_serialize_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, (const struct ns1__SOF_USCOREGetCertInfoByOidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid:
		soap_serialize_ns1__SOF_USCOREGetCertInfoByOid(soap, (const struct ns1__SOF_USCOREGetCertInfoByOid *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse:
		soap_serialize_ns1__SOF_USCOREGetServerCertificateResponse(soap, (const struct ns1__SOF_USCOREGetServerCertificateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate:
		soap_serialize_ns1__SOF_USCOREGetServerCertificate(soap, (const struct ns1__SOF_USCOREGetServerCertificate *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse:
		soap_serialize_ns1__SOF_USCOREVerifySignedFileResponse(soap, (const struct ns1__SOF_USCOREVerifySignedFileResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile:
		soap_serialize_ns1__SOF_USCOREVerifySignedFile(soap, (const struct ns1__SOF_USCOREVerifySignedFile *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse:
		soap_serialize_ns1__SOF_USCOREPubKeyEncryptResponse(soap, (const struct ns1__SOF_USCOREPubKeyEncryptResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt:
		soap_serialize_ns1__SOF_USCOREPubKeyEncrypt(soap, (const struct ns1__SOF_USCOREPubKeyEncrypt *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse:
		soap_serialize_ns1__SOF_USCOREVerifyTimeStampResponse(soap, (const struct ns1__SOF_USCOREVerifyTimeStampResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp:
		soap_serialize_ns1__SOF_USCOREVerifyTimeStamp(soap, (const struct ns1__SOF_USCOREVerifyTimeStamp *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse:
		soap_serialize_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, (const struct ns1__SOF_USCOREGetP7SignDataInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo:
		soap_serialize_ns1__SOF_USCOREGetP7SignDataInfo(soap, (const struct ns1__SOF_USCOREGetP7SignDataInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse:
		soap_serialize_ns1__SOF_USCORESetCertTrustListResponse(soap, (const struct ns1__SOF_USCORESetCertTrustListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCORESetCertTrustList:
		soap_serialize_ns1__SOF_USCORESetCertTrustList(soap, (const struct ns1__SOF_USCORESetCertTrustList *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response:
		soap_serialize_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, (const struct ns1__SOF_USCOREVerifySignedDataByP7Response *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7:
		soap_serialize_ns1__SOF_USCOREVerifySignedDataByP7(soap, (const struct ns1__SOF_USCOREVerifySignedDataByP7 *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse:
		soap_serialize_ns1__SOF_USCOREQueryCertTrustListResponse(soap, (const struct ns1__SOF_USCOREQueryCertTrustListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList:
		soap_serialize_ns1__SOF_USCOREQueryCertTrustList(soap, (const struct ns1__SOF_USCOREQueryCertTrustList *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse:
		soap_serialize_ns1__SOF_USCOREVerifySignedDataResponse(soap, (const struct ns1__SOF_USCOREVerifySignedDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SOF_USCOREVerifySignedData:
		soap_serialize_ns1__SOF_USCOREVerifySignedData(soap, (const struct ns1__SOF_USCOREVerifySignedData *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		soap_serialize_xsd__base64Binary(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptDataResponse:
		soap_serialize_PointerTons1__SOF_USCOREEncryptDataResponse(soap, (struct ns1__SOF_USCOREEncryptDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptData:
		soap_serialize_PointerTons1__SOF_USCOREEncryptData(soap, (struct ns1__SOF_USCOREEncryptData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, (struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListAltNames:
		soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(soap, (struct ns1__SOF_USCOREQueryCertTrustListAltNames *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetCertInfoResponse(soap, (struct ns1__SOF_USCOREGetCertInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfo:
		soap_serialize_PointerTons1__SOF_USCOREGetCertInfo(soap, (struct ns1__SOF_USCOREGetCertInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataXMLResponse:
		soap_serialize_PointerTons1__SOF_USCORESignDataXMLResponse(soap, (struct ns1__SOF_USCORESignDataXMLResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataXML:
		soap_serialize_PointerTons1__SOF_USCORESignDataXML(soap, (struct ns1__SOF_USCORESignDataXML *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptDataResponse:
		soap_serialize_PointerTons1__SOF_USCOREDecryptDataResponse(soap, (struct ns1__SOF_USCOREDecryptDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptData:
		soap_serialize_PointerTons1__SOF_USCOREDecryptData(soap, (struct ns1__SOF_USCOREDecryptData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataByP7Response:
		soap_serialize_PointerTons1__SOF_USCORESignDataByP7Response(soap, (struct ns1__SOF_USCORESignDataByP7Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataByP7:
		soap_serialize_PointerTons1__SOF_USCORESignDataByP7(soap, (struct ns1__SOF_USCORESignDataByP7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptFileResponse:
		soap_serialize_PointerTons1__SOF_USCOREEncryptFileResponse(soap, (struct ns1__SOF_USCOREEncryptFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREEncryptFile:
		soap_serialize_PointerTons1__SOF_USCOREEncryptFile(soap, (struct ns1__SOF_USCOREEncryptFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetTimeStampInfoResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(soap, (struct ns1__SOF_USCOREGetTimeStampInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetTimeStampInfo:
		soap_serialize_PointerTons1__SOF_USCOREGetTimeStampInfo(soap, (struct ns1__SOF_USCOREGetTimeStampInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESetSignMethodResponse:
		soap_serialize_PointerTons1__SOF_USCORESetSignMethodResponse(soap, (struct ns1__SOF_USCORESetSignMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESetSignMethod:
		soap_serialize_PointerTons1__SOF_USCORESetSignMethod(soap, (struct ns1__SOF_USCORESetSignMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptFileResponse:
		soap_serialize_PointerTons1__SOF_USCOREDecryptFileResponse(soap, (struct ns1__SOF_USCOREDecryptFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREDecryptFile:
		soap_serialize_PointerTons1__SOF_USCOREDecryptFile(soap, (struct ns1__SOF_USCOREDecryptFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetFileResponse:
		soap_serialize_PointerTons1__GetFileResponse(soap, (struct ns1__GetFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetFile:
		soap_serialize_PointerTons1__GetFile(soap, (struct ns1__GetFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DeleteFileResponse:
		soap_serialize_PointerTons1__DeleteFileResponse(soap, (struct ns1__DeleteFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DeleteFile:
		soap_serialize_PointerTons1__DeleteFile(soap, (struct ns1__DeleteFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREValidateCertResponse:
		soap_serialize_PointerTons1__SOF_USCOREValidateCertResponse(soap, (struct ns1__SOF_USCOREValidateCertResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREValidateCert:
		soap_serialize_PointerTons1__SOF_USCOREValidateCert(soap, (struct ns1__SOF_USCOREValidateCert *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampResponseResponse:
		soap_serialize_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(soap, (struct ns1__SOF_USCORECreateTimeStampResponseResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampResponse:
		soap_serialize_PointerTons1__SOF_USCORECreateTimeStampResponse(soap, (struct ns1__SOF_USCORECreateTimeStampResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetEncryptMethodResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetEncryptMethodResponse(soap, (struct ns1__SOF_USCOREGetEncryptMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetEncryptMethod:
		soap_serialize_PointerTons1__SOF_USCOREGetEncryptMethod(soap, (struct ns1__SOF_USCOREGetEncryptMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampRequestResponse:
		soap_serialize_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(soap, (struct ns1__SOF_USCORECreateTimeStampRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORECreateTimeStampRequest:
		soap_serialize_PointerTons1__SOF_USCORECreateTimeStampRequest(soap, (struct ns1__SOF_USCORECreateTimeStampRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESetEncryptMethodResponse:
		soap_serialize_PointerTons1__SOF_USCORESetEncryptMethodResponse(soap, (struct ns1__SOF_USCORESetEncryptMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESetEncryptMethod:
		soap_serialize_PointerTons1__SOF_USCORESetEncryptMethod(soap, (struct ns1__SOF_USCORESetEncryptMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESetWebAppNameResponse:
		soap_serialize_PointerTons1__SOF_USCORESetWebAppNameResponse(soap, (struct ns1__SOF_USCORESetWebAppNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESetWebAppName:
		soap_serialize_PointerTons1__SOF_USCORESetWebAppName(soap, (struct ns1__SOF_USCORESetWebAppName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetSignMethodResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetSignMethodResponse(soap, (struct ns1__SOF_USCOREGetSignMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetSignMethod:
		soap_serialize_PointerTons1__SOF_USCOREGetSignMethod(soap, (struct ns1__SOF_USCOREGetSignMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGenRandomResponse:
		soap_serialize_PointerTons1__SOF_USCOREGenRandomResponse(soap, (struct ns1__SOF_USCOREGenRandomResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGenRandom:
		soap_serialize_PointerTons1__SOF_USCOREGenRandom(soap, (struct ns1__SOF_USCOREGenRandom *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREPriKeyDecryptResponse:
		soap_serialize_PointerTons1__SOF_USCOREPriKeyDecryptResponse(soap, (struct ns1__SOF_USCOREPriKeyDecryptResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREPriKeyDecrypt:
		soap_serialize_PointerTons1__SOF_USCOREPriKeyDecrypt(soap, (struct ns1__SOF_USCOREPriKeyDecrypt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetInstanceResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetInstanceResponse(soap, (struct ns1__SOF_USCOREGetInstanceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetInstance:
		soap_serialize_PointerTons1__SOF_USCOREGetInstance(soap, (struct ns1__SOF_USCOREGetInstance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESignFileResponse:
		soap_serialize_PointerTons1__SOF_USCORESignFileResponse(soap, (struct ns1__SOF_USCORESignFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESignFile:
		soap_serialize_PointerTons1__SOF_USCORESignFile(soap, (struct ns1__SOF_USCORESignFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse:
		soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(soap, (struct ns1__SOF_USCOREVerifySignedDataXMLResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataXML:
		soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataXML(soap, (struct ns1__SOF_USCOREVerifySignedDataXML *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESignDataResponse:
		soap_serialize_PointerTons1__SOF_USCORESignDataResponse(soap, (struct ns1__SOF_USCORESignDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESignData:
		soap_serialize_PointerTons1__SOF_USCORESignData(soap, (struct ns1__SOF_USCORESignData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(soap, (struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetXMLSignatureInfo:
		soap_serialize_PointerTons1__SOF_USCOREGetXMLSignatureInfo(soap, (struct ns1__SOF_USCOREGetXMLSignatureInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREDelCertTrustListResponse:
		soap_serialize_PointerTons1__SOF_USCOREDelCertTrustListResponse(soap, (struct ns1__SOF_USCOREDelCertTrustListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREDelCertTrustList:
		soap_serialize_PointerTons1__SOF_USCOREDelCertTrustList(soap, (struct ns1__SOF_USCOREDelCertTrustList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetServerCertificateResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetServerCertificateResponse(soap, (struct ns1__SOF_USCOREGetServerCertificateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetServerCertificate:
		soap_serialize_PointerTons1__SOF_USCOREGetServerCertificate(soap, (struct ns1__SOF_USCOREGetServerCertificate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoByOidResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(soap, (struct ns1__SOF_USCOREGetCertInfoByOidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetCertInfoByOid:
		soap_serialize_PointerTons1__SOF_USCOREGetCertInfoByOid(soap, (struct ns1__SOF_USCOREGetCertInfoByOid *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedFileResponse:
		soap_serialize_PointerTons1__SOF_USCOREVerifySignedFileResponse(soap, (struct ns1__SOF_USCOREVerifySignedFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedFile:
		soap_serialize_PointerTons1__SOF_USCOREVerifySignedFile(soap, (struct ns1__SOF_USCOREVerifySignedFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifyTimeStampResponse:
		soap_serialize_PointerTons1__SOF_USCOREVerifyTimeStampResponse(soap, (struct ns1__SOF_USCOREVerifyTimeStampResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifyTimeStamp:
		soap_serialize_PointerTons1__SOF_USCOREVerifyTimeStamp(soap, (struct ns1__SOF_USCOREVerifyTimeStamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREPubKeyEncryptResponse:
		soap_serialize_PointerTons1__SOF_USCOREPubKeyEncryptResponse(soap, (struct ns1__SOF_USCOREPubKeyEncryptResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREPubKeyEncrypt:
		soap_serialize_PointerTons1__SOF_USCOREPubKeyEncrypt(soap, (struct ns1__SOF_USCOREPubKeyEncrypt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataByP7Response:
		soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(soap, (struct ns1__SOF_USCOREVerifySignedDataByP7Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataByP7:
		soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataByP7(soap, (struct ns1__SOF_USCOREVerifySignedDataByP7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESetCertTrustListResponse:
		soap_serialize_PointerTons1__SOF_USCORESetCertTrustListResponse(soap, (struct ns1__SOF_USCORESetCertTrustListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCORESetCertTrustList:
		soap_serialize_PointerTons1__SOF_USCORESetCertTrustList(soap, (struct ns1__SOF_USCORESetCertTrustList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse:
		soap_serialize_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(soap, (struct ns1__SOF_USCOREGetP7SignDataInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREGetP7SignDataInfo:
		soap_serialize_PointerTons1__SOF_USCOREGetP7SignDataInfo(soap, (struct ns1__SOF_USCOREGetP7SignDataInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustListResponse:
		soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustListResponse(soap, (struct ns1__SOF_USCOREQueryCertTrustListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREQueryCertTrustList:
		soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustList(soap, (struct ns1__SOF_USCOREQueryCertTrustList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedDataResponse:
		soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataResponse(soap, (struct ns1__SOF_USCOREVerifySignedDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SOF_USCOREVerifySignedData:
		soap_serialize_PointerTons1__SOF_USCOREVerifySignedData(soap, (struct ns1__SOF_USCOREVerifySignedData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sofSecurityEngineDeal:
		soap_serialize_PointerTons1__sofSecurityEngineDeal(soap, (struct ns1__sofSecurityEngineDeal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	a = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return a;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_new_short(struct soap *soap, int n)
{
	short *p;
	short *a = (short*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(short));
	for (p = a; p && n--; p++)
		soap_default_short(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	if (soap_out_short(soap, tag ? tag : "short", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *p;
	unsigned char *a = (unsigned char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(unsigned char));
	for (p = a; p && n--; p++)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *p;
	unsigned int *a = (unsigned int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(unsigned int));
	for (p = a; p && n--; p++)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (LONG64)xsd__boolean__false_, "false" },
	{ (LONG64)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_new_xsd__boolean(struct soap *soap, int n)
{
	enum xsd__boolean *p;
	enum xsd__boolean *a = (enum xsd__boolean*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum xsd__boolean));
	for (p = a; p && n--; p++)
		soap_default_xsd__boolean(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREEncryptData(struct soap *soap, struct __ns1__SOF_USCOREEncryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREEncryptData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREEncryptData(struct soap *soap, const struct __ns1__SOF_USCOREEncryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREEncryptData(soap, &a->ns1__SOF_USCOREEncryptData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREEncryptData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREEncryptData(soap, "ns1:SOF_EncryptData", -1, &a->ns1__SOF_USCOREEncryptData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_in___ns1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREEncryptData *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREEncryptData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREEncryptData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREEncryptData, sizeof(struct __ns1__SOF_USCOREEncryptData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREEncryptData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREEncryptData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREEncryptData(soap, "ns1:SOF_EncryptData", &a->ns1__SOF_USCOREEncryptData, "ns1:SOF_EncryptData"))
				{	soap_flag_ns1__SOF_USCOREEncryptData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_new___ns1__SOF_USCOREEncryptData(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREEncryptData *p;
	struct __ns1__SOF_USCOREEncryptData *a = (struct __ns1__SOF_USCOREEncryptData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREEncryptData));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREEncryptData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREEncryptData(struct soap *soap, const struct __ns1__SOF_USCOREEncryptData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREEncryptData(soap, tag ? tag : "-ns1:SOF_EncryptData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_get___ns1__SOF_USCOREEncryptData(struct soap *soap, struct __ns1__SOF_USCOREEncryptData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREEncryptData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct __ns1__SOF_USCOREQueryCertTrustListAltNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREQueryCertTrustListAltNames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const struct __ns1__SOF_USCOREQueryCertTrustListAltNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(soap, &a->ns1__SOF_USCOREQueryCertTrustListAltNames);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREQueryCertTrustListAltNames *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(soap, "ns1:SOF_QueryCertTrustListAltNames", -1, &a->ns1__SOF_USCOREQueryCertTrustListAltNames, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_in___ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREQueryCertTrustListAltNames *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREQueryCertTrustListAltNames = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREQueryCertTrustListAltNames *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREQueryCertTrustListAltNames, sizeof(struct __ns1__SOF_USCOREQueryCertTrustListAltNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREQueryCertTrustListAltNames(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREQueryCertTrustListAltNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(soap, "ns1:SOF_QueryCertTrustListAltNames", &a->ns1__SOF_USCOREQueryCertTrustListAltNames, "ns1:SOF_QueryCertTrustListAltNames"))
				{	soap_flag_ns1__SOF_USCOREQueryCertTrustListAltNames--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_new___ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREQueryCertTrustListAltNames *p;
	struct __ns1__SOF_USCOREQueryCertTrustListAltNames *a = (struct __ns1__SOF_USCOREQueryCertTrustListAltNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREQueryCertTrustListAltNames));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREQueryCertTrustListAltNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const struct __ns1__SOF_USCOREQueryCertTrustListAltNames *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREQueryCertTrustListAltNames(soap, tag ? tag : "-ns1:SOF_QueryCertTrustListAltNames", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_get___ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct __ns1__SOF_USCOREQueryCertTrustListAltNames *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetCertInfo(struct soap *soap, struct __ns1__SOF_USCOREGetCertInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetCertInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetCertInfo(struct soap *soap, const struct __ns1__SOF_USCOREGetCertInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetCertInfo(soap, &a->ns1__SOF_USCOREGetCertInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetCertInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetCertInfo(soap, "ns1:SOF_GetCertInfo", -1, &a->ns1__SOF_USCOREGetCertInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetCertInfo *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetCertInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetCertInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetCertInfo, sizeof(struct __ns1__SOF_USCOREGetCertInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetCertInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetCertInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetCertInfo(soap, "ns1:SOF_GetCertInfo", &a->ns1__SOF_USCOREGetCertInfo, "ns1:SOF_GetCertInfo"))
				{	soap_flag_ns1__SOF_USCOREGetCertInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetCertInfo(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetCertInfo *p;
	struct __ns1__SOF_USCOREGetCertInfo *a = (struct __ns1__SOF_USCOREGetCertInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetCertInfo));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetCertInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetCertInfo(struct soap *soap, const struct __ns1__SOF_USCOREGetCertInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetCertInfo(soap, tag ? tag : "-ns1:SOF_GetCertInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetCertInfo(struct soap *soap, struct __ns1__SOF_USCOREGetCertInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetCertInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORESignDataXML(struct soap *soap, struct __ns1__SOF_USCORESignDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORESignDataXML = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORESignDataXML(struct soap *soap, const struct __ns1__SOF_USCORESignDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORESignDataXML(soap, &a->ns1__SOF_USCORESignDataXML);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORESignDataXML *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORESignDataXML(soap, "ns1:SOF_SignDataXML", -1, &a->ns1__SOF_USCORESignDataXML, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_in___ns1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, struct __ns1__SOF_USCORESignDataXML *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORESignDataXML = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORESignDataXML *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORESignDataXML, sizeof(struct __ns1__SOF_USCORESignDataXML), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORESignDataXML(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORESignDataXML && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORESignDataXML(soap, "ns1:SOF_SignDataXML", &a->ns1__SOF_USCORESignDataXML, "ns1:SOF_SignDataXML"))
				{	soap_flag_ns1__SOF_USCORESignDataXML--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_new___ns1__SOF_USCORESignDataXML(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORESignDataXML *p;
	struct __ns1__SOF_USCORESignDataXML *a = (struct __ns1__SOF_USCORESignDataXML*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORESignDataXML));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORESignDataXML(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORESignDataXML(struct soap *soap, const struct __ns1__SOF_USCORESignDataXML *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORESignDataXML(soap, tag ? tag : "-ns1:SOF_SignDataXML", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_get___ns1__SOF_USCORESignDataXML(struct soap *soap, struct __ns1__SOF_USCORESignDataXML *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORESignDataXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREDecryptData(struct soap *soap, struct __ns1__SOF_USCOREDecryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREDecryptData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREDecryptData(struct soap *soap, const struct __ns1__SOF_USCOREDecryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREDecryptData(soap, &a->ns1__SOF_USCOREDecryptData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREDecryptData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREDecryptData(soap, "ns1:SOF_DecryptData", -1, &a->ns1__SOF_USCOREDecryptData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_in___ns1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREDecryptData *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREDecryptData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREDecryptData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREDecryptData, sizeof(struct __ns1__SOF_USCOREDecryptData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREDecryptData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREDecryptData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREDecryptData(soap, "ns1:SOF_DecryptData", &a->ns1__SOF_USCOREDecryptData, "ns1:SOF_DecryptData"))
				{	soap_flag_ns1__SOF_USCOREDecryptData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_new___ns1__SOF_USCOREDecryptData(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREDecryptData *p;
	struct __ns1__SOF_USCOREDecryptData *a = (struct __ns1__SOF_USCOREDecryptData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREDecryptData));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREDecryptData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREDecryptData(struct soap *soap, const struct __ns1__SOF_USCOREDecryptData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREDecryptData(soap, tag ? tag : "-ns1:SOF_DecryptData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_get___ns1__SOF_USCOREDecryptData(struct soap *soap, struct __ns1__SOF_USCOREDecryptData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREDecryptData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORESignDataByP7(struct soap *soap, struct __ns1__SOF_USCORESignDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORESignDataByP7 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORESignDataByP7(struct soap *soap, const struct __ns1__SOF_USCORESignDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORESignDataByP7(soap, &a->ns1__SOF_USCORESignDataByP7);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORESignDataByP7 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORESignDataByP7(soap, "ns1:SOF_SignDataByP7", -1, &a->ns1__SOF_USCORESignDataByP7, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_in___ns1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, struct __ns1__SOF_USCORESignDataByP7 *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORESignDataByP7 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORESignDataByP7 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORESignDataByP7, sizeof(struct __ns1__SOF_USCORESignDataByP7), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORESignDataByP7(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORESignDataByP7 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORESignDataByP7(soap, "ns1:SOF_SignDataByP7", &a->ns1__SOF_USCORESignDataByP7, "ns1:SOF_SignDataByP7"))
				{	soap_flag_ns1__SOF_USCORESignDataByP7--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_new___ns1__SOF_USCORESignDataByP7(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORESignDataByP7 *p;
	struct __ns1__SOF_USCORESignDataByP7 *a = (struct __ns1__SOF_USCORESignDataByP7*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORESignDataByP7));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORESignDataByP7(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORESignDataByP7(struct soap *soap, const struct __ns1__SOF_USCORESignDataByP7 *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORESignDataByP7(soap, tag ? tag : "-ns1:SOF_SignDataByP7", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_get___ns1__SOF_USCORESignDataByP7(struct soap *soap, struct __ns1__SOF_USCORESignDataByP7 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORESignDataByP7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREEncryptFile(struct soap *soap, struct __ns1__SOF_USCOREEncryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREEncryptFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREEncryptFile(struct soap *soap, const struct __ns1__SOF_USCOREEncryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREEncryptFile(soap, &a->ns1__SOF_USCOREEncryptFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREEncryptFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREEncryptFile(soap, "ns1:SOF_EncryptFile", -1, &a->ns1__SOF_USCOREEncryptFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_in___ns1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREEncryptFile *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREEncryptFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREEncryptFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREEncryptFile, sizeof(struct __ns1__SOF_USCOREEncryptFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREEncryptFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREEncryptFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREEncryptFile(soap, "ns1:SOF_EncryptFile", &a->ns1__SOF_USCOREEncryptFile, "ns1:SOF_EncryptFile"))
				{	soap_flag_ns1__SOF_USCOREEncryptFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_new___ns1__SOF_USCOREEncryptFile(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREEncryptFile *p;
	struct __ns1__SOF_USCOREEncryptFile *a = (struct __ns1__SOF_USCOREEncryptFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREEncryptFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREEncryptFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREEncryptFile(struct soap *soap, const struct __ns1__SOF_USCOREEncryptFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREEncryptFile(soap, tag ? tag : "-ns1:SOF_EncryptFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_get___ns1__SOF_USCOREEncryptFile(struct soap *soap, struct __ns1__SOF_USCOREEncryptFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREEncryptFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct __ns1__SOF_USCOREGetTimeStampInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetTimeStampInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const struct __ns1__SOF_USCOREGetTimeStampInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetTimeStampInfo(soap, &a->ns1__SOF_USCOREGetTimeStampInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetTimeStampInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetTimeStampInfo(soap, "ns1:SOF_GetTimeStampInfo", -1, &a->ns1__SOF_USCOREGetTimeStampInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetTimeStampInfo *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetTimeStampInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetTimeStampInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetTimeStampInfo, sizeof(struct __ns1__SOF_USCOREGetTimeStampInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetTimeStampInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetTimeStampInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetTimeStampInfo(soap, "ns1:SOF_GetTimeStampInfo", &a->ns1__SOF_USCOREGetTimeStampInfo, "ns1:SOF_GetTimeStampInfo"))
				{	soap_flag_ns1__SOF_USCOREGetTimeStampInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetTimeStampInfo *p;
	struct __ns1__SOF_USCOREGetTimeStampInfo *a = (struct __ns1__SOF_USCOREGetTimeStampInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetTimeStampInfo));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetTimeStampInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const struct __ns1__SOF_USCOREGetTimeStampInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetTimeStampInfo(soap, tag ? tag : "-ns1:SOF_GetTimeStampInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct __ns1__SOF_USCOREGetTimeStampInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetTimeStampInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORESetSignMethod(struct soap *soap, struct __ns1__SOF_USCORESetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORESetSignMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORESetSignMethod(struct soap *soap, const struct __ns1__SOF_USCORESetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORESetSignMethod(soap, &a->ns1__SOF_USCORESetSignMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORESetSignMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORESetSignMethod(soap, "ns1:SOF_SetSignMethod", -1, &a->ns1__SOF_USCORESetSignMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_in___ns1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, struct __ns1__SOF_USCORESetSignMethod *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORESetSignMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORESetSignMethod *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORESetSignMethod, sizeof(struct __ns1__SOF_USCORESetSignMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORESetSignMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORESetSignMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORESetSignMethod(soap, "ns1:SOF_SetSignMethod", &a->ns1__SOF_USCORESetSignMethod, "ns1:SOF_SetSignMethod"))
				{	soap_flag_ns1__SOF_USCORESetSignMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_new___ns1__SOF_USCORESetSignMethod(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORESetSignMethod *p;
	struct __ns1__SOF_USCORESetSignMethod *a = (struct __ns1__SOF_USCORESetSignMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORESetSignMethod));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORESetSignMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORESetSignMethod(struct soap *soap, const struct __ns1__SOF_USCORESetSignMethod *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORESetSignMethod(soap, tag ? tag : "-ns1:SOF_SetSignMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_get___ns1__SOF_USCORESetSignMethod(struct soap *soap, struct __ns1__SOF_USCORESetSignMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORESetSignMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREDecryptFile(struct soap *soap, struct __ns1__SOF_USCOREDecryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREDecryptFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREDecryptFile(struct soap *soap, const struct __ns1__SOF_USCOREDecryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREDecryptFile(soap, &a->ns1__SOF_USCOREDecryptFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREDecryptFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREDecryptFile(soap, "ns1:SOF_DecryptFile", -1, &a->ns1__SOF_USCOREDecryptFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_in___ns1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREDecryptFile *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREDecryptFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREDecryptFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREDecryptFile, sizeof(struct __ns1__SOF_USCOREDecryptFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREDecryptFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREDecryptFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREDecryptFile(soap, "ns1:SOF_DecryptFile", &a->ns1__SOF_USCOREDecryptFile, "ns1:SOF_DecryptFile"))
				{	soap_flag_ns1__SOF_USCOREDecryptFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_new___ns1__SOF_USCOREDecryptFile(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREDecryptFile *p;
	struct __ns1__SOF_USCOREDecryptFile *a = (struct __ns1__SOF_USCOREDecryptFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREDecryptFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREDecryptFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREDecryptFile(struct soap *soap, const struct __ns1__SOF_USCOREDecryptFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREDecryptFile(soap, tag ? tag : "-ns1:SOF_DecryptFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_get___ns1__SOF_USCOREDecryptFile(struct soap *soap, struct __ns1__SOF_USCOREDecryptFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREDecryptFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFile(struct soap *soap, struct __ns1__GetFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFile(struct soap *soap, const struct __ns1__GetFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__GetFile(soap, &a->ns1__GetFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFile(struct soap *soap, const char *tag, int id, const struct __ns1__GetFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__GetFile(soap, "ns1:GetFile", -1, &a->ns1__GetFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFile * SOAP_FMAC4 soap_in___ns1__GetFile(struct soap *soap, const char *tag, struct __ns1__GetFile *a, const char *type)
{
	size_t soap_flag_ns1__GetFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFile, sizeof(struct __ns1__GetFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GetFile(soap, "ns1:GetFile", &a->ns1__GetFile, "ns1:GetFile"))
				{	soap_flag_ns1__GetFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetFile * SOAP_FMAC4 soap_new___ns1__GetFile(struct soap *soap, int n)
{
	struct __ns1__GetFile *p;
	struct __ns1__GetFile *a = (struct __ns1__GetFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__GetFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__GetFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFile(struct soap *soap, const struct __ns1__GetFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFile(soap, tag ? tag : "-ns1:GetFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFile * SOAP_FMAC4 soap_get___ns1__GetFile(struct soap *soap, struct __ns1__GetFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DeleteFile(struct soap *soap, struct __ns1__DeleteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DeleteFile(struct soap *soap, const struct __ns1__DeleteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DeleteFile(soap, &a->ns1__DeleteFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DeleteFile(struct soap *soap, const char *tag, int id, const struct __ns1__DeleteFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__DeleteFile(soap, "ns1:DeleteFile", -1, &a->ns1__DeleteFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteFile * SOAP_FMAC4 soap_in___ns1__DeleteFile(struct soap *soap, const char *tag, struct __ns1__DeleteFile *a, const char *type)
{
	size_t soap_flag_ns1__DeleteFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DeleteFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DeleteFile, sizeof(struct __ns1__DeleteFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DeleteFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DeleteFile(soap, "ns1:DeleteFile", &a->ns1__DeleteFile, "ns1:DeleteFile"))
				{	soap_flag_ns1__DeleteFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__DeleteFile * SOAP_FMAC4 soap_new___ns1__DeleteFile(struct soap *soap, int n)
{
	struct __ns1__DeleteFile *p;
	struct __ns1__DeleteFile *a = (struct __ns1__DeleteFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__DeleteFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__DeleteFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DeleteFile(struct soap *soap, const struct __ns1__DeleteFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DeleteFile(soap, tag ? tag : "-ns1:DeleteFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteFile * SOAP_FMAC4 soap_get___ns1__DeleteFile(struct soap *soap, struct __ns1__DeleteFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DeleteFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREValidateCert(struct soap *soap, struct __ns1__SOF_USCOREValidateCert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREValidateCert = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREValidateCert(struct soap *soap, const struct __ns1__SOF_USCOREValidateCert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREValidateCert(soap, &a->ns1__SOF_USCOREValidateCert);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREValidateCert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREValidateCert(soap, "ns1:SOF_ValidateCert", -1, &a->ns1__SOF_USCOREValidateCert, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_in___ns1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREValidateCert *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREValidateCert = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREValidateCert *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREValidateCert, sizeof(struct __ns1__SOF_USCOREValidateCert), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREValidateCert(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREValidateCert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREValidateCert(soap, "ns1:SOF_ValidateCert", &a->ns1__SOF_USCOREValidateCert, "ns1:SOF_ValidateCert"))
				{	soap_flag_ns1__SOF_USCOREValidateCert--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_new___ns1__SOF_USCOREValidateCert(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREValidateCert *p;
	struct __ns1__SOF_USCOREValidateCert *a = (struct __ns1__SOF_USCOREValidateCert*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREValidateCert));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREValidateCert(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREValidateCert(struct soap *soap, const struct __ns1__SOF_USCOREValidateCert *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREValidateCert(soap, tag ? tag : "-ns1:SOF_ValidateCert", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_get___ns1__SOF_USCOREValidateCert(struct soap *soap, struct __ns1__SOF_USCOREValidateCert *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREValidateCert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct __ns1__SOF_USCORECreateTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORECreateTimeStampResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const struct __ns1__SOF_USCORECreateTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORECreateTimeStampResponse(soap, &a->ns1__SOF_USCORECreateTimeStampResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORECreateTimeStampResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORECreateTimeStampResponse(soap, "ns1:SOF_CreateTimeStampResponse", -1, &a->ns1__SOF_USCORECreateTimeStampResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_in___ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, struct __ns1__SOF_USCORECreateTimeStampResponse *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORECreateTimeStampResponse = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORECreateTimeStampResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORECreateTimeStampResponse, sizeof(struct __ns1__SOF_USCORECreateTimeStampResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORECreateTimeStampResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORECreateTimeStampResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORECreateTimeStampResponse(soap, "ns1:SOF_CreateTimeStampResponse", &a->ns1__SOF_USCORECreateTimeStampResponse, "ns1:SOF_CreateTimeStampResponse"))
				{	soap_flag_ns1__SOF_USCORECreateTimeStampResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_new___ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORECreateTimeStampResponse *p;
	struct __ns1__SOF_USCORECreateTimeStampResponse *a = (struct __ns1__SOF_USCORECreateTimeStampResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORECreateTimeStampResponse));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORECreateTimeStampResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const struct __ns1__SOF_USCORECreateTimeStampResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORECreateTimeStampResponse(soap, tag ? tag : "-ns1:SOF_CreateTimeStampResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_get___ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct __ns1__SOF_USCORECreateTimeStampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORECreateTimeStampResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct __ns1__SOF_USCOREGetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetEncryptMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, const struct __ns1__SOF_USCOREGetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetEncryptMethod(soap, &a->ns1__SOF_USCOREGetEncryptMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetEncryptMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetEncryptMethod(soap, "ns1:SOF_GetEncryptMethod", -1, &a->ns1__SOF_USCOREGetEncryptMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetEncryptMethod *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetEncryptMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetEncryptMethod *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetEncryptMethod, sizeof(struct __ns1__SOF_USCOREGetEncryptMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetEncryptMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetEncryptMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetEncryptMethod(soap, "ns1:SOF_GetEncryptMethod", &a->ns1__SOF_USCOREGetEncryptMethod, "ns1:SOF_GetEncryptMethod"))
				{	soap_flag_ns1__SOF_USCOREGetEncryptMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetEncryptMethod *p;
	struct __ns1__SOF_USCOREGetEncryptMethod *a = (struct __ns1__SOF_USCOREGetEncryptMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetEncryptMethod));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetEncryptMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, const struct __ns1__SOF_USCOREGetEncryptMethod *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetEncryptMethod(soap, tag ? tag : "-ns1:SOF_GetEncryptMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct __ns1__SOF_USCOREGetEncryptMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetEncryptMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct __ns1__SOF_USCORECreateTimeStampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORECreateTimeStampRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const struct __ns1__SOF_USCORECreateTimeStampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORECreateTimeStampRequest(soap, &a->ns1__SOF_USCORECreateTimeStampRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORECreateTimeStampRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORECreateTimeStampRequest(soap, "ns1:SOF_CreateTimeStampRequest", -1, &a->ns1__SOF_USCORECreateTimeStampRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_in___ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, struct __ns1__SOF_USCORECreateTimeStampRequest *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORECreateTimeStampRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORECreateTimeStampRequest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORECreateTimeStampRequest, sizeof(struct __ns1__SOF_USCORECreateTimeStampRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORECreateTimeStampRequest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORECreateTimeStampRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORECreateTimeStampRequest(soap, "ns1:SOF_CreateTimeStampRequest", &a->ns1__SOF_USCORECreateTimeStampRequest, "ns1:SOF_CreateTimeStampRequest"))
				{	soap_flag_ns1__SOF_USCORECreateTimeStampRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_new___ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORECreateTimeStampRequest *p;
	struct __ns1__SOF_USCORECreateTimeStampRequest *a = (struct __ns1__SOF_USCORECreateTimeStampRequest*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORECreateTimeStampRequest));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORECreateTimeStampRequest(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const struct __ns1__SOF_USCORECreateTimeStampRequest *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORECreateTimeStampRequest(soap, tag ? tag : "-ns1:SOF_CreateTimeStampRequest", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_get___ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct __ns1__SOF_USCORECreateTimeStampRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORECreateTimeStampRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORESetEncryptMethod(struct soap *soap, struct __ns1__SOF_USCORESetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORESetEncryptMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORESetEncryptMethod(struct soap *soap, const struct __ns1__SOF_USCORESetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORESetEncryptMethod(soap, &a->ns1__SOF_USCORESetEncryptMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORESetEncryptMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORESetEncryptMethod(soap, "ns1:SOF_SetEncryptMethod", -1, &a->ns1__SOF_USCORESetEncryptMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_in___ns1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, struct __ns1__SOF_USCORESetEncryptMethod *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORESetEncryptMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORESetEncryptMethod *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORESetEncryptMethod, sizeof(struct __ns1__SOF_USCORESetEncryptMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORESetEncryptMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORESetEncryptMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORESetEncryptMethod(soap, "ns1:SOF_SetEncryptMethod", &a->ns1__SOF_USCORESetEncryptMethod, "ns1:SOF_SetEncryptMethod"))
				{	soap_flag_ns1__SOF_USCORESetEncryptMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_new___ns1__SOF_USCORESetEncryptMethod(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORESetEncryptMethod *p;
	struct __ns1__SOF_USCORESetEncryptMethod *a = (struct __ns1__SOF_USCORESetEncryptMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORESetEncryptMethod));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORESetEncryptMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORESetEncryptMethod(struct soap *soap, const struct __ns1__SOF_USCORESetEncryptMethod *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORESetEncryptMethod(soap, tag ? tag : "-ns1:SOF_SetEncryptMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_get___ns1__SOF_USCORESetEncryptMethod(struct soap *soap, struct __ns1__SOF_USCORESetEncryptMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORESetEncryptMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORESetWebAppName(struct soap *soap, struct __ns1__SOF_USCORESetWebAppName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORESetWebAppName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORESetWebAppName(struct soap *soap, const struct __ns1__SOF_USCORESetWebAppName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORESetWebAppName(soap, &a->ns1__SOF_USCORESetWebAppName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORESetWebAppName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORESetWebAppName(soap, "ns1:SOF_SetWebAppName", -1, &a->ns1__SOF_USCORESetWebAppName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_in___ns1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, struct __ns1__SOF_USCORESetWebAppName *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORESetWebAppName = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORESetWebAppName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORESetWebAppName, sizeof(struct __ns1__SOF_USCORESetWebAppName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORESetWebAppName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORESetWebAppName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORESetWebAppName(soap, "ns1:SOF_SetWebAppName", &a->ns1__SOF_USCORESetWebAppName, "ns1:SOF_SetWebAppName"))
				{	soap_flag_ns1__SOF_USCORESetWebAppName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_new___ns1__SOF_USCORESetWebAppName(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORESetWebAppName *p;
	struct __ns1__SOF_USCORESetWebAppName *a = (struct __ns1__SOF_USCORESetWebAppName*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORESetWebAppName));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORESetWebAppName(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORESetWebAppName(struct soap *soap, const struct __ns1__SOF_USCORESetWebAppName *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORESetWebAppName(soap, tag ? tag : "-ns1:SOF_SetWebAppName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_get___ns1__SOF_USCORESetWebAppName(struct soap *soap, struct __ns1__SOF_USCORESetWebAppName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORESetWebAppName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetSignMethod(struct soap *soap, struct __ns1__SOF_USCOREGetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetSignMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetSignMethod(struct soap *soap, const struct __ns1__SOF_USCOREGetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetSignMethod(soap, &a->ns1__SOF_USCOREGetSignMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetSignMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetSignMethod(soap, "ns1:SOF_GetSignMethod", -1, &a->ns1__SOF_USCOREGetSignMethod, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetSignMethod *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetSignMethod = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetSignMethod *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetSignMethod, sizeof(struct __ns1__SOF_USCOREGetSignMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetSignMethod(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetSignMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetSignMethod(soap, "ns1:SOF_GetSignMethod", &a->ns1__SOF_USCOREGetSignMethod, "ns1:SOF_GetSignMethod"))
				{	soap_flag_ns1__SOF_USCOREGetSignMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetSignMethod(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetSignMethod *p;
	struct __ns1__SOF_USCOREGetSignMethod *a = (struct __ns1__SOF_USCOREGetSignMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetSignMethod));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetSignMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetSignMethod(struct soap *soap, const struct __ns1__SOF_USCOREGetSignMethod *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetSignMethod(soap, tag ? tag : "-ns1:SOF_GetSignMethod", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetSignMethod(struct soap *soap, struct __ns1__SOF_USCOREGetSignMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetSignMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGenRandom(struct soap *soap, struct __ns1__SOF_USCOREGenRandom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGenRandom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGenRandom(struct soap *soap, const struct __ns1__SOF_USCOREGenRandom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGenRandom(soap, &a->ns1__SOF_USCOREGenRandom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGenRandom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGenRandom(soap, "ns1:SOF_GenRandom", -1, &a->ns1__SOF_USCOREGenRandom, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGenRandom *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGenRandom = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGenRandom *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGenRandom, sizeof(struct __ns1__SOF_USCOREGenRandom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGenRandom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGenRandom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGenRandom(soap, "ns1:SOF_GenRandom", &a->ns1__SOF_USCOREGenRandom, "ns1:SOF_GenRandom"))
				{	soap_flag_ns1__SOF_USCOREGenRandom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGenRandom(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGenRandom *p;
	struct __ns1__SOF_USCOREGenRandom *a = (struct __ns1__SOF_USCOREGenRandom*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGenRandom));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGenRandom(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGenRandom(struct soap *soap, const struct __ns1__SOF_USCOREGenRandom *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGenRandom(soap, tag ? tag : "-ns1:SOF_GenRandom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGenRandom(struct soap *soap, struct __ns1__SOF_USCOREGenRandom *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGenRandom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct __ns1__SOF_USCOREPriKeyDecrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREPriKeyDecrypt = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const struct __ns1__SOF_USCOREPriKeyDecrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREPriKeyDecrypt(soap, &a->ns1__SOF_USCOREPriKeyDecrypt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREPriKeyDecrypt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREPriKeyDecrypt(soap, "ns1:SOF_PriKeyDecrypt", -1, &a->ns1__SOF_USCOREPriKeyDecrypt, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_in___ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREPriKeyDecrypt *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREPriKeyDecrypt = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREPriKeyDecrypt *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREPriKeyDecrypt, sizeof(struct __ns1__SOF_USCOREPriKeyDecrypt), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREPriKeyDecrypt(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREPriKeyDecrypt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREPriKeyDecrypt(soap, "ns1:SOF_PriKeyDecrypt", &a->ns1__SOF_USCOREPriKeyDecrypt, "ns1:SOF_PriKeyDecrypt"))
				{	soap_flag_ns1__SOF_USCOREPriKeyDecrypt--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_new___ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREPriKeyDecrypt *p;
	struct __ns1__SOF_USCOREPriKeyDecrypt *a = (struct __ns1__SOF_USCOREPriKeyDecrypt*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREPriKeyDecrypt));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREPriKeyDecrypt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const struct __ns1__SOF_USCOREPriKeyDecrypt *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREPriKeyDecrypt(soap, tag ? tag : "-ns1:SOF_PriKeyDecrypt", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_get___ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct __ns1__SOF_USCOREPriKeyDecrypt *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREPriKeyDecrypt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetInstance(struct soap *soap, struct __ns1__SOF_USCOREGetInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetInstance(struct soap *soap, const struct __ns1__SOF_USCOREGetInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetInstance(soap, &a->ns1__SOF_USCOREGetInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetInstance *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetInstance(soap, "ns1:SOF_GetInstance", -1, &a->ns1__SOF_USCOREGetInstance, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetInstance *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetInstance = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetInstance *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetInstance, sizeof(struct __ns1__SOF_USCOREGetInstance), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetInstance(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetInstance(soap, "ns1:SOF_GetInstance", &a->ns1__SOF_USCOREGetInstance, "ns1:SOF_GetInstance"))
				{	soap_flag_ns1__SOF_USCOREGetInstance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetInstance(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetInstance *p;
	struct __ns1__SOF_USCOREGetInstance *a = (struct __ns1__SOF_USCOREGetInstance*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetInstance));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetInstance(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetInstance(struct soap *soap, const struct __ns1__SOF_USCOREGetInstance *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetInstance(soap, tag ? tag : "-ns1:SOF_GetInstance", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetInstance(struct soap *soap, struct __ns1__SOF_USCOREGetInstance *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORESignFile(struct soap *soap, struct __ns1__SOF_USCORESignFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORESignFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORESignFile(struct soap *soap, const struct __ns1__SOF_USCORESignFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORESignFile(soap, &a->ns1__SOF_USCORESignFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORESignFile(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORESignFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORESignFile(soap, "ns1:SOF_SignFile", -1, &a->ns1__SOF_USCORESignFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignFile * SOAP_FMAC4 soap_in___ns1__SOF_USCORESignFile(struct soap *soap, const char *tag, struct __ns1__SOF_USCORESignFile *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORESignFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORESignFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORESignFile, sizeof(struct __ns1__SOF_USCORESignFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORESignFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORESignFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORESignFile(soap, "ns1:SOF_SignFile", &a->ns1__SOF_USCORESignFile, "ns1:SOF_SignFile"))
				{	soap_flag_ns1__SOF_USCORESignFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignFile * SOAP_FMAC4 soap_new___ns1__SOF_USCORESignFile(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORESignFile *p;
	struct __ns1__SOF_USCORESignFile *a = (struct __ns1__SOF_USCORESignFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORESignFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORESignFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORESignFile(struct soap *soap, const struct __ns1__SOF_USCORESignFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORESignFile(soap, tag ? tag : "-ns1:SOF_SignFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignFile * SOAP_FMAC4 soap_get___ns1__SOF_USCORESignFile(struct soap *soap, struct __ns1__SOF_USCORESignFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORESignFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct __ns1__SOF_USCOREVerifySignedDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREVerifySignedDataXML = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const struct __ns1__SOF_USCOREVerifySignedDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataXML(soap, &a->ns1__SOF_USCOREVerifySignedDataXML);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREVerifySignedDataXML *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedDataXML(soap, "ns1:SOF_VerifySignedDataXML", -1, &a->ns1__SOF_USCOREVerifySignedDataXML, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_in___ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREVerifySignedDataXML *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREVerifySignedDataXML = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREVerifySignedDataXML *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREVerifySignedDataXML, sizeof(struct __ns1__SOF_USCOREVerifySignedDataXML), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREVerifySignedDataXML(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREVerifySignedDataXML && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREVerifySignedDataXML(soap, "ns1:SOF_VerifySignedDataXML", &a->ns1__SOF_USCOREVerifySignedDataXML, "ns1:SOF_VerifySignedDataXML"))
				{	soap_flag_ns1__SOF_USCOREVerifySignedDataXML--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_new___ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREVerifySignedDataXML *p;
	struct __ns1__SOF_USCOREVerifySignedDataXML *a = (struct __ns1__SOF_USCOREVerifySignedDataXML*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREVerifySignedDataXML));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREVerifySignedDataXML(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const struct __ns1__SOF_USCOREVerifySignedDataXML *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREVerifySignedDataXML(soap, tag ? tag : "-ns1:SOF_VerifySignedDataXML", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_get___ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct __ns1__SOF_USCOREVerifySignedDataXML *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREVerifySignedDataXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORESignData(struct soap *soap, struct __ns1__SOF_USCORESignData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORESignData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORESignData(struct soap *soap, const struct __ns1__SOF_USCORESignData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORESignData(soap, &a->ns1__SOF_USCORESignData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORESignData(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORESignData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORESignData(soap, "ns1:SOF_SignData", -1, &a->ns1__SOF_USCORESignData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignData * SOAP_FMAC4 soap_in___ns1__SOF_USCORESignData(struct soap *soap, const char *tag, struct __ns1__SOF_USCORESignData *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORESignData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORESignData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORESignData, sizeof(struct __ns1__SOF_USCORESignData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORESignData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORESignData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORESignData(soap, "ns1:SOF_SignData", &a->ns1__SOF_USCORESignData, "ns1:SOF_SignData"))
				{	soap_flag_ns1__SOF_USCORESignData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignData * SOAP_FMAC4 soap_new___ns1__SOF_USCORESignData(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORESignData *p;
	struct __ns1__SOF_USCORESignData *a = (struct __ns1__SOF_USCORESignData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORESignData));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORESignData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORESignData(struct soap *soap, const struct __ns1__SOF_USCORESignData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORESignData(soap, tag ? tag : "-ns1:SOF_SignData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESignData * SOAP_FMAC4 soap_get___ns1__SOF_USCORESignData(struct soap *soap, struct __ns1__SOF_USCORESignData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORESignData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct __ns1__SOF_USCOREGetXMLSignatureInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetXMLSignatureInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const struct __ns1__SOF_USCOREGetXMLSignatureInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetXMLSignatureInfo(soap, &a->ns1__SOF_USCOREGetXMLSignatureInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetXMLSignatureInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetXMLSignatureInfo(soap, "ns1:SOF_GetXMLSignatureInfo", -1, &a->ns1__SOF_USCOREGetXMLSignatureInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetXMLSignatureInfo *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetXMLSignatureInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetXMLSignatureInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetXMLSignatureInfo, sizeof(struct __ns1__SOF_USCOREGetXMLSignatureInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetXMLSignatureInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetXMLSignatureInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetXMLSignatureInfo(soap, "ns1:SOF_GetXMLSignatureInfo", &a->ns1__SOF_USCOREGetXMLSignatureInfo, "ns1:SOF_GetXMLSignatureInfo"))
				{	soap_flag_ns1__SOF_USCOREGetXMLSignatureInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetXMLSignatureInfo *p;
	struct __ns1__SOF_USCOREGetXMLSignatureInfo *a = (struct __ns1__SOF_USCOREGetXMLSignatureInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetXMLSignatureInfo));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetXMLSignatureInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const struct __ns1__SOF_USCOREGetXMLSignatureInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetXMLSignatureInfo(soap, tag ? tag : "-ns1:SOF_GetXMLSignatureInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct __ns1__SOF_USCOREGetXMLSignatureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetXMLSignatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREDelCertTrustList(struct soap *soap, struct __ns1__SOF_USCOREDelCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREDelCertTrustList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREDelCertTrustList(struct soap *soap, const struct __ns1__SOF_USCOREDelCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREDelCertTrustList(soap, &a->ns1__SOF_USCOREDelCertTrustList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREDelCertTrustList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREDelCertTrustList(soap, "ns1:SOF_DelCertTrustList", -1, &a->ns1__SOF_USCOREDelCertTrustList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_in___ns1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREDelCertTrustList *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREDelCertTrustList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREDelCertTrustList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREDelCertTrustList, sizeof(struct __ns1__SOF_USCOREDelCertTrustList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREDelCertTrustList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREDelCertTrustList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREDelCertTrustList(soap, "ns1:SOF_DelCertTrustList", &a->ns1__SOF_USCOREDelCertTrustList, "ns1:SOF_DelCertTrustList"))
				{	soap_flag_ns1__SOF_USCOREDelCertTrustList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_new___ns1__SOF_USCOREDelCertTrustList(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREDelCertTrustList *p;
	struct __ns1__SOF_USCOREDelCertTrustList *a = (struct __ns1__SOF_USCOREDelCertTrustList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREDelCertTrustList));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREDelCertTrustList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREDelCertTrustList(struct soap *soap, const struct __ns1__SOF_USCOREDelCertTrustList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREDelCertTrustList(soap, tag ? tag : "-ns1:SOF_DelCertTrustList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_get___ns1__SOF_USCOREDelCertTrustList(struct soap *soap, struct __ns1__SOF_USCOREDelCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREDelCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetServerCertificate(struct soap *soap, struct __ns1__SOF_USCOREGetServerCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetServerCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetServerCertificate(struct soap *soap, const struct __ns1__SOF_USCOREGetServerCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetServerCertificate(soap, &a->ns1__SOF_USCOREGetServerCertificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetServerCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetServerCertificate(soap, "ns1:SOF_GetServerCertificate", -1, &a->ns1__SOF_USCOREGetServerCertificate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetServerCertificate *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetServerCertificate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetServerCertificate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetServerCertificate, sizeof(struct __ns1__SOF_USCOREGetServerCertificate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetServerCertificate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetServerCertificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetServerCertificate(soap, "ns1:SOF_GetServerCertificate", &a->ns1__SOF_USCOREGetServerCertificate, "ns1:SOF_GetServerCertificate"))
				{	soap_flag_ns1__SOF_USCOREGetServerCertificate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetServerCertificate(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetServerCertificate *p;
	struct __ns1__SOF_USCOREGetServerCertificate *a = (struct __ns1__SOF_USCOREGetServerCertificate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetServerCertificate));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetServerCertificate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetServerCertificate(struct soap *soap, const struct __ns1__SOF_USCOREGetServerCertificate *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetServerCertificate(soap, tag ? tag : "-ns1:SOF_GetServerCertificate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetServerCertificate(struct soap *soap, struct __ns1__SOF_USCOREGetServerCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetServerCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct __ns1__SOF_USCOREGetCertInfoByOid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetCertInfoByOid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const struct __ns1__SOF_USCOREGetCertInfoByOid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetCertInfoByOid(soap, &a->ns1__SOF_USCOREGetCertInfoByOid);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetCertInfoByOid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetCertInfoByOid(soap, "ns1:SOF_GetCertInfoByOid", -1, &a->ns1__SOF_USCOREGetCertInfoByOid, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetCertInfoByOid *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetCertInfoByOid = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetCertInfoByOid *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetCertInfoByOid, sizeof(struct __ns1__SOF_USCOREGetCertInfoByOid), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetCertInfoByOid(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetCertInfoByOid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetCertInfoByOid(soap, "ns1:SOF_GetCertInfoByOid", &a->ns1__SOF_USCOREGetCertInfoByOid, "ns1:SOF_GetCertInfoByOid"))
				{	soap_flag_ns1__SOF_USCOREGetCertInfoByOid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetCertInfoByOid *p;
	struct __ns1__SOF_USCOREGetCertInfoByOid *a = (struct __ns1__SOF_USCOREGetCertInfoByOid*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetCertInfoByOid));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetCertInfoByOid(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const struct __ns1__SOF_USCOREGetCertInfoByOid *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetCertInfoByOid(soap, tag ? tag : "-ns1:SOF_GetCertInfoByOid", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct __ns1__SOF_USCOREGetCertInfoByOid *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetCertInfoByOid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREVerifySignedFile(struct soap *soap, struct __ns1__SOF_USCOREVerifySignedFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREVerifySignedFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREVerifySignedFile(struct soap *soap, const struct __ns1__SOF_USCOREVerifySignedFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREVerifySignedFile(soap, &a->ns1__SOF_USCOREVerifySignedFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREVerifySignedFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedFile(soap, "ns1:SOF_VerifySignedFile", -1, &a->ns1__SOF_USCOREVerifySignedFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_in___ns1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREVerifySignedFile *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREVerifySignedFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREVerifySignedFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREVerifySignedFile, sizeof(struct __ns1__SOF_USCOREVerifySignedFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREVerifySignedFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREVerifySignedFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREVerifySignedFile(soap, "ns1:SOF_VerifySignedFile", &a->ns1__SOF_USCOREVerifySignedFile, "ns1:SOF_VerifySignedFile"))
				{	soap_flag_ns1__SOF_USCOREVerifySignedFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_new___ns1__SOF_USCOREVerifySignedFile(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREVerifySignedFile *p;
	struct __ns1__SOF_USCOREVerifySignedFile *a = (struct __ns1__SOF_USCOREVerifySignedFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREVerifySignedFile));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREVerifySignedFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREVerifySignedFile(struct soap *soap, const struct __ns1__SOF_USCOREVerifySignedFile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREVerifySignedFile(soap, tag ? tag : "-ns1:SOF_VerifySignedFile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_get___ns1__SOF_USCOREVerifySignedFile(struct soap *soap, struct __ns1__SOF_USCOREVerifySignedFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREVerifySignedFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct __ns1__SOF_USCOREVerifyTimeStamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREVerifyTimeStamp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const struct __ns1__SOF_USCOREVerifyTimeStamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREVerifyTimeStamp(soap, &a->ns1__SOF_USCOREVerifyTimeStamp);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREVerifyTimeStamp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREVerifyTimeStamp(soap, "ns1:SOF_VerifyTimeStamp", -1, &a->ns1__SOF_USCOREVerifyTimeStamp, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_in___ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREVerifyTimeStamp *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREVerifyTimeStamp = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREVerifyTimeStamp *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREVerifyTimeStamp, sizeof(struct __ns1__SOF_USCOREVerifyTimeStamp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREVerifyTimeStamp(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREVerifyTimeStamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREVerifyTimeStamp(soap, "ns1:SOF_VerifyTimeStamp", &a->ns1__SOF_USCOREVerifyTimeStamp, "ns1:SOF_VerifyTimeStamp"))
				{	soap_flag_ns1__SOF_USCOREVerifyTimeStamp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_new___ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREVerifyTimeStamp *p;
	struct __ns1__SOF_USCOREVerifyTimeStamp *a = (struct __ns1__SOF_USCOREVerifyTimeStamp*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREVerifyTimeStamp));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREVerifyTimeStamp(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const struct __ns1__SOF_USCOREVerifyTimeStamp *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREVerifyTimeStamp(soap, tag ? tag : "-ns1:SOF_VerifyTimeStamp", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_get___ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct __ns1__SOF_USCOREVerifyTimeStamp *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREVerifyTimeStamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct __ns1__SOF_USCOREPubKeyEncrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREPubKeyEncrypt = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const struct __ns1__SOF_USCOREPubKeyEncrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREPubKeyEncrypt(soap, &a->ns1__SOF_USCOREPubKeyEncrypt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREPubKeyEncrypt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREPubKeyEncrypt(soap, "ns1:SOF_PubKeyEncrypt", -1, &a->ns1__SOF_USCOREPubKeyEncrypt, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_in___ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREPubKeyEncrypt *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREPubKeyEncrypt = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREPubKeyEncrypt *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREPubKeyEncrypt, sizeof(struct __ns1__SOF_USCOREPubKeyEncrypt), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREPubKeyEncrypt(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREPubKeyEncrypt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREPubKeyEncrypt(soap, "ns1:SOF_PubKeyEncrypt", &a->ns1__SOF_USCOREPubKeyEncrypt, "ns1:SOF_PubKeyEncrypt"))
				{	soap_flag_ns1__SOF_USCOREPubKeyEncrypt--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_new___ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREPubKeyEncrypt *p;
	struct __ns1__SOF_USCOREPubKeyEncrypt *a = (struct __ns1__SOF_USCOREPubKeyEncrypt*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREPubKeyEncrypt));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREPubKeyEncrypt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const struct __ns1__SOF_USCOREPubKeyEncrypt *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREPubKeyEncrypt(soap, tag ? tag : "-ns1:SOF_PubKeyEncrypt", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_get___ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct __ns1__SOF_USCOREPubKeyEncrypt *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREPubKeyEncrypt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct __ns1__SOF_USCOREVerifySignedDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREVerifySignedDataByP7 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const struct __ns1__SOF_USCOREVerifySignedDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataByP7(soap, &a->ns1__SOF_USCOREVerifySignedDataByP7);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREVerifySignedDataByP7 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedDataByP7(soap, "ns1:SOF_VerifySignedDataByP7", -1, &a->ns1__SOF_USCOREVerifySignedDataByP7, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_in___ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREVerifySignedDataByP7 *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREVerifySignedDataByP7 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREVerifySignedDataByP7 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREVerifySignedDataByP7, sizeof(struct __ns1__SOF_USCOREVerifySignedDataByP7), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREVerifySignedDataByP7(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREVerifySignedDataByP7 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREVerifySignedDataByP7(soap, "ns1:SOF_VerifySignedDataByP7", &a->ns1__SOF_USCOREVerifySignedDataByP7, "ns1:SOF_VerifySignedDataByP7"))
				{	soap_flag_ns1__SOF_USCOREVerifySignedDataByP7--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_new___ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREVerifySignedDataByP7 *p;
	struct __ns1__SOF_USCOREVerifySignedDataByP7 *a = (struct __ns1__SOF_USCOREVerifySignedDataByP7*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREVerifySignedDataByP7));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREVerifySignedDataByP7(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const struct __ns1__SOF_USCOREVerifySignedDataByP7 *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREVerifySignedDataByP7(soap, tag ? tag : "-ns1:SOF_VerifySignedDataByP7", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_get___ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct __ns1__SOF_USCOREVerifySignedDataByP7 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREVerifySignedDataByP7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCORESetCertTrustList(struct soap *soap, struct __ns1__SOF_USCORESetCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCORESetCertTrustList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCORESetCertTrustList(struct soap *soap, const struct __ns1__SOF_USCORESetCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCORESetCertTrustList(soap, &a->ns1__SOF_USCORESetCertTrustList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCORESetCertTrustList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCORESetCertTrustList(soap, "ns1:SOF_SetCertTrustList", -1, &a->ns1__SOF_USCORESetCertTrustList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_in___ns1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, struct __ns1__SOF_USCORESetCertTrustList *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCORESetCertTrustList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCORESetCertTrustList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCORESetCertTrustList, sizeof(struct __ns1__SOF_USCORESetCertTrustList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCORESetCertTrustList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCORESetCertTrustList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCORESetCertTrustList(soap, "ns1:SOF_SetCertTrustList", &a->ns1__SOF_USCORESetCertTrustList, "ns1:SOF_SetCertTrustList"))
				{	soap_flag_ns1__SOF_USCORESetCertTrustList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_new___ns1__SOF_USCORESetCertTrustList(struct soap *soap, int n)
{
	struct __ns1__SOF_USCORESetCertTrustList *p;
	struct __ns1__SOF_USCORESetCertTrustList *a = (struct __ns1__SOF_USCORESetCertTrustList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCORESetCertTrustList));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCORESetCertTrustList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCORESetCertTrustList(struct soap *soap, const struct __ns1__SOF_USCORESetCertTrustList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCORESetCertTrustList(soap, tag ? tag : "-ns1:SOF_SetCertTrustList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_get___ns1__SOF_USCORESetCertTrustList(struct soap *soap, struct __ns1__SOF_USCORESetCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCORESetCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct __ns1__SOF_USCOREGetP7SignDataInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREGetP7SignDataInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const struct __ns1__SOF_USCOREGetP7SignDataInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREGetP7SignDataInfo(soap, &a->ns1__SOF_USCOREGetP7SignDataInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREGetP7SignDataInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREGetP7SignDataInfo(soap, "ns1:SOF_GetP7SignDataInfo", -1, &a->ns1__SOF_USCOREGetP7SignDataInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_in___ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREGetP7SignDataInfo *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREGetP7SignDataInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREGetP7SignDataInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREGetP7SignDataInfo, sizeof(struct __ns1__SOF_USCOREGetP7SignDataInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREGetP7SignDataInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREGetP7SignDataInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREGetP7SignDataInfo(soap, "ns1:SOF_GetP7SignDataInfo", &a->ns1__SOF_USCOREGetP7SignDataInfo, "ns1:SOF_GetP7SignDataInfo"))
				{	soap_flag_ns1__SOF_USCOREGetP7SignDataInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_new___ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREGetP7SignDataInfo *p;
	struct __ns1__SOF_USCOREGetP7SignDataInfo *a = (struct __ns1__SOF_USCOREGetP7SignDataInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREGetP7SignDataInfo));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREGetP7SignDataInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const struct __ns1__SOF_USCOREGetP7SignDataInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREGetP7SignDataInfo(soap, tag ? tag : "-ns1:SOF_GetP7SignDataInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_get___ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct __ns1__SOF_USCOREGetP7SignDataInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREGetP7SignDataInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct __ns1__SOF_USCOREQueryCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREQueryCertTrustList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, const struct __ns1__SOF_USCOREQueryCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustList(soap, &a->ns1__SOF_USCOREQueryCertTrustList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREQueryCertTrustList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREQueryCertTrustList(soap, "ns1:SOF_QueryCertTrustList", -1, &a->ns1__SOF_USCOREQueryCertTrustList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_in___ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREQueryCertTrustList *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREQueryCertTrustList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREQueryCertTrustList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREQueryCertTrustList, sizeof(struct __ns1__SOF_USCOREQueryCertTrustList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREQueryCertTrustList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREQueryCertTrustList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREQueryCertTrustList(soap, "ns1:SOF_QueryCertTrustList", &a->ns1__SOF_USCOREQueryCertTrustList, "ns1:SOF_QueryCertTrustList"))
				{	soap_flag_ns1__SOF_USCOREQueryCertTrustList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_new___ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREQueryCertTrustList *p;
	struct __ns1__SOF_USCOREQueryCertTrustList *a = (struct __ns1__SOF_USCOREQueryCertTrustList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREQueryCertTrustList));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREQueryCertTrustList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, const struct __ns1__SOF_USCOREQueryCertTrustList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREQueryCertTrustList(soap, tag ? tag : "-ns1:SOF_QueryCertTrustList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_get___ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct __ns1__SOF_USCOREQueryCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREQueryCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SOF_USCOREVerifySignedData(struct soap *soap, struct __ns1__SOF_USCOREVerifySignedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SOF_USCOREVerifySignedData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SOF_USCOREVerifySignedData(struct soap *soap, const struct __ns1__SOF_USCOREVerifySignedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SOF_USCOREVerifySignedData(soap, &a->ns1__SOF_USCOREVerifySignedData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, int id, const struct __ns1__SOF_USCOREVerifySignedData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedData(soap, "ns1:SOF_VerifySignedData", -1, &a->ns1__SOF_USCOREVerifySignedData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_in___ns1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, struct __ns1__SOF_USCOREVerifySignedData *a, const char *type)
{
	size_t soap_flag_ns1__SOF_USCOREVerifySignedData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SOF_USCOREVerifySignedData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SOF_USCOREVerifySignedData, sizeof(struct __ns1__SOF_USCOREVerifySignedData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SOF_USCOREVerifySignedData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SOF_USCOREVerifySignedData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SOF_USCOREVerifySignedData(soap, "ns1:SOF_VerifySignedData", &a->ns1__SOF_USCOREVerifySignedData, "ns1:SOF_VerifySignedData"))
				{	soap_flag_ns1__SOF_USCOREVerifySignedData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_new___ns1__SOF_USCOREVerifySignedData(struct soap *soap, int n)
{
	struct __ns1__SOF_USCOREVerifySignedData *p;
	struct __ns1__SOF_USCOREVerifySignedData *a = (struct __ns1__SOF_USCOREVerifySignedData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__SOF_USCOREVerifySignedData));
	for (p = a; p && n--; p++)
		soap_default___ns1__SOF_USCOREVerifySignedData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SOF_USCOREVerifySignedData(struct soap *soap, const struct __ns1__SOF_USCOREVerifySignedData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SOF_USCOREVerifySignedData(soap, tag ? tag : "-ns1:SOF_VerifySignedData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_get___ns1__SOF_USCOREVerifySignedData(struct soap *soap, struct __ns1__SOF_USCOREVerifySignedData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SOF_USCOREVerifySignedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREEncryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREEncryptDataResponse(struct soap *soap, const struct ns1__SOF_USCOREEncryptDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREEncryptDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREEncryptDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptDataResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREEncryptDataResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREEncryptDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREEncryptDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse, sizeof(struct ns1__SOF_USCOREEncryptDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREEncryptDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREEncryptDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse, SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse, sizeof(struct ns1__SOF_USCOREEncryptDataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptDataResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREEncryptDataResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREEncryptDataResponse *p;
	struct ns1__SOF_USCOREEncryptDataResponse *a = (struct ns1__SOF_USCOREEncryptDataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREEncryptDataResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREEncryptDataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREEncryptDataResponse(struct soap *soap, const struct ns1__SOF_USCOREEncryptDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREEncryptDataResponse(soap, tag ? tag : "ns1:SOF_EncryptDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptDataResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREEncryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREEncryptDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREEncryptData(struct soap *soap, struct ns1__SOF_USCOREEncryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREEncryptData(struct soap *soap, const struct ns1__SOF_USCOREEncryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->key);
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREEncryptData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREEncryptData), type))
		return soap->error;
	if (soap_out_string(soap, "key", -1, (char*const*)&a->key, ""))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_in_ns1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, struct ns1__SOF_USCOREEncryptData *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREEncryptData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREEncryptData, sizeof(struct ns1__SOF_USCOREEncryptData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREEncryptData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "key", (char**)&a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREEncryptData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREEncryptData, SOAP_TYPE_ns1__SOF_USCOREEncryptData, sizeof(struct ns1__SOF_USCOREEncryptData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_new_ns1__SOF_USCOREEncryptData(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREEncryptData *p;
	struct ns1__SOF_USCOREEncryptData *a = (struct ns1__SOF_USCOREEncryptData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREEncryptData));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREEncryptData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREEncryptData(struct soap *soap, const struct ns1__SOF_USCOREEncryptData *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREEncryptData(soap, tag ? tag : "ns1:SOF_EncryptData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_get_ns1__SOF_USCOREEncryptData(struct soap *soap, struct ns1__SOF_USCOREEncryptData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREEncryptData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetCertInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const struct ns1__SOF_USCOREGetCertInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetCertInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetCertInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetCertInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse, sizeof(struct ns1__SOF_USCOREGetCertInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetCertInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetCertInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse, sizeof(struct ns1__SOF_USCOREGetCertInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetCertInfoResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetCertInfoResponse *p;
	struct ns1__SOF_USCOREGetCertInfoResponse *a = (struct ns1__SOF_USCOREGetCertInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetCertInfoResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetCertInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const struct ns1__SOF_USCOREGetCertInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetCertInfoResponse(soap, tag ? tag : "ns1:SOF_GetCertInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetCertInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetCertInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetCertInfo(struct soap *soap, struct ns1__SOF_USCOREGetCertInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->base64EncodeCert);
	soap_default_int(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetCertInfo(struct soap *soap, const struct ns1__SOF_USCOREGetCertInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->base64EncodeCert);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetCertInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfo), type))
		return soap->error;
	if (soap_out_string(soap, "base64EncodeCert", -1, (char*const*)&a->base64EncodeCert, ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetCertInfo *a, const char *type)
{
	size_t soap_flag_base64EncodeCert = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetCertInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfo, sizeof(struct ns1__SOF_USCOREGetCertInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetCertInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "base64EncodeCert", (char**)&a->base64EncodeCert, "xsd:string"))
				{	soap_flag_base64EncodeCert--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetCertInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetCertInfo, SOAP_TYPE_ns1__SOF_USCOREGetCertInfo, sizeof(struct ns1__SOF_USCOREGetCertInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetCertInfo(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetCertInfo *p;
	struct ns1__SOF_USCOREGetCertInfo *a = (struct ns1__SOF_USCOREGetCertInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetCertInfo));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetCertInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetCertInfo(struct soap *soap, const struct ns1__SOF_USCOREGetCertInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetCertInfo(soap, tag ? tag : "ns1:SOF_GetCertInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetCertInfo(struct soap *soap, struct ns1__SOF_USCOREGetCertInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetCertInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse, sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse, sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *p;
	struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *a = (struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag ? tag : "ns1:SOF_QueryCertTrustListAltNamesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const struct ns1__SOF_USCOREQueryCertTrustListAltNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREQueryCertTrustListAltNames *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_in_ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, struct ns1__SOF_USCOREQueryCertTrustListAltNames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREQueryCertTrustListAltNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames, sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREQueryCertTrustListAltNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames, sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_new_ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREQueryCertTrustListAltNames *p;
	struct ns1__SOF_USCOREQueryCertTrustListAltNames *a = (struct ns1__SOF_USCOREQueryCertTrustListAltNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNames));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const struct ns1__SOF_USCOREQueryCertTrustListAltNames *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, tag ? tag : "ns1:SOF_QueryCertTrustListAltNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_get_ns1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREDecryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREDecryptDataResponse(struct soap *soap, const struct ns1__SOF_USCOREDecryptDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREDecryptDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREDecryptDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptDataResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREDecryptDataResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDecryptDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREDecryptDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse, sizeof(struct ns1__SOF_USCOREDecryptDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREDecryptDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDecryptDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse, SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse, sizeof(struct ns1__SOF_USCOREDecryptDataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptDataResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREDecryptDataResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREDecryptDataResponse *p;
	struct ns1__SOF_USCOREDecryptDataResponse *a = (struct ns1__SOF_USCOREDecryptDataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREDecryptDataResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREDecryptDataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREDecryptDataResponse(struct soap *soap, const struct ns1__SOF_USCOREDecryptDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREDecryptDataResponse(soap, tag ? tag : "ns1:SOF_DecryptDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptDataResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREDecryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREDecryptDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREDecryptData(struct soap *soap, struct ns1__SOF_USCOREDecryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREDecryptData(struct soap *soap, const struct ns1__SOF_USCOREDecryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->key);
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREDecryptData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREDecryptData), type))
		return soap->error;
	if (soap_out_string(soap, "key", -1, (char*const*)&a->key, ""))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_in_ns1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDecryptData *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREDecryptData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREDecryptData, sizeof(struct ns1__SOF_USCOREDecryptData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREDecryptData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "key", (char**)&a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDecryptData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREDecryptData, SOAP_TYPE_ns1__SOF_USCOREDecryptData, sizeof(struct ns1__SOF_USCOREDecryptData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_new_ns1__SOF_USCOREDecryptData(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREDecryptData *p;
	struct ns1__SOF_USCOREDecryptData *a = (struct ns1__SOF_USCOREDecryptData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREDecryptData));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREDecryptData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREDecryptData(struct soap *soap, const struct ns1__SOF_USCOREDecryptData *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREDecryptData(soap, tag ? tag : "ns1:SOF_DecryptData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_get_ns1__SOF_USCOREDecryptData(struct soap *soap, struct ns1__SOF_USCOREDecryptData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREDecryptData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESignDataXMLResponse(struct soap *soap, struct ns1__SOF_USCORESignDataXMLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESignDataXMLResponse(struct soap *soap, const struct ns1__SOF_USCORESignDataXMLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESignDataXMLResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESignDataXMLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXMLResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORESignDataXMLResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataXMLResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESignDataXMLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse, sizeof(struct ns1__SOF_USCORESignDataXMLResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESignDataXMLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataXMLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse, SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse, sizeof(struct ns1__SOF_USCORESignDataXMLResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXMLResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORESignDataXMLResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESignDataXMLResponse *p;
	struct ns1__SOF_USCORESignDataXMLResponse *a = (struct ns1__SOF_USCORESignDataXMLResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESignDataXMLResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESignDataXMLResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESignDataXMLResponse(struct soap *soap, const struct ns1__SOF_USCORESignDataXMLResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESignDataXMLResponse(soap, tag ? tag : "ns1:SOF_SignDataXMLResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXMLResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORESignDataXMLResponse(struct soap *soap, struct ns1__SOF_USCORESignDataXMLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESignDataXMLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESignDataXML(struct soap *soap, struct ns1__SOF_USCORESignDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESignDataXML(struct soap *soap, const struct ns1__SOF_USCORESignDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESignDataXML *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESignDataXML), type))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_in_ns1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataXML *a, const char *type)
{
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESignDataXML *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESignDataXML, sizeof(struct ns1__SOF_USCORESignDataXML), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESignDataXML(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataXML *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESignDataXML, SOAP_TYPE_ns1__SOF_USCORESignDataXML, sizeof(struct ns1__SOF_USCORESignDataXML), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_new_ns1__SOF_USCORESignDataXML(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESignDataXML *p;
	struct ns1__SOF_USCORESignDataXML *a = (struct ns1__SOF_USCORESignDataXML*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESignDataXML));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESignDataXML(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESignDataXML(struct soap *soap, const struct ns1__SOF_USCORESignDataXML *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESignDataXML(soap, tag ? tag : "ns1:SOF_SignDataXML", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_get_ns1__SOF_USCORESignDataXML(struct soap *soap, struct ns1__SOF_USCORESignDataXML *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESignDataXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREEncryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREEncryptFileResponse(struct soap *soap, const struct ns1__SOF_USCOREEncryptFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREEncryptFileResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREEncryptFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFileResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREEncryptFileResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREEncryptFileResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREEncryptFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse, sizeof(struct ns1__SOF_USCOREEncryptFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREEncryptFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREEncryptFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse, SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse, sizeof(struct ns1__SOF_USCOREEncryptFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFileResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREEncryptFileResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREEncryptFileResponse *p;
	struct ns1__SOF_USCOREEncryptFileResponse *a = (struct ns1__SOF_USCOREEncryptFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREEncryptFileResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREEncryptFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREEncryptFileResponse(struct soap *soap, const struct ns1__SOF_USCOREEncryptFileResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREEncryptFileResponse(soap, tag ? tag : "ns1:SOF_EncryptFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFileResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREEncryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREEncryptFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREEncryptFile(struct soap *soap, struct ns1__SOF_USCOREEncryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->inFile);
	soap_default_string(soap, &a->outFile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREEncryptFile(struct soap *soap, const struct ns1__SOF_USCOREEncryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->key);
	soap_serialize_string(soap, (char*const*)&a->inFile);
	soap_serialize_string(soap, (char*const*)&a->outFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREEncryptFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREEncryptFile), type))
		return soap->error;
	if (soap_out_string(soap, "key", -1, (char*const*)&a->key, ""))
		return soap->error;
	if (soap_out_string(soap, "inFile", -1, (char*const*)&a->inFile, ""))
		return soap->error;
	if (soap_out_string(soap, "outFile", -1, (char*const*)&a->outFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_in_ns1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, struct ns1__SOF_USCOREEncryptFile *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_inFile = 1;
	size_t soap_flag_outFile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREEncryptFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREEncryptFile, sizeof(struct ns1__SOF_USCOREEncryptFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREEncryptFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "key", (char**)&a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_inFile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inFile", (char**)&a->inFile, "xsd:string"))
				{	soap_flag_inFile--;
					continue;
				}
			if (soap_flag_outFile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outFile", (char**)&a->outFile, "xsd:string"))
				{	soap_flag_outFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREEncryptFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREEncryptFile, SOAP_TYPE_ns1__SOF_USCOREEncryptFile, sizeof(struct ns1__SOF_USCOREEncryptFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_new_ns1__SOF_USCOREEncryptFile(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREEncryptFile *p;
	struct ns1__SOF_USCOREEncryptFile *a = (struct ns1__SOF_USCOREEncryptFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREEncryptFile));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREEncryptFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREEncryptFile(struct soap *soap, const struct ns1__SOF_USCOREEncryptFile *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREEncryptFile(soap, tag ? tag : "ns1:SOF_EncryptFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_get_ns1__SOF_USCOREEncryptFile(struct soap *soap, struct ns1__SOF_USCOREEncryptFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREEncryptFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESignDataByP7Response(struct soap *soap, struct ns1__SOF_USCORESignDataByP7Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESignDataByP7Response(struct soap *soap, const struct ns1__SOF_USCORESignDataByP7Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESignDataByP7Response(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESignDataByP7Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7Response * SOAP_FMAC4 soap_in_ns1__SOF_USCORESignDataByP7Response(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataByP7Response *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESignDataByP7Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response, sizeof(struct ns1__SOF_USCORESignDataByP7Response), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESignDataByP7Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataByP7Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response, SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response, sizeof(struct ns1__SOF_USCORESignDataByP7Response), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7Response * SOAP_FMAC4 soap_new_ns1__SOF_USCORESignDataByP7Response(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESignDataByP7Response *p;
	struct ns1__SOF_USCORESignDataByP7Response *a = (struct ns1__SOF_USCORESignDataByP7Response*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESignDataByP7Response));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESignDataByP7Response(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESignDataByP7Response(struct soap *soap, const struct ns1__SOF_USCORESignDataByP7Response *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESignDataByP7Response(soap, tag ? tag : "ns1:SOF_SignDataByP7Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7Response * SOAP_FMAC4 soap_get_ns1__SOF_USCORESignDataByP7Response(struct soap *soap, struct ns1__SOF_USCORESignDataByP7Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESignDataByP7Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESignDataByP7(struct soap *soap, struct ns1__SOF_USCORESignDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESignDataByP7(struct soap *soap, const struct ns1__SOF_USCORESignDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESignDataByP7 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESignDataByP7), type))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_in_ns1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataByP7 *a, const char *type)
{
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESignDataByP7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESignDataByP7, sizeof(struct ns1__SOF_USCORESignDataByP7), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESignDataByP7(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataByP7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESignDataByP7, SOAP_TYPE_ns1__SOF_USCORESignDataByP7, sizeof(struct ns1__SOF_USCORESignDataByP7), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_new_ns1__SOF_USCORESignDataByP7(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESignDataByP7 *p;
	struct ns1__SOF_USCORESignDataByP7 *a = (struct ns1__SOF_USCORESignDataByP7*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESignDataByP7));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESignDataByP7(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESignDataByP7(struct soap *soap, const struct ns1__SOF_USCORESignDataByP7 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESignDataByP7(soap, tag ? tag : "ns1:SOF_SignDataByP7", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_get_ns1__SOF_USCORESignDataByP7(struct soap *soap, struct ns1__SOF_USCORESignDataByP7 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESignDataByP7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const struct ns1__SOF_USCOREGetTimeStampInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetTimeStampInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfoResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetTimeStampInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetTimeStampInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse, sizeof(struct ns1__SOF_USCOREGetTimeStampInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetTimeStampInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse, sizeof(struct ns1__SOF_USCOREGetTimeStampInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfoResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetTimeStampInfoResponse *p;
	struct ns1__SOF_USCOREGetTimeStampInfoResponse *a = (struct ns1__SOF_USCOREGetTimeStampInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetTimeStampInfoResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const struct ns1__SOF_USCOREGetTimeStampInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, tag ? tag : "ns1:SOF_GetTimeStampInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfoResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->tsResponseData);
	soap_default_int(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const struct ns1__SOF_USCOREGetTimeStampInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->tsResponseData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetTimeStampInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo), type))
		return soap->error;
	if (soap_out_string(soap, "tsResponseData", -1, (char*const*)&a->tsResponseData, ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetTimeStampInfo *a, const char *type)
{
	size_t soap_flag_tsResponseData = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetTimeStampInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo, sizeof(struct ns1__SOF_USCOREGetTimeStampInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetTimeStampInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tsResponseData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tsResponseData", (char**)&a->tsResponseData, "xsd:string"))
				{	soap_flag_tsResponseData--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetTimeStampInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo, sizeof(struct ns1__SOF_USCOREGetTimeStampInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetTimeStampInfo *p;
	struct ns1__SOF_USCOREGetTimeStampInfo *a = (struct ns1__SOF_USCOREGetTimeStampInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetTimeStampInfo));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetTimeStampInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const struct ns1__SOF_USCOREGetTimeStampInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetTimeStampInfo(soap, tag ? tag : "ns1:SOF_GetTimeStampInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetTimeStampInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetSignMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESetSignMethodResponse(struct soap *soap, const struct ns1__SOF_USCORESetSignMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESetSignMethodResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESetSignMethodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethodResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORESetSignMethodResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetSignMethodResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESetSignMethodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse, sizeof(struct ns1__SOF_USCORESetSignMethodResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESetSignMethodResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetSignMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse, SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse, sizeof(struct ns1__SOF_USCORESetSignMethodResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethodResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORESetSignMethodResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESetSignMethodResponse *p;
	struct ns1__SOF_USCORESetSignMethodResponse *a = (struct ns1__SOF_USCORESetSignMethodResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESetSignMethodResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESetSignMethodResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESetSignMethodResponse(struct soap *soap, const struct ns1__SOF_USCORESetSignMethodResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESetSignMethodResponse(soap, tag ? tag : "ns1:SOF_SetSignMethodResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethodResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORESetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetSignMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESetSignMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESetSignMethod(struct soap *soap, struct ns1__SOF_USCORESetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->signMethod);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESetSignMethod(struct soap *soap, const struct ns1__SOF_USCORESetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESetSignMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESetSignMethod), type))
		return soap->error;
	if (soap_out_int(soap, "signMethod", -1, &a->signMethod, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_in_ns1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetSignMethod *a, const char *type)
{
	size_t soap_flag_signMethod = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESetSignMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESetSignMethod, sizeof(struct ns1__SOF_USCORESetSignMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESetSignMethod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "signMethod", &a->signMethod, "xsd:int"))
				{	soap_flag_signMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_signMethod > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetSignMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESetSignMethod, SOAP_TYPE_ns1__SOF_USCORESetSignMethod, sizeof(struct ns1__SOF_USCORESetSignMethod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_new_ns1__SOF_USCORESetSignMethod(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESetSignMethod *p;
	struct ns1__SOF_USCORESetSignMethod *a = (struct ns1__SOF_USCORESetSignMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESetSignMethod));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESetSignMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESetSignMethod(struct soap *soap, const struct ns1__SOF_USCORESetSignMethod *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESetSignMethod(soap, tag ? tag : "ns1:SOF_SetSignMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_get_ns1__SOF_USCORESetSignMethod(struct soap *soap, struct ns1__SOF_USCORESetSignMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESetSignMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREDecryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREDecryptFileResponse(struct soap *soap, const struct ns1__SOF_USCOREDecryptFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREDecryptFileResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREDecryptFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFileResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREDecryptFileResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDecryptFileResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREDecryptFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse, sizeof(struct ns1__SOF_USCOREDecryptFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREDecryptFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDecryptFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse, SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse, sizeof(struct ns1__SOF_USCOREDecryptFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFileResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREDecryptFileResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREDecryptFileResponse *p;
	struct ns1__SOF_USCOREDecryptFileResponse *a = (struct ns1__SOF_USCOREDecryptFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREDecryptFileResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREDecryptFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREDecryptFileResponse(struct soap *soap, const struct ns1__SOF_USCOREDecryptFileResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREDecryptFileResponse(soap, tag ? tag : "ns1:SOF_DecryptFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFileResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREDecryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREDecryptFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREDecryptFile(struct soap *soap, struct ns1__SOF_USCOREDecryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->inFile);
	soap_default_string(soap, &a->outFile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREDecryptFile(struct soap *soap, const struct ns1__SOF_USCOREDecryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->key);
	soap_serialize_string(soap, (char*const*)&a->inFile);
	soap_serialize_string(soap, (char*const*)&a->outFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREDecryptFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREDecryptFile), type))
		return soap->error;
	if (soap_out_string(soap, "key", -1, (char*const*)&a->key, ""))
		return soap->error;
	if (soap_out_string(soap, "inFile", -1, (char*const*)&a->inFile, ""))
		return soap->error;
	if (soap_out_string(soap, "outFile", -1, (char*const*)&a->outFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_in_ns1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDecryptFile *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_inFile = 1;
	size_t soap_flag_outFile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREDecryptFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREDecryptFile, sizeof(struct ns1__SOF_USCOREDecryptFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREDecryptFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "key", (char**)&a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_inFile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inFile", (char**)&a->inFile, "xsd:string"))
				{	soap_flag_inFile--;
					continue;
				}
			if (soap_flag_outFile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outFile", (char**)&a->outFile, "xsd:string"))
				{	soap_flag_outFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDecryptFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREDecryptFile, SOAP_TYPE_ns1__SOF_USCOREDecryptFile, sizeof(struct ns1__SOF_USCOREDecryptFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_new_ns1__SOF_USCOREDecryptFile(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREDecryptFile *p;
	struct ns1__SOF_USCOREDecryptFile *a = (struct ns1__SOF_USCOREDecryptFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREDecryptFile));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREDecryptFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREDecryptFile(struct soap *soap, const struct ns1__SOF_USCOREDecryptFile *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREDecryptFile(soap, tag ? tag : "ns1:SOF_DecryptFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_get_ns1__SOF_USCOREDecryptFile(struct soap *soap, struct ns1__SOF_USCOREDecryptFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREDecryptFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetFileResponse(struct soap *soap, struct ns1__GetFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__base64Binary(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetFileResponse(struct soap *soap, const struct ns1__GetFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__base64Binary(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetFileResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetFileResponse), type))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetFileResponse * SOAP_FMAC4 soap_in_ns1__GetFileResponse(struct soap *soap, const char *tag, struct ns1__GetFileResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetFileResponse, sizeof(struct ns1__GetFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__base64Binary(soap, "return", &a->return_, "xsd:base64Binary"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetFileResponse, SOAP_TYPE_ns1__GetFileResponse, sizeof(struct ns1__GetFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__GetFileResponse * SOAP_FMAC4 soap_new_ns1__GetFileResponse(struct soap *soap, int n)
{
	struct ns1__GetFileResponse *p;
	struct ns1__GetFileResponse *a = (struct ns1__GetFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__GetFileResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__GetFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetFileResponse(struct soap *soap, const struct ns1__GetFileResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetFileResponse(soap, tag ? tag : "ns1:GetFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetFileResponse * SOAP_FMAC4 soap_get_ns1__GetFileResponse(struct soap *soap, struct ns1__GetFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetFile(struct soap *soap, struct ns1__GetFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->requestFileName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetFile(struct soap *soap, const struct ns1__GetFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->requestFileName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetFile(struct soap *soap, const char *tag, int id, const struct ns1__GetFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetFile), type))
		return soap->error;
	if (soap_out_string(soap, "requestFileName", -1, (char*const*)&a->requestFileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetFile * SOAP_FMAC4 soap_in_ns1__GetFile(struct soap *soap, const char *tag, struct ns1__GetFile *a, const char *type)
{
	size_t soap_flag_requestFileName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetFile, sizeof(struct ns1__GetFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestFileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "requestFileName", (char**)&a->requestFileName, "xsd:string"))
				{	soap_flag_requestFileName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetFile, SOAP_TYPE_ns1__GetFile, sizeof(struct ns1__GetFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__GetFile * SOAP_FMAC4 soap_new_ns1__GetFile(struct soap *soap, int n)
{
	struct ns1__GetFile *p;
	struct ns1__GetFile *a = (struct ns1__GetFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__GetFile));
	for (p = a; p && n--; p++)
		soap_default_ns1__GetFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetFile(struct soap *soap, const struct ns1__GetFile *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetFile(soap, tag ? tag : "ns1:GetFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetFile * SOAP_FMAC4 soap_get_ns1__GetFile(struct soap *soap, struct ns1__GetFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteFileResponse(struct soap *soap, struct ns1__DeleteFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteFileResponse(struct soap *soap, const struct ns1__DeleteFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteFileResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteFileResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteFileResponse * SOAP_FMAC4 soap_in_ns1__DeleteFileResponse(struct soap *soap, const char *tag, struct ns1__DeleteFileResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteFileResponse, sizeof(struct ns1__DeleteFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteFileResponse, SOAP_TYPE_ns1__DeleteFileResponse, sizeof(struct ns1__DeleteFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeleteFileResponse * SOAP_FMAC4 soap_new_ns1__DeleteFileResponse(struct soap *soap, int n)
{
	struct ns1__DeleteFileResponse *p;
	struct ns1__DeleteFileResponse *a = (struct ns1__DeleteFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeleteFileResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeleteFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteFileResponse(struct soap *soap, const struct ns1__DeleteFileResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteFileResponse(soap, tag ? tag : "ns1:DeleteFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteFileResponse * SOAP_FMAC4 soap_get_ns1__DeleteFileResponse(struct soap *soap, struct ns1__DeleteFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteFile(struct soap *soap, struct ns1__DeleteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteFile(struct soap *soap, const struct ns1__DeleteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->fileName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteFile(struct soap *soap, const char *tag, int id, const struct ns1__DeleteFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteFile), type))
		return soap->error;
	if (soap_out_string(soap, "fileName", -1, (char*const*)&a->fileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteFile * SOAP_FMAC4 soap_in_ns1__DeleteFile(struct soap *soap, const char *tag, struct ns1__DeleteFile *a, const char *type)
{
	size_t soap_flag_fileName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteFile, sizeof(struct ns1__DeleteFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileName", (char**)&a->fileName, "xsd:string"))
				{	soap_flag_fileName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteFile, SOAP_TYPE_ns1__DeleteFile, sizeof(struct ns1__DeleteFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeleteFile * SOAP_FMAC4 soap_new_ns1__DeleteFile(struct soap *soap, int n)
{
	struct ns1__DeleteFile *p;
	struct ns1__DeleteFile *a = (struct ns1__DeleteFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeleteFile));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeleteFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteFile(struct soap *soap, const struct ns1__DeleteFile *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteFile(soap, tag ? tag : "ns1:DeleteFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteFile * SOAP_FMAC4 soap_get_ns1__DeleteFile(struct soap *soap, struct ns1__DeleteFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREValidateCertResponse(struct soap *soap, struct ns1__SOF_USCOREValidateCertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREValidateCertResponse(struct soap *soap, const struct ns1__SOF_USCOREValidateCertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREValidateCertResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREValidateCertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCertResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREValidateCertResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREValidateCertResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREValidateCertResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse, sizeof(struct ns1__SOF_USCOREValidateCertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREValidateCertResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREValidateCertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse, SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse, sizeof(struct ns1__SOF_USCOREValidateCertResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCertResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREValidateCertResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREValidateCertResponse *p;
	struct ns1__SOF_USCOREValidateCertResponse *a = (struct ns1__SOF_USCOREValidateCertResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREValidateCertResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREValidateCertResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREValidateCertResponse(struct soap *soap, const struct ns1__SOF_USCOREValidateCertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREValidateCertResponse(soap, tag ? tag : "ns1:SOF_ValidateCertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCertResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREValidateCertResponse(struct soap *soap, struct ns1__SOF_USCOREValidateCertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREValidateCertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREValidateCert(struct soap *soap, struct ns1__SOF_USCOREValidateCert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->base64EncodeCert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREValidateCert(struct soap *soap, const struct ns1__SOF_USCOREValidateCert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->base64EncodeCert);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREValidateCert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREValidateCert), type))
		return soap->error;
	if (soap_out_string(soap, "base64EncodeCert", -1, (char*const*)&a->base64EncodeCert, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_in_ns1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, struct ns1__SOF_USCOREValidateCert *a, const char *type)
{
	size_t soap_flag_base64EncodeCert = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREValidateCert *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREValidateCert, sizeof(struct ns1__SOF_USCOREValidateCert), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREValidateCert(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "base64EncodeCert", (char**)&a->base64EncodeCert, "xsd:string"))
				{	soap_flag_base64EncodeCert--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREValidateCert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREValidateCert, SOAP_TYPE_ns1__SOF_USCOREValidateCert, sizeof(struct ns1__SOF_USCOREValidateCert), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_new_ns1__SOF_USCOREValidateCert(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREValidateCert *p;
	struct ns1__SOF_USCOREValidateCert *a = (struct ns1__SOF_USCOREValidateCert*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREValidateCert));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREValidateCert(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREValidateCert(struct soap *soap, const struct ns1__SOF_USCOREValidateCert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREValidateCert(soap, tag ? tag : "ns1:SOF_ValidateCert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_get_ns1__SOF_USCOREValidateCert(struct soap *soap, struct ns1__SOF_USCOREValidateCert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREValidateCert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const struct ns1__SOF_USCORECreateTimeStampResponseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORECreateTimeStampResponseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponseResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORECreateTimeStampResponseResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORECreateTimeStampResponseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampResponseResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORECreateTimeStampResponseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampResponseResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponseResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORECreateTimeStampResponseResponse *p;
	struct ns1__SOF_USCORECreateTimeStampResponseResponse *a = (struct ns1__SOF_USCORECreateTimeStampResponseResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORECreateTimeStampResponseResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const struct ns1__SOF_USCORECreateTimeStampResponseResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, tag ? tag : "ns1:SOF_CreateTimeStampResponseResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponseResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const struct ns1__SOF_USCORECreateTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORECreateTimeStampResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse), type))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORECreateTimeStampResponse *a, const char *type)
{
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORECreateTimeStampResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORECreateTimeStampResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORECreateTimeStampResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORECreateTimeStampResponse *p;
	struct ns1__SOF_USCORECreateTimeStampResponse *a = (struct ns1__SOF_USCORECreateTimeStampResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORECreateTimeStampResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORECreateTimeStampResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const struct ns1__SOF_USCORECreateTimeStampResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORECreateTimeStampResponse(soap, tag ? tag : "ns1:SOF_CreateTimeStampResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORECreateTimeStampResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const struct ns1__SOF_USCOREGetEncryptMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetEncryptMethodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethodResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetEncryptMethodResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetEncryptMethodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse, sizeof(struct ns1__SOF_USCOREGetEncryptMethodResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetEncryptMethodResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetEncryptMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse, sizeof(struct ns1__SOF_USCOREGetEncryptMethodResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethodResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetEncryptMethodResponse *p;
	struct ns1__SOF_USCOREGetEncryptMethodResponse *a = (struct ns1__SOF_USCOREGetEncryptMethodResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetEncryptMethodResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetEncryptMethodResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const struct ns1__SOF_USCOREGetEncryptMethodResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetEncryptMethodResponse(soap, tag ? tag : "ns1:SOF_GetEncryptMethodResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethodResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetEncryptMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, const struct ns1__SOF_USCOREGetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetEncryptMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetEncryptMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetEncryptMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod, sizeof(struct ns1__SOF_USCOREGetEncryptMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetEncryptMethod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetEncryptMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod, sizeof(struct ns1__SOF_USCOREGetEncryptMethod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetEncryptMethod *p;
	struct ns1__SOF_USCOREGetEncryptMethod *a = (struct ns1__SOF_USCOREGetEncryptMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetEncryptMethod));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetEncryptMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, const struct ns1__SOF_USCOREGetEncryptMethod *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetEncryptMethod(soap, tag ? tag : "ns1:SOF_GetEncryptMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetEncryptMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const struct ns1__SOF_USCORECreateTimeStampRequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORECreateTimeStampRequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequestResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORECreateTimeStampRequestResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORECreateTimeStampRequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampRequestResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORECreateTimeStampRequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampRequestResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequestResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORECreateTimeStampRequestResponse *p;
	struct ns1__SOF_USCORECreateTimeStampRequestResponse *a = (struct ns1__SOF_USCORECreateTimeStampRequestResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORECreateTimeStampRequestResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const struct ns1__SOF_USCORECreateTimeStampRequestResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, tag ? tag : "ns1:SOF_CreateTimeStampRequestResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequestResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const struct ns1__SOF_USCORECreateTimeStampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORECreateTimeStampRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest), type))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_in_ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, struct ns1__SOF_USCORECreateTimeStampRequest *a, const char *type)
{
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORECreateTimeStampRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest, sizeof(struct ns1__SOF_USCORECreateTimeStampRequest), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORECreateTimeStampRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORECreateTimeStampRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest, sizeof(struct ns1__SOF_USCORECreateTimeStampRequest), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_new_ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, int n)
{
	struct ns1__SOF_USCORECreateTimeStampRequest *p;
	struct ns1__SOF_USCORECreateTimeStampRequest *a = (struct ns1__SOF_USCORECreateTimeStampRequest*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORECreateTimeStampRequest));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORECreateTimeStampRequest(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const struct ns1__SOF_USCORECreateTimeStampRequest *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORECreateTimeStampRequest(soap, tag ? tag : "ns1:SOF_CreateTimeStampRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_get_ns1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORECreateTimeStampRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const struct ns1__SOF_USCORESetEncryptMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESetEncryptMethodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethodResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetEncryptMethodResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESetEncryptMethodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse, sizeof(struct ns1__SOF_USCORESetEncryptMethodResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESetEncryptMethodResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetEncryptMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse, sizeof(struct ns1__SOF_USCORESetEncryptMethodResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethodResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESetEncryptMethodResponse *p;
	struct ns1__SOF_USCORESetEncryptMethodResponse *a = (struct ns1__SOF_USCORESetEncryptMethodResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESetEncryptMethodResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESetEncryptMethodResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const struct ns1__SOF_USCORESetEncryptMethodResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESetEncryptMethodResponse(soap, tag ? tag : "ns1:SOF_SetEncryptMethodResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethodResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESetEncryptMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESetEncryptMethod(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->encryptMethod);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESetEncryptMethod(struct soap *soap, const struct ns1__SOF_USCORESetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESetEncryptMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod), type))
		return soap->error;
	if (soap_out_int(soap, "encryptMethod", -1, &a->encryptMethod, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_in_ns1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetEncryptMethod *a, const char *type)
{
	size_t soap_flag_encryptMethod = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESetEncryptMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod, sizeof(struct ns1__SOF_USCORESetEncryptMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESetEncryptMethod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_encryptMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "encryptMethod", &a->encryptMethod, "xsd:int"))
				{	soap_flag_encryptMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_encryptMethod > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetEncryptMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod, sizeof(struct ns1__SOF_USCORESetEncryptMethod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_new_ns1__SOF_USCORESetEncryptMethod(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESetEncryptMethod *p;
	struct ns1__SOF_USCORESetEncryptMethod *a = (struct ns1__SOF_USCORESetEncryptMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESetEncryptMethod));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESetEncryptMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESetEncryptMethod(struct soap *soap, const struct ns1__SOF_USCORESetEncryptMethod *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESetEncryptMethod(soap, tag ? tag : "ns1:SOF_SetEncryptMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_get_ns1__SOF_USCORESetEncryptMethod(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESetEncryptMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetSignMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const struct ns1__SOF_USCOREGetSignMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetSignMethodResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethodResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetSignMethodResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetSignMethodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse, sizeof(struct ns1__SOF_USCOREGetSignMethodResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetSignMethodResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetSignMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse, SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse, sizeof(struct ns1__SOF_USCOREGetSignMethodResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethodResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetSignMethodResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetSignMethodResponse *p;
	struct ns1__SOF_USCOREGetSignMethodResponse *a = (struct ns1__SOF_USCOREGetSignMethodResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetSignMethodResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetSignMethodResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const struct ns1__SOF_USCOREGetSignMethodResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetSignMethodResponse(soap, tag ? tag : "ns1:SOF_GetSignMethodResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethodResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetSignMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetSignMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetSignMethod(struct soap *soap, struct ns1__SOF_USCOREGetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetSignMethod(struct soap *soap, const struct ns1__SOF_USCOREGetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetSignMethod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetSignMethod), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetSignMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetSignMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetSignMethod, sizeof(struct ns1__SOF_USCOREGetSignMethod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetSignMethod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetSignMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetSignMethod, SOAP_TYPE_ns1__SOF_USCOREGetSignMethod, sizeof(struct ns1__SOF_USCOREGetSignMethod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetSignMethod(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetSignMethod *p;
	struct ns1__SOF_USCOREGetSignMethod *a = (struct ns1__SOF_USCOREGetSignMethod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetSignMethod));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetSignMethod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetSignMethod(struct soap *soap, const struct ns1__SOF_USCOREGetSignMethod *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetSignMethod(soap, tag ? tag : "ns1:SOF_GetSignMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetSignMethod(struct soap *soap, struct ns1__SOF_USCOREGetSignMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetSignMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESetWebAppNameResponse(struct soap *soap, struct ns1__SOF_USCORESetWebAppNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const struct ns1__SOF_USCORESetWebAppNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESetWebAppNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppNameResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetWebAppNameResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESetWebAppNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse, sizeof(struct ns1__SOF_USCORESetWebAppNameResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESetWebAppNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetWebAppNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse, SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse, sizeof(struct ns1__SOF_USCORESetWebAppNameResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppNameResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORESetWebAppNameResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESetWebAppNameResponse *p;
	struct ns1__SOF_USCORESetWebAppNameResponse *a = (struct ns1__SOF_USCORESetWebAppNameResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESetWebAppNameResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESetWebAppNameResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const struct ns1__SOF_USCORESetWebAppNameResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESetWebAppNameResponse(soap, tag ? tag : "ns1:SOF_SetWebAppNameResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppNameResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORESetWebAppNameResponse(struct soap *soap, struct ns1__SOF_USCORESetWebAppNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESetWebAppNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESetWebAppName(struct soap *soap, struct ns1__SOF_USCORESetWebAppName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->webAppName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESetWebAppName(struct soap *soap, const struct ns1__SOF_USCORESetWebAppName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->webAppName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESetWebAppName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESetWebAppName), type))
		return soap->error;
	if (soap_out_string(soap, "webAppName", -1, (char*const*)&a->webAppName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_in_ns1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetWebAppName *a, const char *type)
{
	size_t soap_flag_webAppName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESetWebAppName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESetWebAppName, sizeof(struct ns1__SOF_USCORESetWebAppName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESetWebAppName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_webAppName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "webAppName", (char**)&a->webAppName, "xsd:string"))
				{	soap_flag_webAppName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetWebAppName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESetWebAppName, SOAP_TYPE_ns1__SOF_USCORESetWebAppName, sizeof(struct ns1__SOF_USCORESetWebAppName), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_new_ns1__SOF_USCORESetWebAppName(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESetWebAppName *p;
	struct ns1__SOF_USCORESetWebAppName *a = (struct ns1__SOF_USCORESetWebAppName*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESetWebAppName));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESetWebAppName(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESetWebAppName(struct soap *soap, const struct ns1__SOF_USCORESetWebAppName *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESetWebAppName(soap, tag ? tag : "ns1:SOF_SetWebAppName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_get_ns1__SOF_USCORESetWebAppName(struct soap *soap, struct ns1__SOF_USCORESetWebAppName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESetWebAppName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGenRandomResponse(struct soap *soap, struct ns1__SOF_USCOREGenRandomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGenRandomResponse(struct soap *soap, const struct ns1__SOF_USCOREGenRandomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGenRandomResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGenRandomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandomResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGenRandomResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGenRandomResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGenRandomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse, sizeof(struct ns1__SOF_USCOREGenRandomResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGenRandomResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGenRandomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse, SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse, sizeof(struct ns1__SOF_USCOREGenRandomResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandomResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGenRandomResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGenRandomResponse *p;
	struct ns1__SOF_USCOREGenRandomResponse *a = (struct ns1__SOF_USCOREGenRandomResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGenRandomResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGenRandomResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGenRandomResponse(struct soap *soap, const struct ns1__SOF_USCOREGenRandomResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGenRandomResponse(soap, tag ? tag : "ns1:SOF_GenRandomResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandomResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGenRandomResponse(struct soap *soap, struct ns1__SOF_USCOREGenRandomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGenRandomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGenRandom(struct soap *soap, struct ns1__SOF_USCOREGenRandom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->len);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGenRandom(struct soap *soap, const struct ns1__SOF_USCOREGenRandom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGenRandom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGenRandom), type))
		return soap->error;
	if (soap_out_int(soap, "len", -1, &a->len, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGenRandom *a, const char *type)
{
	size_t soap_flag_len = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGenRandom *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGenRandom, sizeof(struct ns1__SOF_USCOREGenRandom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGenRandom(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_len && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "len", &a->len, "xsd:int"))
				{	soap_flag_len--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_len > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGenRandom *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGenRandom, SOAP_TYPE_ns1__SOF_USCOREGenRandom, sizeof(struct ns1__SOF_USCOREGenRandom), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGenRandom(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGenRandom *p;
	struct ns1__SOF_USCOREGenRandom *a = (struct ns1__SOF_USCOREGenRandom*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGenRandom));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGenRandom(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGenRandom(struct soap *soap, const struct ns1__SOF_USCOREGenRandom *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGenRandom(soap, tag ? tag : "ns1:SOF_GenRandom", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGenRandom(struct soap *soap, struct ns1__SOF_USCOREGenRandom *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGenRandom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecryptResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const struct ns1__SOF_USCOREPriKeyDecryptResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREPriKeyDecryptResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecryptResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREPriKeyDecryptResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREPriKeyDecryptResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse, sizeof(struct ns1__SOF_USCOREPriKeyDecryptResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREPriKeyDecryptResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREPriKeyDecryptResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse, sizeof(struct ns1__SOF_USCOREPriKeyDecryptResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecryptResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREPriKeyDecryptResponse *p;
	struct ns1__SOF_USCOREPriKeyDecryptResponse *a = (struct ns1__SOF_USCOREPriKeyDecryptResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREPriKeyDecryptResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREPriKeyDecryptResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const struct ns1__SOF_USCOREPriKeyDecryptResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREPriKeyDecryptResponse(soap, tag ? tag : "ns1:SOF_PriKeyDecryptResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecryptResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecryptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREPriKeyDecryptResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const struct ns1__SOF_USCOREPriKeyDecrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREPriKeyDecrypt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt), type))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_in_ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, struct ns1__SOF_USCOREPriKeyDecrypt *a, const char *type)
{
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREPriKeyDecrypt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt, sizeof(struct ns1__SOF_USCOREPriKeyDecrypt), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREPriKeyDecrypt(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREPriKeyDecrypt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt, sizeof(struct ns1__SOF_USCOREPriKeyDecrypt), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_new_ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREPriKeyDecrypt *p;
	struct ns1__SOF_USCOREPriKeyDecrypt *a = (struct ns1__SOF_USCOREPriKeyDecrypt*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREPriKeyDecrypt));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREPriKeyDecrypt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const struct ns1__SOF_USCOREPriKeyDecrypt *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREPriKeyDecrypt(soap, tag ? tag : "ns1:SOF_PriKeyDecrypt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_get_ns1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecrypt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREPriKeyDecrypt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sofSecurityEngineDeal(struct soap *soap, struct ns1__sofSecurityEngineDeal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->alias);
	soap_default_string(soap, &a->encryption);
	soap_default_string(soap, &a->sessionID);
	soap_default_string(soap, &a->signature);
	soap_default_string(soap, &a->valcrl);
	soap_default_string(soap, &a->valpath);
	soap_default_string(soap, &a->valtime);
	soap_default_string(soap, &a->webAppName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sofSecurityEngineDeal(struct soap *soap, const struct ns1__sofSecurityEngineDeal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->alias);
	soap_serialize_string(soap, (char*const*)&a->encryption);
	soap_serialize_string(soap, (char*const*)&a->sessionID);
	soap_serialize_string(soap, (char*const*)&a->signature);
	soap_serialize_string(soap, (char*const*)&a->valcrl);
	soap_serialize_string(soap, (char*const*)&a->valpath);
	soap_serialize_string(soap, (char*const*)&a->valtime);
	soap_serialize_string(soap, (char*const*)&a->webAppName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sofSecurityEngineDeal(struct soap *soap, const char *tag, int id, const struct ns1__sofSecurityEngineDeal *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sofSecurityEngineDeal), type))
		return soap->error;
	if (soap_out_string(soap, "alias", -1, (char*const*)&a->alias, ""))
		return soap->error;
	if (soap_out_string(soap, "encryption", -1, (char*const*)&a->encryption, ""))
		return soap->error;
	if (soap_out_string(soap, "sessionID", -1, (char*const*)&a->sessionID, ""))
		return soap->error;
	if (soap_out_string(soap, "signature", -1, (char*const*)&a->signature, ""))
		return soap->error;
	if (soap_out_string(soap, "valcrl", -1, (char*const*)&a->valcrl, ""))
		return soap->error;
	if (soap_out_string(soap, "valpath", -1, (char*const*)&a->valpath, ""))
		return soap->error;
	if (soap_out_string(soap, "valtime", -1, (char*const*)&a->valtime, ""))
		return soap->error;
	if (soap_out_string(soap, "webAppName", -1, (char*const*)&a->webAppName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sofSecurityEngineDeal * SOAP_FMAC4 soap_in_ns1__sofSecurityEngineDeal(struct soap *soap, const char *tag, struct ns1__sofSecurityEngineDeal *a, const char *type)
{
	size_t soap_flag_alias = 1;
	size_t soap_flag_encryption = 1;
	size_t soap_flag_sessionID = 1;
	size_t soap_flag_signature = 1;
	size_t soap_flag_valcrl = 1;
	size_t soap_flag_valpath = 1;
	size_t soap_flag_valtime = 1;
	size_t soap_flag_webAppName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sofSecurityEngineDeal *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sofSecurityEngineDeal, sizeof(struct ns1__sofSecurityEngineDeal), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sofSecurityEngineDeal(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "alias", (char**)&a->alias, "xsd:string"))
				{	soap_flag_alias--;
					continue;
				}
			if (soap_flag_encryption && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "encryption", (char**)&a->encryption, "xsd:string"))
				{	soap_flag_encryption--;
					continue;
				}
			if (soap_flag_sessionID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sessionID", (char**)&a->sessionID, "xsd:string"))
				{	soap_flag_sessionID--;
					continue;
				}
			if (soap_flag_signature && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "signature", (char**)&a->signature, "xsd:string"))
				{	soap_flag_signature--;
					continue;
				}
			if (soap_flag_valcrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "valcrl", (char**)&a->valcrl, "xsd:string"))
				{	soap_flag_valcrl--;
					continue;
				}
			if (soap_flag_valpath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "valpath", (char**)&a->valpath, "xsd:string"))
				{	soap_flag_valpath--;
					continue;
				}
			if (soap_flag_valtime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "valtime", (char**)&a->valtime, "xsd:string"))
				{	soap_flag_valtime--;
					continue;
				}
			if (soap_flag_webAppName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "webAppName", (char**)&a->webAppName, "xsd:string"))
				{	soap_flag_webAppName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sofSecurityEngineDeal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sofSecurityEngineDeal, SOAP_TYPE_ns1__sofSecurityEngineDeal, sizeof(struct ns1__sofSecurityEngineDeal), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__sofSecurityEngineDeal * SOAP_FMAC4 soap_new_ns1__sofSecurityEngineDeal(struct soap *soap, int n)
{
	struct ns1__sofSecurityEngineDeal *p;
	struct ns1__sofSecurityEngineDeal *a = (struct ns1__sofSecurityEngineDeal*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__sofSecurityEngineDeal));
	for (p = a; p && n--; p++)
		soap_default_ns1__sofSecurityEngineDeal(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sofSecurityEngineDeal(struct soap *soap, const struct ns1__sofSecurityEngineDeal *a, const char *tag, const char *type)
{
	if (soap_out_ns1__sofSecurityEngineDeal(soap, tag ? tag : "ns1:sofSecurityEngineDeal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sofSecurityEngineDeal * SOAP_FMAC4 soap_get_ns1__sofSecurityEngineDeal(struct soap *soap, struct ns1__sofSecurityEngineDeal *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sofSecurityEngineDeal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetInstanceResponse(struct soap *soap, struct ns1__SOF_USCOREGetInstanceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetInstanceResponse(struct soap *soap, const struct ns1__SOF_USCOREGetInstanceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__sofSecurityEngineDeal(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetInstanceResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetInstanceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__sofSecurityEngineDeal(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstanceResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetInstanceResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetInstanceResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetInstanceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse, sizeof(struct ns1__SOF_USCOREGetInstanceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetInstanceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sofSecurityEngineDeal(soap, "return", &a->return_, "ns1:sofSecurityEngineDeal"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetInstanceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse, SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse, sizeof(struct ns1__SOF_USCOREGetInstanceResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstanceResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetInstanceResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetInstanceResponse *p;
	struct ns1__SOF_USCOREGetInstanceResponse *a = (struct ns1__SOF_USCOREGetInstanceResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetInstanceResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetInstanceResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetInstanceResponse(struct soap *soap, const struct ns1__SOF_USCOREGetInstanceResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetInstanceResponse(soap, tag ? tag : "ns1:SOF_GetInstanceResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstanceResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetInstanceResponse(struct soap *soap, struct ns1__SOF_USCOREGetInstanceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetInstanceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetInstance(struct soap *soap, struct ns1__SOF_USCOREGetInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->appName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetInstance(struct soap *soap, const struct ns1__SOF_USCOREGetInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->appName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetInstance *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetInstance), type))
		return soap->error;
	if (soap_out_string(soap, "appName", -1, (char*const*)&a->appName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetInstance *a, const char *type)
{
	size_t soap_flag_appName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetInstance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetInstance, sizeof(struct ns1__SOF_USCOREGetInstance), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetInstance(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "appName", (char**)&a->appName, "xsd:string"))
				{	soap_flag_appName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetInstance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetInstance, SOAP_TYPE_ns1__SOF_USCOREGetInstance, sizeof(struct ns1__SOF_USCOREGetInstance), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetInstance(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetInstance *p;
	struct ns1__SOF_USCOREGetInstance *a = (struct ns1__SOF_USCOREGetInstance*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetInstance));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetInstance(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetInstance(struct soap *soap, const struct ns1__SOF_USCOREGetInstance *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetInstance(soap, tag ? tag : "ns1:SOF_GetInstance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetInstance(struct soap *soap, struct ns1__SOF_USCOREGetInstance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESignFileResponse(struct soap *soap, struct ns1__SOF_USCORESignFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESignFileResponse(struct soap *soap, const struct ns1__SOF_USCORESignFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESignFileResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESignFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESignFileResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFileResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORESignFileResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignFileResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESignFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESignFileResponse, sizeof(struct ns1__SOF_USCORESignFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESignFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESignFileResponse, SOAP_TYPE_ns1__SOF_USCORESignFileResponse, sizeof(struct ns1__SOF_USCORESignFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFileResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORESignFileResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESignFileResponse *p;
	struct ns1__SOF_USCORESignFileResponse *a = (struct ns1__SOF_USCORESignFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESignFileResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESignFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESignFileResponse(struct soap *soap, const struct ns1__SOF_USCORESignFileResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESignFileResponse(soap, tag ? tag : "ns1:SOF_SignFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFileResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORESignFileResponse(struct soap *soap, struct ns1__SOF_USCORESignFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESignFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESignFile(struct soap *soap, struct ns1__SOF_USCORESignFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inFile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESignFile(struct soap *soap, const struct ns1__SOF_USCORESignFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->inFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESignFile(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESignFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESignFile), type))
		return soap->error;
	if (soap_out_string(soap, "inFile", -1, (char*const*)&a->inFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFile * SOAP_FMAC4 soap_in_ns1__SOF_USCORESignFile(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignFile *a, const char *type)
{
	size_t soap_flag_inFile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESignFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESignFile, sizeof(struct ns1__SOF_USCORESignFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESignFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inFile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inFile", (char**)&a->inFile, "xsd:string"))
				{	soap_flag_inFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESignFile, SOAP_TYPE_ns1__SOF_USCORESignFile, sizeof(struct ns1__SOF_USCORESignFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFile * SOAP_FMAC4 soap_new_ns1__SOF_USCORESignFile(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESignFile *p;
	struct ns1__SOF_USCORESignFile *a = (struct ns1__SOF_USCORESignFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESignFile));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESignFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESignFile(struct soap *soap, const struct ns1__SOF_USCORESignFile *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESignFile(soap, tag ? tag : "ns1:SOF_SignFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFile * SOAP_FMAC4 soap_get_ns1__SOF_USCORESignFile(struct soap *soap, struct ns1__SOF_USCORESignFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESignFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESignDataResponse(struct soap *soap, struct ns1__SOF_USCORESignDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESignDataResponse(struct soap *soap, const struct ns1__SOF_USCORESignDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESignDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESignDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESignDataResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORESignDataResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESignDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESignDataResponse, sizeof(struct ns1__SOF_USCORESignDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESignDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESignDataResponse, SOAP_TYPE_ns1__SOF_USCORESignDataResponse, sizeof(struct ns1__SOF_USCORESignDataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORESignDataResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESignDataResponse *p;
	struct ns1__SOF_USCORESignDataResponse *a = (struct ns1__SOF_USCORESignDataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESignDataResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESignDataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESignDataResponse(struct soap *soap, const struct ns1__SOF_USCORESignDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESignDataResponse(soap, tag ? tag : "ns1:SOF_SignDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORESignDataResponse(struct soap *soap, struct ns1__SOF_USCORESignDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESignDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESignData(struct soap *soap, struct ns1__SOF_USCORESignData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESignData(struct soap *soap, const struct ns1__SOF_USCORESignData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESignData(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESignData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESignData), type))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignData * SOAP_FMAC4 soap_in_ns1__SOF_USCORESignData(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignData *a, const char *type)
{
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESignData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESignData, sizeof(struct ns1__SOF_USCORESignData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESignData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESignData, SOAP_TYPE_ns1__SOF_USCORESignData, sizeof(struct ns1__SOF_USCORESignData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESignData * SOAP_FMAC4 soap_new_ns1__SOF_USCORESignData(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESignData *p;
	struct ns1__SOF_USCORESignData *a = (struct ns1__SOF_USCORESignData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESignData));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESignData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESignData(struct soap *soap, const struct ns1__SOF_USCORESignData *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESignData(soap, tag ? tag : "ns1:SOF_SignData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignData * SOAP_FMAC4 soap_get_ns1__SOF_USCORESignData(struct soap *soap, struct ns1__SOF_USCORESignData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESignData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXMLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataXMLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifySignedDataXMLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXMLResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataXMLResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifySignedDataXMLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse, sizeof(struct ns1__SOF_USCOREVerifySignedDataXMLResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataXMLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse, sizeof(struct ns1__SOF_USCOREVerifySignedDataXMLResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXMLResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifySignedDataXMLResponse *p;
	struct ns1__SOF_USCOREVerifySignedDataXMLResponse *a = (struct ns1__SOF_USCOREVerifySignedDataXMLResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifySignedDataXMLResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataXMLResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag ? tag : "ns1:SOF_VerifySignedDataXMLResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXMLResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXMLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifySignedDataXML *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML), type))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataXML *a, const char *type)
{
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifySignedDataXML *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML, sizeof(struct ns1__SOF_USCOREVerifySignedDataXML), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifySignedDataXML(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataXML *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML, sizeof(struct ns1__SOF_USCOREVerifySignedDataXML), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifySignedDataXML *p;
	struct ns1__SOF_USCOREVerifySignedDataXML *a = (struct ns1__SOF_USCOREVerifySignedDataXML*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifySignedDataXML));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifySignedDataXML(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataXML *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifySignedDataXML(soap, tag ? tag : "ns1:SOF_VerifySignedDataXML", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXML *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifySignedDataXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfoResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse, sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse, sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfoResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *p;
	struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *a = (struct ns1__SOF_USCOREGetXMLSignatureInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfoResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag ? tag : "ns1:SOF_GetXMLSignatureInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfoResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XMLSignedData);
	soap_default_short(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const struct ns1__SOF_USCOREGetXMLSignatureInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->XMLSignedData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetXMLSignatureInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo), type))
		return soap->error;
	if (soap_out_string(soap, "XMLSignedData", -1, (char*const*)&a->XMLSignedData, ""))
		return soap->error;
	if (soap_out_short(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetXMLSignatureInfo *a, const char *type)
{
	size_t soap_flag_XMLSignedData = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetXMLSignatureInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo, sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetXMLSignatureInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XMLSignedData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "XMLSignedData", (char**)&a->XMLSignedData, "xsd:string"))
				{	soap_flag_XMLSignedData--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "type", &a->type, "xsd:short"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetXMLSignatureInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo, sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetXMLSignatureInfo *p;
	struct ns1__SOF_USCOREGetXMLSignatureInfo *a = (struct ns1__SOF_USCOREGetXMLSignatureInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfo));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetXMLSignatureInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const struct ns1__SOF_USCOREGetXMLSignatureInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetXMLSignatureInfo(soap, tag ? tag : "ns1:SOF_GetXMLSignatureInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetXMLSignatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const struct ns1__SOF_USCOREDelCertTrustListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREDelCertTrustListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustListResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDelCertTrustListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREDelCertTrustListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse, sizeof(struct ns1__SOF_USCOREDelCertTrustListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREDelCertTrustListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDelCertTrustListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse, sizeof(struct ns1__SOF_USCOREDelCertTrustListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustListResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREDelCertTrustListResponse *p;
	struct ns1__SOF_USCOREDelCertTrustListResponse *a = (struct ns1__SOF_USCOREDelCertTrustListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREDelCertTrustListResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREDelCertTrustListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const struct ns1__SOF_USCOREDelCertTrustListResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREDelCertTrustListResponse(soap, tag ? tag : "ns1:SOF_DelCertTrustListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustListResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREDelCertTrustListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREDelCertTrustList(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fCtlAltname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREDelCertTrustList(struct soap *soap, const struct ns1__SOF_USCOREDelCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->fCtlAltname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREDelCertTrustList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList), type))
		return soap->error;
	if (soap_out_string(soap, "fCtlAltname", -1, (char*const*)&a->fCtlAltname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_in_ns1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDelCertTrustList *a, const char *type)
{
	size_t soap_flag_fCtlAltname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREDelCertTrustList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList, sizeof(struct ns1__SOF_USCOREDelCertTrustList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREDelCertTrustList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fCtlAltname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fCtlAltname", (char**)&a->fCtlAltname, "xsd:string"))
				{	soap_flag_fCtlAltname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDelCertTrustList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList, sizeof(struct ns1__SOF_USCOREDelCertTrustList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_new_ns1__SOF_USCOREDelCertTrustList(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREDelCertTrustList *p;
	struct ns1__SOF_USCOREDelCertTrustList *a = (struct ns1__SOF_USCOREDelCertTrustList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREDelCertTrustList));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREDelCertTrustList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREDelCertTrustList(struct soap *soap, const struct ns1__SOF_USCOREDelCertTrustList *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREDelCertTrustList(soap, tag ? tag : "ns1:SOF_DelCertTrustList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_get_ns1__SOF_USCOREDelCertTrustList(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREDelCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const struct ns1__SOF_USCOREGetCertInfoByOidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetCertInfoByOidResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOidResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetCertInfoByOidResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetCertInfoByOidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse, sizeof(struct ns1__SOF_USCOREGetCertInfoByOidResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetCertInfoByOidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse, sizeof(struct ns1__SOF_USCOREGetCertInfoByOidResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOidResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetCertInfoByOidResponse *p;
	struct ns1__SOF_USCOREGetCertInfoByOidResponse *a = (struct ns1__SOF_USCOREGetCertInfoByOidResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetCertInfoByOidResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const struct ns1__SOF_USCOREGetCertInfoByOidResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, tag ? tag : "ns1:SOF_GetCertInfoByOidResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOidResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->base64EncodeCert);
	soap_default_string(soap, &a->oid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const struct ns1__SOF_USCOREGetCertInfoByOid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->base64EncodeCert);
	soap_serialize_string(soap, (char*const*)&a->oid);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetCertInfoByOid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid), type))
		return soap->error;
	if (soap_out_string(soap, "base64EncodeCert", -1, (char*const*)&a->base64EncodeCert, ""))
		return soap->error;
	if (soap_out_string(soap, "oid", -1, (char*const*)&a->oid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetCertInfoByOid *a, const char *type)
{
	size_t soap_flag_base64EncodeCert = 1;
	size_t soap_flag_oid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetCertInfoByOid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid, sizeof(struct ns1__SOF_USCOREGetCertInfoByOid), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetCertInfoByOid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "base64EncodeCert", (char**)&a->base64EncodeCert, "xsd:string"))
				{	soap_flag_base64EncodeCert--;
					continue;
				}
			if (soap_flag_oid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "oid", (char**)&a->oid, "xsd:string"))
				{	soap_flag_oid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetCertInfoByOid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid, sizeof(struct ns1__SOF_USCOREGetCertInfoByOid), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetCertInfoByOid *p;
	struct ns1__SOF_USCOREGetCertInfoByOid *a = (struct ns1__SOF_USCOREGetCertInfoByOid*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetCertInfoByOid));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetCertInfoByOid(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const struct ns1__SOF_USCOREGetCertInfoByOid *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetCertInfoByOid(soap, tag ? tag : "ns1:SOF_GetCertInfoByOid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetCertInfoByOid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const struct ns1__SOF_USCOREGetServerCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetServerCertificateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificateResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetServerCertificateResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetServerCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse, sizeof(struct ns1__SOF_USCOREGetServerCertificateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetServerCertificateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetServerCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse, sizeof(struct ns1__SOF_USCOREGetServerCertificateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificateResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetServerCertificateResponse *p;
	struct ns1__SOF_USCOREGetServerCertificateResponse *a = (struct ns1__SOF_USCOREGetServerCertificateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetServerCertificateResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetServerCertificateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const struct ns1__SOF_USCOREGetServerCertificateResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetServerCertificateResponse(soap, tag ? tag : "ns1:SOF_GetServerCertificateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificateResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetServerCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetServerCertificate(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->certUsage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetServerCertificate(struct soap *soap, const struct ns1__SOF_USCOREGetServerCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetServerCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate), type))
		return soap->error;
	if (soap_out_int(soap, "certUsage", -1, &a->certUsage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetServerCertificate *a, const char *type)
{
	size_t soap_flag_certUsage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetServerCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate, sizeof(struct ns1__SOF_USCOREGetServerCertificate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetServerCertificate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_certUsage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "certUsage", &a->certUsage, "xsd:int"))
				{	soap_flag_certUsage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_certUsage > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetServerCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate, sizeof(struct ns1__SOF_USCOREGetServerCertificate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetServerCertificate(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetServerCertificate *p;
	struct ns1__SOF_USCOREGetServerCertificate *a = (struct ns1__SOF_USCOREGetServerCertificate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetServerCertificate));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetServerCertificate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetServerCertificate(struct soap *soap, const struct ns1__SOF_USCOREGetServerCertificate *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetServerCertificate(soap, tag ? tag : "ns1:SOF_GetServerCertificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetServerCertificate(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetServerCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifySignedFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFileResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedFileResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifySignedFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse, sizeof(struct ns1__SOF_USCOREVerifySignedFileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifySignedFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse, sizeof(struct ns1__SOF_USCOREVerifySignedFileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFileResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifySignedFileResponse *p;
	struct ns1__SOF_USCOREVerifySignedFileResponse *a = (struct ns1__SOF_USCOREVerifySignedFileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifySignedFileResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifySignedFileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedFileResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifySignedFileResponse(soap, tag ? tag : "ns1:SOF_VerifySignedFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFileResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifySignedFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifySignedFile(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->base64EncodeCert);
	soap_default_string(soap, &a->inFile);
	soap_default_string(soap, &a->signValue);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifySignedFile(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->base64EncodeCert);
	soap_serialize_string(soap, (char*const*)&a->inFile);
	soap_serialize_string(soap, (char*const*)&a->signValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifySignedFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile), type))
		return soap->error;
	if (soap_out_string(soap, "base64EncodeCert", -1, (char*const*)&a->base64EncodeCert, ""))
		return soap->error;
	if (soap_out_string(soap, "inFile", -1, (char*const*)&a->inFile, ""))
		return soap->error;
	if (soap_out_string(soap, "signValue", -1, (char*const*)&a->signValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedFile *a, const char *type)
{
	size_t soap_flag_base64EncodeCert = 1;
	size_t soap_flag_inFile = 1;
	size_t soap_flag_signValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifySignedFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile, sizeof(struct ns1__SOF_USCOREVerifySignedFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifySignedFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "base64EncodeCert", (char**)&a->base64EncodeCert, "xsd:string"))
				{	soap_flag_base64EncodeCert--;
					continue;
				}
			if (soap_flag_inFile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inFile", (char**)&a->inFile, "xsd:string"))
				{	soap_flag_inFile--;
					continue;
				}
			if (soap_flag_signValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "signValue", (char**)&a->signValue, "xsd:string"))
				{	soap_flag_signValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile, sizeof(struct ns1__SOF_USCOREVerifySignedFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifySignedFile(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifySignedFile *p;
	struct ns1__SOF_USCOREVerifySignedFile *a = (struct ns1__SOF_USCOREVerifySignedFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifySignedFile));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifySignedFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifySignedFile(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedFile *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifySignedFile(soap, tag ? tag : "ns1:SOF_VerifySignedFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifySignedFile(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifySignedFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncryptResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const struct ns1__SOF_USCOREPubKeyEncryptResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREPubKeyEncryptResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncryptResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREPubKeyEncryptResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREPubKeyEncryptResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse, sizeof(struct ns1__SOF_USCOREPubKeyEncryptResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREPubKeyEncryptResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREPubKeyEncryptResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse, sizeof(struct ns1__SOF_USCOREPubKeyEncryptResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncryptResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREPubKeyEncryptResponse *p;
	struct ns1__SOF_USCOREPubKeyEncryptResponse *a = (struct ns1__SOF_USCOREPubKeyEncryptResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREPubKeyEncryptResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREPubKeyEncryptResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const struct ns1__SOF_USCOREPubKeyEncryptResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREPubKeyEncryptResponse(soap, tag ? tag : "ns1:SOF_PubKeyEncryptResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncryptResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncryptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREPubKeyEncryptResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->base64EncodeCert);
	soap_default_string(soap, &a->inData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const struct ns1__SOF_USCOREPubKeyEncrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->base64EncodeCert);
	soap_serialize_string(soap, (char*const*)&a->inData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREPubKeyEncrypt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt), type))
		return soap->error;
	if (soap_out_string(soap, "base64EncodeCert", -1, (char*const*)&a->base64EncodeCert, ""))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_in_ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, struct ns1__SOF_USCOREPubKeyEncrypt *a, const char *type)
{
	size_t soap_flag_base64EncodeCert = 1;
	size_t soap_flag_inData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREPubKeyEncrypt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt, sizeof(struct ns1__SOF_USCOREPubKeyEncrypt), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREPubKeyEncrypt(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "base64EncodeCert", (char**)&a->base64EncodeCert, "xsd:string"))
				{	soap_flag_base64EncodeCert--;
					continue;
				}
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREPubKeyEncrypt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt, sizeof(struct ns1__SOF_USCOREPubKeyEncrypt), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_new_ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREPubKeyEncrypt *p;
	struct ns1__SOF_USCOREPubKeyEncrypt *a = (struct ns1__SOF_USCOREPubKeyEncrypt*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREPubKeyEncrypt));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREPubKeyEncrypt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const struct ns1__SOF_USCOREPubKeyEncrypt *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREPubKeyEncrypt(soap, tag ? tag : "ns1:SOF_PubKeyEncrypt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_get_ns1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncrypt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREPubKeyEncrypt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const struct ns1__SOF_USCOREVerifyTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifyTimeStampResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStampResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifyTimeStampResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifyTimeStampResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse, sizeof(struct ns1__SOF_USCOREVerifyTimeStampResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifyTimeStampResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifyTimeStampResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse, sizeof(struct ns1__SOF_USCOREVerifyTimeStampResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStampResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifyTimeStampResponse *p;
	struct ns1__SOF_USCOREVerifyTimeStampResponse *a = (struct ns1__SOF_USCOREVerifyTimeStampResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifyTimeStampResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifyTimeStampResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const struct ns1__SOF_USCOREVerifyTimeStampResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifyTimeStampResponse(soap, tag ? tag : "ns1:SOF_VerifyTimeStampResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStampResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifyTimeStampResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->content);
	soap_default_string(soap, &a->tsResponseData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const struct ns1__SOF_USCOREVerifyTimeStamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->content);
	soap_serialize_string(soap, (char*const*)&a->tsResponseData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifyTimeStamp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp), type))
		return soap->error;
	if (soap_out_string(soap, "content", -1, (char*const*)&a->content, ""))
		return soap->error;
	if (soap_out_string(soap, "tsResponseData", -1, (char*const*)&a->tsResponseData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifyTimeStamp *a, const char *type)
{
	size_t soap_flag_content = 1;
	size_t soap_flag_tsResponseData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifyTimeStamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp, sizeof(struct ns1__SOF_USCOREVerifyTimeStamp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifyTimeStamp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "content", (char**)&a->content, "xsd:string"))
				{	soap_flag_content--;
					continue;
				}
			if (soap_flag_tsResponseData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tsResponseData", (char**)&a->tsResponseData, "xsd:string"))
				{	soap_flag_tsResponseData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifyTimeStamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp, sizeof(struct ns1__SOF_USCOREVerifyTimeStamp), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifyTimeStamp *p;
	struct ns1__SOF_USCOREVerifyTimeStamp *a = (struct ns1__SOF_USCOREVerifyTimeStamp*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifyTimeStamp));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifyTimeStamp(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const struct ns1__SOF_USCOREVerifyTimeStamp *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifyTimeStamp(soap, tag ? tag : "ns1:SOF_VerifyTimeStamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStamp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifyTimeStamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const struct ns1__SOF_USCOREGetP7SignDataInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetP7SignDataInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfoResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetP7SignDataInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetP7SignDataInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse, sizeof(struct ns1__SOF_USCOREGetP7SignDataInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetP7SignDataInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse, sizeof(struct ns1__SOF_USCOREGetP7SignDataInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfoResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetP7SignDataInfoResponse *p;
	struct ns1__SOF_USCOREGetP7SignDataInfoResponse *a = (struct ns1__SOF_USCOREGetP7SignDataInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetP7SignDataInfoResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const struct ns1__SOF_USCOREGetP7SignDataInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag ? tag : "ns1:SOF_GetP7SignDataInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfoResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->pkcs7SignData);
	soap_default_int(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const struct ns1__SOF_USCOREGetP7SignDataInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->pkcs7SignData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREGetP7SignDataInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo), type))
		return soap->error;
	if (soap_out_string(soap, "pkcs7SignData", -1, (char*const*)&a->pkcs7SignData, ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_in_ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetP7SignDataInfo *a, const char *type)
{
	size_t soap_flag_pkcs7SignData = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREGetP7SignDataInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo, sizeof(struct ns1__SOF_USCOREGetP7SignDataInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREGetP7SignDataInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pkcs7SignData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pkcs7SignData", (char**)&a->pkcs7SignData, "xsd:string"))
				{	soap_flag_pkcs7SignData--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetP7SignDataInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo, sizeof(struct ns1__SOF_USCOREGetP7SignDataInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_new_ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREGetP7SignDataInfo *p;
	struct ns1__SOF_USCOREGetP7SignDataInfo *a = (struct ns1__SOF_USCOREGetP7SignDataInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREGetP7SignDataInfo));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREGetP7SignDataInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const struct ns1__SOF_USCOREGetP7SignDataInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREGetP7SignDataInfo(soap, tag ? tag : "ns1:SOF_GetP7SignDataInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_get_ns1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREGetP7SignDataInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESetCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCORESetCertTrustListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const struct ns1__SOF_USCORESetCertTrustListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESetCertTrustListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustListResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetCertTrustListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESetCertTrustListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse, sizeof(struct ns1__SOF_USCORESetCertTrustListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESetCertTrustListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetCertTrustListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse, SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse, sizeof(struct ns1__SOF_USCORESetCertTrustListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustListResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCORESetCertTrustListResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESetCertTrustListResponse *p;
	struct ns1__SOF_USCORESetCertTrustListResponse *a = (struct ns1__SOF_USCORESetCertTrustListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESetCertTrustListResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESetCertTrustListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const struct ns1__SOF_USCORESetCertTrustListResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESetCertTrustListResponse(soap, tag ? tag : "ns1:SOF_SetCertTrustListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustListResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCORESetCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCORESetCertTrustListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESetCertTrustListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCORESetCertTrustList(struct soap *soap, struct ns1__SOF_USCORESetCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fCtlAltname);
	soap_default_string(soap, &a->fCtlContent);
	soap_default_int(soap, &a->fCtlContentLen);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCORESetCertTrustList(struct soap *soap, const struct ns1__SOF_USCORESetCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->fCtlAltname);
	soap_serialize_string(soap, (char*const*)&a->fCtlContent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCORESetCertTrustList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCORESetCertTrustList), type))
		return soap->error;
	if (soap_out_string(soap, "fCtlAltname", -1, (char*const*)&a->fCtlAltname, ""))
		return soap->error;
	if (soap_out_string(soap, "fCtlContent", -1, (char*const*)&a->fCtlContent, ""))
		return soap->error;
	if (soap_out_int(soap, "fCtlContentLen", -1, &a->fCtlContentLen, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_in_ns1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetCertTrustList *a, const char *type)
{
	size_t soap_flag_fCtlAltname = 1;
	size_t soap_flag_fCtlContent = 1;
	size_t soap_flag_fCtlContentLen = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCORESetCertTrustList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCORESetCertTrustList, sizeof(struct ns1__SOF_USCORESetCertTrustList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCORESetCertTrustList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fCtlAltname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fCtlAltname", (char**)&a->fCtlAltname, "xsd:string"))
				{	soap_flag_fCtlAltname--;
					continue;
				}
			if (soap_flag_fCtlContent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fCtlContent", (char**)&a->fCtlContent, "xsd:string"))
				{	soap_flag_fCtlContent--;
					continue;
				}
			if (soap_flag_fCtlContentLen && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fCtlContentLen", &a->fCtlContentLen, "xsd:int"))
				{	soap_flag_fCtlContentLen--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fCtlContentLen > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetCertTrustList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCORESetCertTrustList, SOAP_TYPE_ns1__SOF_USCORESetCertTrustList, sizeof(struct ns1__SOF_USCORESetCertTrustList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_new_ns1__SOF_USCORESetCertTrustList(struct soap *soap, int n)
{
	struct ns1__SOF_USCORESetCertTrustList *p;
	struct ns1__SOF_USCORESetCertTrustList *a = (struct ns1__SOF_USCORESetCertTrustList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCORESetCertTrustList));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCORESetCertTrustList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCORESetCertTrustList(struct soap *soap, const struct ns1__SOF_USCORESetCertTrustList *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCORESetCertTrustList(soap, tag ? tag : "ns1:SOF_SetCertTrustList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_get_ns1__SOF_USCORESetCertTrustList(struct soap *soap, struct ns1__SOF_USCORESetCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCORESetCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataByP7Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifySignedDataByP7Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7Response * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataByP7Response *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifySignedDataByP7Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response, sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7Response), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataByP7Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response, sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7Response), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7Response * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifySignedDataByP7Response *p;
	struct ns1__SOF_USCOREVerifySignedDataByP7Response *a = (struct ns1__SOF_USCOREVerifySignedDataByP7Response*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7Response));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataByP7Response *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, tag ? tag : "ns1:SOF_VerifySignedDataByP7Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7Response * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->pkcs7SignData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->pkcs7SignData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifySignedDataByP7 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7), type))
		return soap->error;
	if (soap_out_string(soap, "pkcs7SignData", -1, (char*const*)&a->pkcs7SignData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataByP7 *a, const char *type)
{
	size_t soap_flag_pkcs7SignData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifySignedDataByP7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7, sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifySignedDataByP7(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pkcs7SignData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pkcs7SignData", (char**)&a->pkcs7SignData, "xsd:string"))
				{	soap_flag_pkcs7SignData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataByP7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7, sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifySignedDataByP7 *p;
	struct ns1__SOF_USCOREVerifySignedDataByP7 *a = (struct ns1__SOF_USCOREVerifySignedDataByP7*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifySignedDataByP7(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataByP7 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifySignedDataByP7(soap, tag ? tag : "ns1:SOF_VerifySignedDataByP7", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifySignedDataByP7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const struct ns1__SOF_USCOREQueryCertTrustListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREQueryCertTrustListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, (char*const*)&a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREQueryCertTrustListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREQueryCertTrustListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse, sizeof(struct ns1__SOF_USCOREQueryCertTrustListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREQueryCertTrustListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", (char**)&a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREQueryCertTrustListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse, sizeof(struct ns1__SOF_USCOREQueryCertTrustListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREQueryCertTrustListResponse *p;
	struct ns1__SOF_USCOREQueryCertTrustListResponse *a = (struct ns1__SOF_USCOREQueryCertTrustListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREQueryCertTrustListResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREQueryCertTrustListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const struct ns1__SOF_USCOREQueryCertTrustListResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREQueryCertTrustListResponse(soap, tag ? tag : "ns1:SOF_QueryCertTrustListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREQueryCertTrustListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fCtlAltname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, const struct ns1__SOF_USCOREQueryCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->fCtlAltname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREQueryCertTrustList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList), type))
		return soap->error;
	if (soap_out_string(soap, "fCtlAltname", -1, (char*const*)&a->fCtlAltname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_in_ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, struct ns1__SOF_USCOREQueryCertTrustList *a, const char *type)
{
	size_t soap_flag_fCtlAltname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREQueryCertTrustList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList, sizeof(struct ns1__SOF_USCOREQueryCertTrustList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREQueryCertTrustList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fCtlAltname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fCtlAltname", (char**)&a->fCtlAltname, "xsd:string"))
				{	soap_flag_fCtlAltname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREQueryCertTrustList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList, sizeof(struct ns1__SOF_USCOREQueryCertTrustList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_new_ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREQueryCertTrustList *p;
	struct ns1__SOF_USCOREQueryCertTrustList *a = (struct ns1__SOF_USCOREQueryCertTrustList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREQueryCertTrustList));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREQueryCertTrustList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, const struct ns1__SOF_USCOREQueryCertTrustList *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREQueryCertTrustList(soap, tag ? tag : "ns1:SOF_QueryCertTrustList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_get_ns1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREQueryCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifySignedDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataResponse * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifySignedDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse, sizeof(struct ns1__SOF_USCOREVerifySignedDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifySignedDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse, sizeof(struct ns1__SOF_USCOREVerifySignedDataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataResponse * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifySignedDataResponse *p;
	struct ns1__SOF_USCOREVerifySignedDataResponse *a = (struct ns1__SOF_USCOREVerifySignedDataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifySignedDataResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifySignedDataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifySignedDataResponse(soap, tag ? tag : "ns1:SOF_VerifySignedDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataResponse * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifySignedDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SOF_USCOREVerifySignedData(struct soap *soap, struct ns1__SOF_USCOREVerifySignedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->base64EncodeCert);
	soap_default_string(soap, &a->inData);
	soap_default_string(soap, &a->signValue);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SOF_USCOREVerifySignedData(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->base64EncodeCert);
	soap_serialize_string(soap, (char*const*)&a->inData);
	soap_serialize_string(soap, (char*const*)&a->signValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, int id, const struct ns1__SOF_USCOREVerifySignedData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedData), type))
		return soap->error;
	if (soap_out_string(soap, "base64EncodeCert", -1, (char*const*)&a->base64EncodeCert, ""))
		return soap->error;
	if (soap_out_string(soap, "inData", -1, (char*const*)&a->inData, ""))
		return soap->error;
	if (soap_out_string(soap, "signValue", -1, (char*const*)&a->signValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_in_ns1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedData *a, const char *type)
{
	size_t soap_flag_base64EncodeCert = 1;
	size_t soap_flag_inData = 1;
	size_t soap_flag_signValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SOF_USCOREVerifySignedData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedData, sizeof(struct ns1__SOF_USCOREVerifySignedData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SOF_USCOREVerifySignedData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "base64EncodeCert", (char**)&a->base64EncodeCert, "xsd:string"))
				{	soap_flag_base64EncodeCert--;
					continue;
				}
			if (soap_flag_inData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "inData", (char**)&a->inData, "xsd:string"))
				{	soap_flag_inData--;
					continue;
				}
			if (soap_flag_signValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "signValue", (char**)&a->signValue, "xsd:string"))
				{	soap_flag_signValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SOF_USCOREVerifySignedData, SOAP_TYPE_ns1__SOF_USCOREVerifySignedData, sizeof(struct ns1__SOF_USCOREVerifySignedData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_new_ns1__SOF_USCOREVerifySignedData(struct soap *soap, int n)
{
	struct ns1__SOF_USCOREVerifySignedData *p;
	struct ns1__SOF_USCOREVerifySignedData *a = (struct ns1__SOF_USCOREVerifySignedData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SOF_USCOREVerifySignedData));
	for (p = a; p && n--; p++)
		soap_default_ns1__SOF_USCOREVerifySignedData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SOF_USCOREVerifySignedData(struct soap *soap, const struct ns1__SOF_USCOREVerifySignedData *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SOF_USCOREVerifySignedData(soap, tag ? tag : "ns1:SOF_VerifySignedData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_get_ns1__SOF_USCOREVerifySignedData(struct soap *soap, struct ns1__SOF_USCOREVerifySignedData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SOF_USCOREVerifySignedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr && !soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_xsd__base64Binary))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, struct xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, struct xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_new_xsd__base64Binary(struct soap *soap, int n)
{
	struct xsd__base64Binary *p;
	struct xsd__base64Binary *a = (struct xsd__base64Binary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xsd__base64Binary));
	for (p = a; p && n--; p++)
		soap_default_xsd__base64Binary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREEncryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptDataResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse))
		soap_serialize_ns1__SOF_USCOREEncryptDataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREEncryptDataResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREEncryptDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREEncryptDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREEncryptDataResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREEncryptDataResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREEncryptDataResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREEncryptDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREEncryptDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREEncryptDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREEncryptDataResponse, sizeof(struct ns1__SOF_USCOREEncryptDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREEncryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptDataResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREEncryptDataResponse(soap, tag ? tag : "ns1:SOF_EncryptDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREEncryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREEncryptDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREEncryptData(struct soap *soap, struct ns1__SOF_USCOREEncryptData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREEncryptData))
		soap_serialize_ns1__SOF_USCOREEncryptData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREEncryptData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREEncryptData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREEncryptData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptData ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, struct ns1__SOF_USCOREEncryptData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREEncryptData **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREEncryptData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREEncryptData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREEncryptData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREEncryptData, sizeof(struct ns1__SOF_USCOREEncryptData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREEncryptData(struct soap *soap, struct ns1__SOF_USCOREEncryptData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREEncryptData(soap, tag ? tag : "ns1:SOF_EncryptData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptData ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREEncryptData(struct soap *soap, struct ns1__SOF_USCOREEncryptData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREEncryptData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse))
		soap_serialize_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNamesResponse, sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag ? tag : "ns1:SOF_QueryCertTrustListAltNamesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNamesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNames *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames))
		soap_serialize_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREQueryCertTrustListAltNames *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNames ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, struct ns1__SOF_USCOREQueryCertTrustListAltNames **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREQueryCertTrustListAltNames **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNames *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREQueryCertTrustListAltNames **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListAltNames, sizeof(struct ns1__SOF_USCOREQueryCertTrustListAltNames), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNames *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(soap, tag ? tag : "ns1:SOF_QueryCertTrustListAltNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListAltNames ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListAltNames **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetCertInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse))
		soap_serialize_ns1__SOF_USCOREGetCertInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetCertInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetCertInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetCertInfoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetCertInfoResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetCertInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetCertInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetCertInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoResponse, sizeof(struct ns1__SOF_USCOREGetCertInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetCertInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetCertInfoResponse(soap, tag ? tag : "ns1:SOF_GetCertInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetCertInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetCertInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetCertInfo(struct soap *soap, struct ns1__SOF_USCOREGetCertInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfo))
		soap_serialize_ns1__SOF_USCOREGetCertInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetCertInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetCertInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetCertInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfo ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetCertInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetCertInfo **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetCertInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetCertInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetCertInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfo, sizeof(struct ns1__SOF_USCOREGetCertInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetCertInfo(struct soap *soap, struct ns1__SOF_USCOREGetCertInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetCertInfo(soap, tag ? tag : "ns1:SOF_GetCertInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfo ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetCertInfo(struct soap *soap, struct ns1__SOF_USCOREGetCertInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetCertInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESignDataXMLResponse(struct soap *soap, struct ns1__SOF_USCORESignDataXMLResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse))
		soap_serialize_ns1__SOF_USCORESignDataXMLResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESignDataXMLResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESignDataXMLResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESignDataXMLResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXMLResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESignDataXMLResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataXMLResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESignDataXMLResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESignDataXMLResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESignDataXMLResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataXMLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESignDataXMLResponse, sizeof(struct ns1__SOF_USCORESignDataXMLResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESignDataXMLResponse(struct soap *soap, struct ns1__SOF_USCORESignDataXMLResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESignDataXMLResponse(soap, tag ? tag : "ns1:SOF_SignDataXMLResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXMLResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESignDataXMLResponse(struct soap *soap, struct ns1__SOF_USCORESignDataXMLResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESignDataXMLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESignDataXML(struct soap *soap, struct ns1__SOF_USCORESignDataXML *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESignDataXML))
		soap_serialize_ns1__SOF_USCORESignDataXML(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESignDataXML *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESignDataXML, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESignDataXML(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXML ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataXML **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESignDataXML **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESignDataXML *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESignDataXML(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataXML **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESignDataXML, sizeof(struct ns1__SOF_USCORESignDataXML), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESignDataXML(struct soap *soap, struct ns1__SOF_USCORESignDataXML *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESignDataXML(soap, tag ? tag : "ns1:SOF_SignDataXML", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataXML ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESignDataXML(struct soap *soap, struct ns1__SOF_USCORESignDataXML **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESignDataXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREDecryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptDataResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse))
		soap_serialize_ns1__SOF_USCOREDecryptDataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREDecryptDataResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREDecryptDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREDecryptDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREDecryptDataResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDecryptDataResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREDecryptDataResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREDecryptDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREDecryptDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDecryptDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREDecryptDataResponse, sizeof(struct ns1__SOF_USCOREDecryptDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREDecryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptDataResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREDecryptDataResponse(soap, tag ? tag : "ns1:SOF_DecryptDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREDecryptDataResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREDecryptDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREDecryptData(struct soap *soap, struct ns1__SOF_USCOREDecryptData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREDecryptData))
		soap_serialize_ns1__SOF_USCOREDecryptData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREDecryptData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREDecryptData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREDecryptData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptData ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDecryptData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREDecryptData **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREDecryptData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREDecryptData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDecryptData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREDecryptData, sizeof(struct ns1__SOF_USCOREDecryptData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREDecryptData(struct soap *soap, struct ns1__SOF_USCOREDecryptData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREDecryptData(soap, tag ? tag : "ns1:SOF_DecryptData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptData ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREDecryptData(struct soap *soap, struct ns1__SOF_USCOREDecryptData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREDecryptData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESignDataByP7Response(struct soap *soap, struct ns1__SOF_USCORESignDataByP7Response *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response))
		soap_serialize_ns1__SOF_USCORESignDataByP7Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESignDataByP7Response(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESignDataByP7Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESignDataByP7Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7Response ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESignDataByP7Response(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataByP7Response **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESignDataByP7Response **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESignDataByP7Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESignDataByP7Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataByP7Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESignDataByP7Response, sizeof(struct ns1__SOF_USCORESignDataByP7Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESignDataByP7Response(struct soap *soap, struct ns1__SOF_USCORESignDataByP7Response *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESignDataByP7Response(soap, tag ? tag : "ns1:SOF_SignDataByP7Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7Response ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESignDataByP7Response(struct soap *soap, struct ns1__SOF_USCORESignDataByP7Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESignDataByP7Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESignDataByP7(struct soap *soap, struct ns1__SOF_USCORESignDataByP7 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESignDataByP7))
		soap_serialize_ns1__SOF_USCORESignDataByP7(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESignDataByP7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESignDataByP7, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESignDataByP7(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7 ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataByP7 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESignDataByP7 **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESignDataByP7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESignDataByP7(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataByP7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESignDataByP7, sizeof(struct ns1__SOF_USCORESignDataByP7), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESignDataByP7(struct soap *soap, struct ns1__SOF_USCORESignDataByP7 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESignDataByP7(soap, tag ? tag : "ns1:SOF_SignDataByP7", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataByP7 ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESignDataByP7(struct soap *soap, struct ns1__SOF_USCORESignDataByP7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESignDataByP7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREEncryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse))
		soap_serialize_ns1__SOF_USCOREEncryptFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREEncryptFileResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREEncryptFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREEncryptFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREEncryptFileResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREEncryptFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREEncryptFileResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREEncryptFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREEncryptFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREEncryptFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREEncryptFileResponse, sizeof(struct ns1__SOF_USCOREEncryptFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREEncryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREEncryptFileResponse(soap, tag ? tag : "ns1:SOF_EncryptFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREEncryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREEncryptFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREEncryptFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREEncryptFile(struct soap *soap, struct ns1__SOF_USCOREEncryptFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREEncryptFile))
		soap_serialize_ns1__SOF_USCOREEncryptFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREEncryptFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREEncryptFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREEncryptFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFile ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, struct ns1__SOF_USCOREEncryptFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREEncryptFile **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREEncryptFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREEncryptFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREEncryptFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREEncryptFile, sizeof(struct ns1__SOF_USCOREEncryptFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREEncryptFile(struct soap *soap, struct ns1__SOF_USCOREEncryptFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREEncryptFile(soap, tag ? tag : "ns1:SOF_EncryptFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREEncryptFile ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREEncryptFile(struct soap *soap, struct ns1__SOF_USCOREEncryptFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREEncryptFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse))
		soap_serialize_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetTimeStampInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetTimeStampInfoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetTimeStampInfoResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetTimeStampInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetTimeStampInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfoResponse, sizeof(struct ns1__SOF_USCOREGetTimeStampInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(soap, tag ? tag : "ns1:SOF_GetTimeStampInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo))
		soap_serialize_ns1__SOF_USCOREGetTimeStampInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetTimeStampInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetTimeStampInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfo ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetTimeStampInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetTimeStampInfo **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetTimeStampInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetTimeStampInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetTimeStampInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetTimeStampInfo, sizeof(struct ns1__SOF_USCOREGetTimeStampInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetTimeStampInfo(soap, tag ? tag : "ns1:SOF_GetTimeStampInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetTimeStampInfo ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct ns1__SOF_USCOREGetTimeStampInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetTimeStampInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetSignMethodResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse))
		soap_serialize_ns1__SOF_USCORESetSignMethodResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESetSignMethodResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESetSignMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESetSignMethodResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethodResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESetSignMethodResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetSignMethodResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESetSignMethodResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESetSignMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESetSignMethodResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetSignMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESetSignMethodResponse, sizeof(struct ns1__SOF_USCORESetSignMethodResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetSignMethodResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESetSignMethodResponse(soap, tag ? tag : "ns1:SOF_SetSignMethodResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethodResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetSignMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESetSignMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESetSignMethod(struct soap *soap, struct ns1__SOF_USCORESetSignMethod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESetSignMethod))
		soap_serialize_ns1__SOF_USCORESetSignMethod(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESetSignMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESetSignMethod, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESetSignMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethod ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetSignMethod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESetSignMethod **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESetSignMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESetSignMethod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetSignMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESetSignMethod, sizeof(struct ns1__SOF_USCORESetSignMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESetSignMethod(struct soap *soap, struct ns1__SOF_USCORESetSignMethod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESetSignMethod(soap, tag ? tag : "ns1:SOF_SetSignMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetSignMethod ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESetSignMethod(struct soap *soap, struct ns1__SOF_USCORESetSignMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESetSignMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREDecryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse))
		soap_serialize_ns1__SOF_USCOREDecryptFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREDecryptFileResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREDecryptFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREDecryptFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREDecryptFileResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDecryptFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREDecryptFileResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREDecryptFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREDecryptFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDecryptFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREDecryptFileResponse, sizeof(struct ns1__SOF_USCOREDecryptFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREDecryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREDecryptFileResponse(soap, tag ? tag : "ns1:SOF_DecryptFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREDecryptFileResponse(struct soap *soap, struct ns1__SOF_USCOREDecryptFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREDecryptFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREDecryptFile(struct soap *soap, struct ns1__SOF_USCOREDecryptFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREDecryptFile))
		soap_serialize_ns1__SOF_USCOREDecryptFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREDecryptFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREDecryptFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREDecryptFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFile ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDecryptFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREDecryptFile **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREDecryptFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREDecryptFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDecryptFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREDecryptFile, sizeof(struct ns1__SOF_USCOREDecryptFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREDecryptFile(struct soap *soap, struct ns1__SOF_USCOREDecryptFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREDecryptFile(soap, tag ? tag : "ns1:SOF_DecryptFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDecryptFile ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREDecryptFile(struct soap *soap, struct ns1__SOF_USCOREDecryptFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREDecryptFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetFileResponse(struct soap *soap, struct ns1__GetFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetFileResponse))
		soap_serialize_ns1__GetFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetFileResponse(struct soap *soap, const char *tag, int id, struct ns1__GetFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__GetFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__GetFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__GetFileResponse(struct soap *soap, const char *tag, struct ns1__GetFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__GetFileResponse **)soap_malloc(soap, sizeof(struct ns1__GetFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__GetFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__GetFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetFileResponse, sizeof(struct ns1__GetFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetFileResponse(struct soap *soap, struct ns1__GetFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetFileResponse(soap, tag ? tag : "ns1:GetFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__GetFileResponse(struct soap *soap, struct ns1__GetFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetFile(struct soap *soap, struct ns1__GetFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetFile))
		soap_serialize_ns1__GetFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetFile(struct soap *soap, const char *tag, int id, struct ns1__GetFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__GetFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__GetFile ** SOAP_FMAC4 soap_in_PointerTons1__GetFile(struct soap *soap, const char *tag, struct ns1__GetFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__GetFile **)soap_malloc(soap, sizeof(struct ns1__GetFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__GetFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__GetFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetFile, sizeof(struct ns1__GetFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetFile(struct soap *soap, struct ns1__GetFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__GetFile(soap, tag ? tag : "ns1:GetFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetFile ** SOAP_FMAC4 soap_get_PointerTons1__GetFile(struct soap *soap, struct ns1__GetFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DeleteFileResponse(struct soap *soap, struct ns1__DeleteFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DeleteFileResponse))
		soap_serialize_ns1__DeleteFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DeleteFileResponse(struct soap *soap, const char *tag, int id, struct ns1__DeleteFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DeleteFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DeleteFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__DeleteFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__DeleteFileResponse(struct soap *soap, const char *tag, struct ns1__DeleteFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__DeleteFileResponse **)soap_malloc(soap, sizeof(struct ns1__DeleteFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DeleteFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeleteFileResponse, sizeof(struct ns1__DeleteFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DeleteFileResponse(struct soap *soap, struct ns1__DeleteFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DeleteFileResponse(soap, tag ? tag : "ns1:DeleteFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__DeleteFileResponse(struct soap *soap, struct ns1__DeleteFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DeleteFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DeleteFile(struct soap *soap, struct ns1__DeleteFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DeleteFile))
		soap_serialize_ns1__DeleteFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DeleteFile(struct soap *soap, const char *tag, int id, struct ns1__DeleteFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DeleteFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DeleteFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__DeleteFile ** SOAP_FMAC4 soap_in_PointerTons1__DeleteFile(struct soap *soap, const char *tag, struct ns1__DeleteFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__DeleteFile **)soap_malloc(soap, sizeof(struct ns1__DeleteFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DeleteFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeleteFile, sizeof(struct ns1__DeleteFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DeleteFile(struct soap *soap, struct ns1__DeleteFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DeleteFile(soap, tag ? tag : "ns1:DeleteFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteFile ** SOAP_FMAC4 soap_get_PointerTons1__DeleteFile(struct soap *soap, struct ns1__DeleteFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DeleteFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREValidateCertResponse(struct soap *soap, struct ns1__SOF_USCOREValidateCertResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse))
		soap_serialize_ns1__SOF_USCOREValidateCertResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREValidateCertResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREValidateCertResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREValidateCertResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCertResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREValidateCertResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREValidateCertResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREValidateCertResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREValidateCertResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREValidateCertResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREValidateCertResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREValidateCertResponse, sizeof(struct ns1__SOF_USCOREValidateCertResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREValidateCertResponse(struct soap *soap, struct ns1__SOF_USCOREValidateCertResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREValidateCertResponse(soap, tag ? tag : "ns1:SOF_ValidateCertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCertResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREValidateCertResponse(struct soap *soap, struct ns1__SOF_USCOREValidateCertResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREValidateCertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREValidateCert(struct soap *soap, struct ns1__SOF_USCOREValidateCert *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREValidateCert))
		soap_serialize_ns1__SOF_USCOREValidateCert(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREValidateCert *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREValidateCert, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREValidateCert(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCert ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, struct ns1__SOF_USCOREValidateCert **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREValidateCert **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREValidateCert *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREValidateCert(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREValidateCert **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREValidateCert, sizeof(struct ns1__SOF_USCOREValidateCert), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREValidateCert(struct soap *soap, struct ns1__SOF_USCOREValidateCert *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREValidateCert(soap, tag ? tag : "ns1:SOF_ValidateCert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREValidateCert ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREValidateCert(struct soap *soap, struct ns1__SOF_USCOREValidateCert **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREValidateCert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponseResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse))
		soap_serialize_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORECreateTimeStampResponseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponseResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORECreateTimeStampResponseResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORECreateTimeStampResponseResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORECreateTimeStampResponseResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORECreateTimeStampResponseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponseResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampResponseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponseResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(soap, tag ? tag : "ns1:SOF_CreateTimeStampResponseResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponseResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse))
		soap_serialize_ns1__SOF_USCORECreateTimeStampResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORECreateTimeStampResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORECreateTimeStampResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORECreateTimeStampResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORECreateTimeStampResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORECreateTimeStampResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORECreateTimeStampResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORECreateTimeStampResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORECreateTimeStampResponse(soap, tag ? tag : "ns1:SOF_CreateTimeStampResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORECreateTimeStampResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethodResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse))
		soap_serialize_ns1__SOF_USCOREGetEncryptMethodResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetEncryptMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetEncryptMethodResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethodResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetEncryptMethodResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetEncryptMethodResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetEncryptMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetEncryptMethodResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetEncryptMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethodResponse, sizeof(struct ns1__SOF_USCOREGetEncryptMethodResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethodResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetEncryptMethodResponse(soap, tag ? tag : "ns1:SOF_GetEncryptMethodResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethodResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetEncryptMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod))
		soap_serialize_ns1__SOF_USCOREGetEncryptMethod(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetEncryptMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetEncryptMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethod ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetEncryptMethod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetEncryptMethod **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetEncryptMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetEncryptMethod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetEncryptMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetEncryptMethod, sizeof(struct ns1__SOF_USCOREGetEncryptMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetEncryptMethod(soap, tag ? tag : "ns1:SOF_GetEncryptMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetEncryptMethod ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct ns1__SOF_USCOREGetEncryptMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetEncryptMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequestResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse))
		soap_serialize_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORECreateTimeStampRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequestResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORECreateTimeStampRequestResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORECreateTimeStampRequestResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORECreateTimeStampRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORECreateTimeStampRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequestResponse, sizeof(struct ns1__SOF_USCORECreateTimeStampRequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequestResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(soap, tag ? tag : "ns1:SOF_CreateTimeStampRequestResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequestResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest))
		soap_serialize_ns1__SOF_USCORECreateTimeStampRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORECreateTimeStampRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORECreateTimeStampRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequest ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, struct ns1__SOF_USCORECreateTimeStampRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORECreateTimeStampRequest **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORECreateTimeStampRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORECreateTimeStampRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORECreateTimeStampRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORECreateTimeStampRequest, sizeof(struct ns1__SOF_USCORECreateTimeStampRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORECreateTimeStampRequest(soap, tag ? tag : "ns1:SOF_CreateTimeStampRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORECreateTimeStampRequest ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct ns1__SOF_USCORECreateTimeStampRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORECreateTimeStampRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethodResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse))
		soap_serialize_ns1__SOF_USCORESetEncryptMethodResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESetEncryptMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESetEncryptMethodResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethodResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetEncryptMethodResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESetEncryptMethodResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESetEncryptMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESetEncryptMethodResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetEncryptMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethodResponse, sizeof(struct ns1__SOF_USCORESetEncryptMethodResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethodResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESetEncryptMethodResponse(soap, tag ? tag : "ns1:SOF_SetEncryptMethodResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethodResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESetEncryptMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESetEncryptMethod(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod))
		soap_serialize_ns1__SOF_USCORESetEncryptMethod(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESetEncryptMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESetEncryptMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethod ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetEncryptMethod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESetEncryptMethod **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESetEncryptMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESetEncryptMethod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetEncryptMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESetEncryptMethod, sizeof(struct ns1__SOF_USCORESetEncryptMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESetEncryptMethod(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESetEncryptMethod(soap, tag ? tag : "ns1:SOF_SetEncryptMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetEncryptMethod ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESetEncryptMethod(struct soap *soap, struct ns1__SOF_USCORESetEncryptMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESetEncryptMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESetWebAppNameResponse(struct soap *soap, struct ns1__SOF_USCORESetWebAppNameResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse))
		soap_serialize_ns1__SOF_USCORESetWebAppNameResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESetWebAppNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESetWebAppNameResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppNameResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetWebAppNameResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESetWebAppNameResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESetWebAppNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESetWebAppNameResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetWebAppNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESetWebAppNameResponse, sizeof(struct ns1__SOF_USCORESetWebAppNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESetWebAppNameResponse(struct soap *soap, struct ns1__SOF_USCORESetWebAppNameResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESetWebAppNameResponse(soap, tag ? tag : "ns1:SOF_SetWebAppNameResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppNameResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESetWebAppNameResponse(struct soap *soap, struct ns1__SOF_USCORESetWebAppNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESetWebAppNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESetWebAppName(struct soap *soap, struct ns1__SOF_USCORESetWebAppName *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESetWebAppName))
		soap_serialize_ns1__SOF_USCORESetWebAppName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESetWebAppName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESetWebAppName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESetWebAppName(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppName ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetWebAppName **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESetWebAppName **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESetWebAppName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESetWebAppName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetWebAppName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESetWebAppName, sizeof(struct ns1__SOF_USCORESetWebAppName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESetWebAppName(struct soap *soap, struct ns1__SOF_USCORESetWebAppName *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESetWebAppName(soap, tag ? tag : "ns1:SOF_SetWebAppName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetWebAppName ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESetWebAppName(struct soap *soap, struct ns1__SOF_USCORESetWebAppName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESetWebAppName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetSignMethodResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse))
		soap_serialize_ns1__SOF_USCOREGetSignMethodResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetSignMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetSignMethodResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethodResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetSignMethodResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetSignMethodResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetSignMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetSignMethodResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetSignMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetSignMethodResponse, sizeof(struct ns1__SOF_USCOREGetSignMethodResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetSignMethodResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetSignMethodResponse(soap, tag ? tag : "ns1:SOF_GetSignMethodResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethodResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetSignMethodResponse(struct soap *soap, struct ns1__SOF_USCOREGetSignMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetSignMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetSignMethod(struct soap *soap, struct ns1__SOF_USCOREGetSignMethod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetSignMethod))
		soap_serialize_ns1__SOF_USCOREGetSignMethod(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetSignMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetSignMethod, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetSignMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethod ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetSignMethod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetSignMethod **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetSignMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetSignMethod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetSignMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetSignMethod, sizeof(struct ns1__SOF_USCOREGetSignMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetSignMethod(struct soap *soap, struct ns1__SOF_USCOREGetSignMethod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetSignMethod(soap, tag ? tag : "ns1:SOF_GetSignMethod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetSignMethod ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetSignMethod(struct soap *soap, struct ns1__SOF_USCOREGetSignMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetSignMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGenRandomResponse(struct soap *soap, struct ns1__SOF_USCOREGenRandomResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse))
		soap_serialize_ns1__SOF_USCOREGenRandomResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGenRandomResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGenRandomResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGenRandomResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandomResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGenRandomResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGenRandomResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGenRandomResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGenRandomResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGenRandomResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGenRandomResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGenRandomResponse, sizeof(struct ns1__SOF_USCOREGenRandomResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGenRandomResponse(struct soap *soap, struct ns1__SOF_USCOREGenRandomResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGenRandomResponse(soap, tag ? tag : "ns1:SOF_GenRandomResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandomResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGenRandomResponse(struct soap *soap, struct ns1__SOF_USCOREGenRandomResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGenRandomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGenRandom(struct soap *soap, struct ns1__SOF_USCOREGenRandom *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGenRandom))
		soap_serialize_ns1__SOF_USCOREGenRandom(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGenRandom *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGenRandom, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGenRandom(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandom ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGenRandom **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGenRandom **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGenRandom *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGenRandom(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGenRandom **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGenRandom, sizeof(struct ns1__SOF_USCOREGenRandom), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGenRandom(struct soap *soap, struct ns1__SOF_USCOREGenRandom *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGenRandom(soap, tag ? tag : "ns1:SOF_GenRandom", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGenRandom ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGenRandom(struct soap *soap, struct ns1__SOF_USCOREGenRandom **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGenRandom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecryptResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse))
		soap_serialize_ns1__SOF_USCOREPriKeyDecryptResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREPriKeyDecryptResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREPriKeyDecryptResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecryptResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREPriKeyDecryptResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREPriKeyDecryptResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREPriKeyDecryptResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREPriKeyDecryptResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREPriKeyDecryptResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecryptResponse, sizeof(struct ns1__SOF_USCOREPriKeyDecryptResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecryptResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREPriKeyDecryptResponse(soap, tag ? tag : "ns1:SOF_PriKeyDecryptResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecryptResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecryptResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREPriKeyDecryptResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecrypt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt))
		soap_serialize_ns1__SOF_USCOREPriKeyDecrypt(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREPriKeyDecrypt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREPriKeyDecrypt(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecrypt ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, struct ns1__SOF_USCOREPriKeyDecrypt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREPriKeyDecrypt **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREPriKeyDecrypt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREPriKeyDecrypt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREPriKeyDecrypt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREPriKeyDecrypt, sizeof(struct ns1__SOF_USCOREPriKeyDecrypt), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecrypt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREPriKeyDecrypt(soap, tag ? tag : "ns1:SOF_PriKeyDecrypt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPriKeyDecrypt ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct ns1__SOF_USCOREPriKeyDecrypt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREPriKeyDecrypt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetInstanceResponse(struct soap *soap, struct ns1__SOF_USCOREGetInstanceResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse))
		soap_serialize_ns1__SOF_USCOREGetInstanceResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetInstanceResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetInstanceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetInstanceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstanceResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetInstanceResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetInstanceResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetInstanceResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetInstanceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetInstanceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetInstanceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetInstanceResponse, sizeof(struct ns1__SOF_USCOREGetInstanceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetInstanceResponse(struct soap *soap, struct ns1__SOF_USCOREGetInstanceResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetInstanceResponse(soap, tag ? tag : "ns1:SOF_GetInstanceResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstanceResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetInstanceResponse(struct soap *soap, struct ns1__SOF_USCOREGetInstanceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetInstanceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetInstance(struct soap *soap, struct ns1__SOF_USCOREGetInstance *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetInstance))
		soap_serialize_ns1__SOF_USCOREGetInstance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetInstance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetInstance, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetInstance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstance ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetInstance **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetInstance **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetInstance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetInstance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetInstance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetInstance, sizeof(struct ns1__SOF_USCOREGetInstance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetInstance(struct soap *soap, struct ns1__SOF_USCOREGetInstance *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetInstance(soap, tag ? tag : "ns1:SOF_GetInstance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetInstance ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetInstance(struct soap *soap, struct ns1__SOF_USCOREGetInstance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESignFileResponse(struct soap *soap, struct ns1__SOF_USCORESignFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESignFileResponse))
		soap_serialize_ns1__SOF_USCORESignFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESignFileResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESignFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESignFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESignFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESignFileResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESignFileResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESignFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESignFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESignFileResponse, sizeof(struct ns1__SOF_USCORESignFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESignFileResponse(struct soap *soap, struct ns1__SOF_USCORESignFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESignFileResponse(soap, tag ? tag : "ns1:SOF_SignFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESignFileResponse(struct soap *soap, struct ns1__SOF_USCORESignFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESignFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESignFile(struct soap *soap, struct ns1__SOF_USCORESignFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESignFile))
		soap_serialize_ns1__SOF_USCORESignFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESignFile(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESignFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESignFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESignFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFile ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESignFile(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESignFile **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESignFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESignFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESignFile, sizeof(struct ns1__SOF_USCORESignFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESignFile(struct soap *soap, struct ns1__SOF_USCORESignFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESignFile(soap, tag ? tag : "ns1:SOF_SignFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignFile ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESignFile(struct soap *soap, struct ns1__SOF_USCORESignFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESignFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXMLResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse))
		soap_serialize_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifySignedDataXMLResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXMLResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataXMLResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifySignedDataXMLResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifySignedDataXMLResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataXMLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXMLResponse, sizeof(struct ns1__SOF_USCOREVerifySignedDataXMLResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXMLResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag ? tag : "ns1:SOF_VerifySignedDataXMLResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXMLResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXMLResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXML *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML))
		soap_serialize_ns1__SOF_USCOREVerifySignedDataXML(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifySignedDataXML *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifySignedDataXML(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXML ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataXML **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifySignedDataXML **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifySignedDataXML *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifySignedDataXML(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataXML **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataXML, sizeof(struct ns1__SOF_USCOREVerifySignedDataXML), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXML *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedDataXML(soap, tag ? tag : "ns1:SOF_VerifySignedDataXML", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataXML ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataXML **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifySignedDataXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESignDataResponse(struct soap *soap, struct ns1__SOF_USCORESignDataResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESignDataResponse))
		soap_serialize_ns1__SOF_USCORESignDataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESignDataResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESignDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESignDataResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESignDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESignDataResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignDataResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESignDataResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESignDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESignDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESignDataResponse, sizeof(struct ns1__SOF_USCORESignDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESignDataResponse(struct soap *soap, struct ns1__SOF_USCORESignDataResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESignDataResponse(soap, tag ? tag : "ns1:SOF_SignDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESignDataResponse(struct soap *soap, struct ns1__SOF_USCORESignDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESignDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESignData(struct soap *soap, struct ns1__SOF_USCORESignData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESignData))
		soap_serialize_ns1__SOF_USCORESignData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESignData(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESignData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESignData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESignData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignData ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESignData(struct soap *soap, const char *tag, struct ns1__SOF_USCORESignData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESignData **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESignData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESignData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESignData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESignData, sizeof(struct ns1__SOF_USCORESignData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESignData(struct soap *soap, struct ns1__SOF_USCORESignData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESignData(soap, tag ? tag : "ns1:SOF_SignData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESignData ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESignData(struct soap *soap, struct ns1__SOF_USCORESignData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESignData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse))
		soap_serialize_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetXMLSignatureInfoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetXMLSignatureInfoResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetXMLSignatureInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfoResponse, sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag ? tag : "ns1:SOF_GetXMLSignatureInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo))
		soap_serialize_ns1__SOF_USCOREGetXMLSignatureInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetXMLSignatureInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetXMLSignatureInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfo ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetXMLSignatureInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetXMLSignatureInfo **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetXMLSignatureInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetXMLSignatureInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetXMLSignatureInfo, sizeof(struct ns1__SOF_USCOREGetXMLSignatureInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetXMLSignatureInfo(soap, tag ? tag : "ns1:SOF_GetXMLSignatureInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetXMLSignatureInfo ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct ns1__SOF_USCOREGetXMLSignatureInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetXMLSignatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustListResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse))
		soap_serialize_ns1__SOF_USCOREDelCertTrustListResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREDelCertTrustListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREDelCertTrustListResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustListResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDelCertTrustListResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREDelCertTrustListResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREDelCertTrustListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREDelCertTrustListResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDelCertTrustListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustListResponse, sizeof(struct ns1__SOF_USCOREDelCertTrustListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustListResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREDelCertTrustListResponse(soap, tag ? tag : "ns1:SOF_DelCertTrustListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustListResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREDelCertTrustListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREDelCertTrustList(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList))
		soap_serialize_ns1__SOF_USCOREDelCertTrustList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREDelCertTrustList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREDelCertTrustList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustList ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, struct ns1__SOF_USCOREDelCertTrustList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREDelCertTrustList **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREDelCertTrustList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREDelCertTrustList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREDelCertTrustList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREDelCertTrustList, sizeof(struct ns1__SOF_USCOREDelCertTrustList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREDelCertTrustList(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREDelCertTrustList(soap, tag ? tag : "ns1:SOF_DelCertTrustList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREDelCertTrustList ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREDelCertTrustList(struct soap *soap, struct ns1__SOF_USCOREDelCertTrustList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREDelCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificateResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse))
		soap_serialize_ns1__SOF_USCOREGetServerCertificateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetServerCertificateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetServerCertificateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificateResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetServerCertificateResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetServerCertificateResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetServerCertificateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetServerCertificateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetServerCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificateResponse, sizeof(struct ns1__SOF_USCOREGetServerCertificateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificateResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetServerCertificateResponse(soap, tag ? tag : "ns1:SOF_GetServerCertificateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificateResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetServerCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetServerCertificate(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate))
		soap_serialize_ns1__SOF_USCOREGetServerCertificate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetServerCertificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetServerCertificate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificate ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetServerCertificate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetServerCertificate **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetServerCertificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetServerCertificate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetServerCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetServerCertificate, sizeof(struct ns1__SOF_USCOREGetServerCertificate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetServerCertificate(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetServerCertificate(soap, tag ? tag : "ns1:SOF_GetServerCertificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetServerCertificate ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetServerCertificate(struct soap *soap, struct ns1__SOF_USCOREGetServerCertificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetServerCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOidResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse))
		soap_serialize_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetCertInfoByOidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOidResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetCertInfoByOidResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetCertInfoByOidResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetCertInfoByOidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetCertInfoByOidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOidResponse, sizeof(struct ns1__SOF_USCOREGetCertInfoByOidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOidResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(soap, tag ? tag : "ns1:SOF_GetCertInfoByOidResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOidResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOid *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid))
		soap_serialize_ns1__SOF_USCOREGetCertInfoByOid(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetCertInfoByOid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetCertInfoByOid(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOid ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetCertInfoByOid **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetCertInfoByOid **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetCertInfoByOid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetCertInfoByOid(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetCertInfoByOid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetCertInfoByOid, sizeof(struct ns1__SOF_USCOREGetCertInfoByOid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOid *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetCertInfoByOid(soap, tag ? tag : "ns1:SOF_GetCertInfoByOid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetCertInfoByOid ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct ns1__SOF_USCOREGetCertInfoByOid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetCertInfoByOid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse))
		soap_serialize_ns1__SOF_USCOREVerifySignedFileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifySignedFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifySignedFileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFileResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedFileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifySignedFileResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifySignedFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifySignedFileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFileResponse, sizeof(struct ns1__SOF_USCOREVerifySignedFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedFileResponse(soap, tag ? tag : "ns1:SOF_VerifySignedFileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFileResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifySignedFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifySignedFile(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile))
		soap_serialize_ns1__SOF_USCOREVerifySignedFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifySignedFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifySignedFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFile ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifySignedFile **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifySignedFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifySignedFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedFile, sizeof(struct ns1__SOF_USCOREVerifySignedFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifySignedFile(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedFile(soap, tag ? tag : "ns1:SOF_VerifySignedFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedFile ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifySignedFile(struct soap *soap, struct ns1__SOF_USCOREVerifySignedFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifySignedFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStampResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse))
		soap_serialize_ns1__SOF_USCOREVerifyTimeStampResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifyTimeStampResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifyTimeStampResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStampResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifyTimeStampResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifyTimeStampResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifyTimeStampResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifyTimeStampResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifyTimeStampResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStampResponse, sizeof(struct ns1__SOF_USCOREVerifyTimeStampResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStampResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifyTimeStampResponse(soap, tag ? tag : "ns1:SOF_VerifyTimeStampResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStampResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStampResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifyTimeStampResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStamp *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp))
		soap_serialize_ns1__SOF_USCOREVerifyTimeStamp(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifyTimeStamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifyTimeStamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStamp ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifyTimeStamp **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifyTimeStamp **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifyTimeStamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifyTimeStamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifyTimeStamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifyTimeStamp, sizeof(struct ns1__SOF_USCOREVerifyTimeStamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStamp *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifyTimeStamp(soap, tag ? tag : "ns1:SOF_VerifyTimeStamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifyTimeStamp ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct ns1__SOF_USCOREVerifyTimeStamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifyTimeStamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncryptResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse))
		soap_serialize_ns1__SOF_USCOREPubKeyEncryptResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREPubKeyEncryptResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREPubKeyEncryptResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncryptResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREPubKeyEncryptResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREPubKeyEncryptResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREPubKeyEncryptResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREPubKeyEncryptResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREPubKeyEncryptResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncryptResponse, sizeof(struct ns1__SOF_USCOREPubKeyEncryptResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncryptResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREPubKeyEncryptResponse(soap, tag ? tag : "ns1:SOF_PubKeyEncryptResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncryptResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncryptResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREPubKeyEncryptResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncrypt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt))
		soap_serialize_ns1__SOF_USCOREPubKeyEncrypt(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREPubKeyEncrypt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREPubKeyEncrypt(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncrypt ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, struct ns1__SOF_USCOREPubKeyEncrypt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREPubKeyEncrypt **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREPubKeyEncrypt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREPubKeyEncrypt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREPubKeyEncrypt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREPubKeyEncrypt, sizeof(struct ns1__SOF_USCOREPubKeyEncrypt), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncrypt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREPubKeyEncrypt(soap, tag ? tag : "ns1:SOF_PubKeyEncrypt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREPubKeyEncrypt ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct ns1__SOF_USCOREPubKeyEncrypt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREPubKeyEncrypt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7Response *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response))
		soap_serialize_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifySignedDataByP7Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7Response ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataByP7Response **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifySignedDataByP7Response **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataByP7Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7Response, sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7Response *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(soap, tag ? tag : "ns1:SOF_VerifySignedDataByP7Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7Response ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7))
		soap_serialize_ns1__SOF_USCOREVerifySignedDataByP7(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifySignedDataByP7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifySignedDataByP7(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7 ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataByP7 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifySignedDataByP7 **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifySignedDataByP7(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataByP7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataByP7, sizeof(struct ns1__SOF_USCOREVerifySignedDataByP7), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedDataByP7(soap, tag ? tag : "ns1:SOF_VerifySignedDataByP7", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataByP7 ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataByP7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifySignedDataByP7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESetCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCORESetCertTrustListResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse))
		soap_serialize_ns1__SOF_USCORESetCertTrustListResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESetCertTrustListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESetCertTrustListResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustListResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetCertTrustListResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESetCertTrustListResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESetCertTrustListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESetCertTrustListResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetCertTrustListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESetCertTrustListResponse, sizeof(struct ns1__SOF_USCORESetCertTrustListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESetCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCORESetCertTrustListResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESetCertTrustListResponse(soap, tag ? tag : "ns1:SOF_SetCertTrustListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustListResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESetCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCORESetCertTrustListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESetCertTrustListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCORESetCertTrustList(struct soap *soap, struct ns1__SOF_USCORESetCertTrustList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCORESetCertTrustList))
		soap_serialize_ns1__SOF_USCORESetCertTrustList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCORESetCertTrustList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCORESetCertTrustList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCORESetCertTrustList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustList ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, struct ns1__SOF_USCORESetCertTrustList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCORESetCertTrustList **)soap_malloc(soap, sizeof(struct ns1__SOF_USCORESetCertTrustList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCORESetCertTrustList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCORESetCertTrustList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCORESetCertTrustList, sizeof(struct ns1__SOF_USCORESetCertTrustList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCORESetCertTrustList(struct soap *soap, struct ns1__SOF_USCORESetCertTrustList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCORESetCertTrustList(soap, tag ? tag : "ns1:SOF_SetCertTrustList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCORESetCertTrustList ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCORESetCertTrustList(struct soap *soap, struct ns1__SOF_USCORESetCertTrustList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCORESetCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse))
		soap_serialize_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetP7SignDataInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetP7SignDataInfoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetP7SignDataInfoResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetP7SignDataInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetP7SignDataInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfoResponse, sizeof(struct ns1__SOF_USCOREGetP7SignDataInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag ? tag : "ns1:SOF_GetP7SignDataInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo))
		soap_serialize_ns1__SOF_USCOREGetP7SignDataInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREGetP7SignDataInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREGetP7SignDataInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfo ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, struct ns1__SOF_USCOREGetP7SignDataInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREGetP7SignDataInfo **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREGetP7SignDataInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREGetP7SignDataInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREGetP7SignDataInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREGetP7SignDataInfo, sizeof(struct ns1__SOF_USCOREGetP7SignDataInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREGetP7SignDataInfo(soap, tag ? tag : "ns1:SOF_GetP7SignDataInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREGetP7SignDataInfo ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct ns1__SOF_USCOREGetP7SignDataInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREGetP7SignDataInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse))
		soap_serialize_ns1__SOF_USCOREQueryCertTrustListResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREQueryCertTrustListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREQueryCertTrustListResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREQueryCertTrustListResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREQueryCertTrustListResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREQueryCertTrustListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREQueryCertTrustListResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREQueryCertTrustListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustListResponse, sizeof(struct ns1__SOF_USCOREQueryCertTrustListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREQueryCertTrustListResponse(soap, tag ? tag : "ns1:SOF_QueryCertTrustListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustListResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREQueryCertTrustListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList))
		soap_serialize_ns1__SOF_USCOREQueryCertTrustList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREQueryCertTrustList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREQueryCertTrustList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustList ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, struct ns1__SOF_USCOREQueryCertTrustList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREQueryCertTrustList **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREQueryCertTrustList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREQueryCertTrustList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREQueryCertTrustList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREQueryCertTrustList, sizeof(struct ns1__SOF_USCOREQueryCertTrustList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREQueryCertTrustList(soap, tag ? tag : "ns1:SOF_QueryCertTrustList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREQueryCertTrustList ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct ns1__SOF_USCOREQueryCertTrustList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREQueryCertTrustList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse))
		soap_serialize_ns1__SOF_USCOREVerifySignedDataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifySignedDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifySignedDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedDataResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifySignedDataResponse **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifySignedDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifySignedDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedDataResponse, sizeof(struct ns1__SOF_USCOREVerifySignedDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedDataResponse(soap, tag ? tag : "ns1:SOF_VerifySignedDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, struct ns1__SOF_USCOREVerifySignedDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifySignedDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SOF_USCOREVerifySignedData(struct soap *soap, struct ns1__SOF_USCOREVerifySignedData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedData))
		soap_serialize_ns1__SOF_USCOREVerifySignedData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, int id, struct ns1__SOF_USCOREVerifySignedData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SOF_USCOREVerifySignedData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SOF_USCOREVerifySignedData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedData ** SOAP_FMAC4 soap_in_PointerTons1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, struct ns1__SOF_USCOREVerifySignedData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SOF_USCOREVerifySignedData **)soap_malloc(soap, sizeof(struct ns1__SOF_USCOREVerifySignedData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SOF_USCOREVerifySignedData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SOF_USCOREVerifySignedData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SOF_USCOREVerifySignedData, sizeof(struct ns1__SOF_USCOREVerifySignedData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SOF_USCOREVerifySignedData(struct soap *soap, struct ns1__SOF_USCOREVerifySignedData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SOF_USCOREVerifySignedData(soap, tag ? tag : "ns1:SOF_VerifySignedData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SOF_USCOREVerifySignedData ** SOAP_FMAC4 soap_get_PointerTons1__SOF_USCOREVerifySignedData(struct soap *soap, struct ns1__SOF_USCOREVerifySignedData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SOF_USCOREVerifySignedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sofSecurityEngineDeal(struct soap *soap, struct ns1__sofSecurityEngineDeal *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sofSecurityEngineDeal))
		soap_serialize_ns1__sofSecurityEngineDeal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sofSecurityEngineDeal(struct soap *soap, const char *tag, int id, struct ns1__sofSecurityEngineDeal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sofSecurityEngineDeal, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__sofSecurityEngineDeal(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__sofSecurityEngineDeal ** SOAP_FMAC4 soap_in_PointerTons1__sofSecurityEngineDeal(struct soap *soap, const char *tag, struct ns1__sofSecurityEngineDeal **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__sofSecurityEngineDeal **)soap_malloc(soap, sizeof(struct ns1__sofSecurityEngineDeal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__sofSecurityEngineDeal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__sofSecurityEngineDeal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sofSecurityEngineDeal, sizeof(struct ns1__sofSecurityEngineDeal), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sofSecurityEngineDeal(struct soap *soap, struct ns1__sofSecurityEngineDeal *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__sofSecurityEngineDeal(soap, tag ? tag : "ns1:sofSecurityEngineDeal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sofSecurityEngineDeal ** SOAP_FMAC4 soap_get_PointerTons1__sofSecurityEngineDeal(struct soap *soap, struct ns1__sofSecurityEngineDeal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sofSecurityEngineDeal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *p;
	char * *a = (char **)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char *));
	for (p = a; p && n--; p++)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
