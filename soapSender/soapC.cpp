/* soapC.cpp
   Generated by gSOAP 2.7.7 from SOF_interface.h
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.7 2017-09-22 05:17:45 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse:
		return soap_in_WS1__SOF_USCOREEncryptDataResponse(soap, NULL, NULL, "WS1:SOF_EncryptDataResponse");
	case SOAP_TYPE_WS1__SOF_USCOREEncryptData:
		return soap_in_WS1__SOF_USCOREEncryptData(soap, NULL, NULL, "WS1:SOF_EncryptData");
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse:
		return soap_in_WS1__SOF_USCOREGetCertInfoResponse(soap, NULL, NULL, "WS1:SOF_GetCertInfoResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfo:
		return soap_in_WS1__SOF_USCOREGetCertInfo(soap, NULL, NULL, "WS1:SOF_GetCertInfo");
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return soap_in_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, NULL, NULL, "WS1:SOF_QueryCertTrustListAltNamesResponse");
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames:
		return soap_in_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, NULL, NULL, "WS1:SOF_QueryCertTrustListAltNames");
	case SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse:
		return soap_in_WS1__SOF_USCOREDecryptDataResponse(soap, NULL, NULL, "WS1:SOF_DecryptDataResponse");
	case SOAP_TYPE_WS1__SOF_USCOREDecryptData:
		return soap_in_WS1__SOF_USCOREDecryptData(soap, NULL, NULL, "WS1:SOF_DecryptData");
	case SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse:
		return soap_in_WS1__SOF_USCORESignDataXMLResponse(soap, NULL, NULL, "WS1:SOF_SignDataXMLResponse");
	case SOAP_TYPE_WS1__SOF_USCORESignDataXML:
		return soap_in_WS1__SOF_USCORESignDataXML(soap, NULL, NULL, "WS1:SOF_SignDataXML");
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse:
		return soap_in_WS1__SOF_USCOREEncryptFileResponse(soap, NULL, NULL, "WS1:SOF_EncryptFileResponse");
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFile:
		return soap_in_WS1__SOF_USCOREEncryptFile(soap, NULL, NULL, "WS1:SOF_EncryptFile");
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response:
		return soap_in_WS1__SOF_USCORESignDataByP7Response(soap, NULL, NULL, "WS1:SOF_SignDataByP7Response");
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7:
		return soap_in_WS1__SOF_USCORESignDataByP7(soap, NULL, NULL, "WS1:SOF_SignDataByP7");
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse:
		return soap_in_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, NULL, NULL, "WS1:SOF_GetTimeStampInfoResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo:
		return soap_in_WS1__SOF_USCOREGetTimeStampInfo(soap, NULL, NULL, "WS1:SOF_GetTimeStampInfo");
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse:
		return soap_in_WS1__SOF_USCORESetSignMethodResponse(soap, NULL, NULL, "WS1:SOF_SetSignMethodResponse");
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethod:
		return soap_in_WS1__SOF_USCORESetSignMethod(soap, NULL, NULL, "WS1:SOF_SetSignMethod");
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse:
		return soap_in_WS1__SOF_USCOREDecryptFileResponse(soap, NULL, NULL, "WS1:SOF_DecryptFileResponse");
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFile:
		return soap_in_WS1__SOF_USCOREDecryptFile(soap, NULL, NULL, "WS1:SOF_DecryptFile");
	case SOAP_TYPE_WS1__GetFileResponse:
		return soap_in_WS1__GetFileResponse(soap, NULL, NULL, "WS1:GetFileResponse");
	case SOAP_TYPE_WS1__GetFile:
		return soap_in_WS1__GetFile(soap, NULL, NULL, "WS1:GetFile");
	case SOAP_TYPE_WS1__DeleteFileResponse:
		return soap_in_WS1__DeleteFileResponse(soap, NULL, NULL, "WS1:DeleteFileResponse");
	case SOAP_TYPE_WS1__DeleteFile:
		return soap_in_WS1__DeleteFile(soap, NULL, NULL, "WS1:DeleteFile");
	case SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse:
		return soap_in_WS1__SOF_USCOREValidateCertResponse(soap, NULL, NULL, "WS1:SOF_ValidateCertResponse");
	case SOAP_TYPE_WS1__SOF_USCOREValidateCert:
		return soap_in_WS1__SOF_USCOREValidateCert(soap, NULL, NULL, "WS1:SOF_ValidateCert");
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse:
		return soap_in_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, NULL, NULL, "WS1:SOF_CreateTimeStampResponseResponse");
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse:
		return soap_in_WS1__SOF_USCORECreateTimeStampResponse(soap, NULL, NULL, "WS1:SOF_CreateTimeStampResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse:
		return soap_in_WS1__SOF_USCOREGetEncryptMethodResponse(soap, NULL, NULL, "WS1:SOF_GetEncryptMethodResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod:
		return soap_in_WS1__SOF_USCOREGetEncryptMethod(soap, NULL, NULL, "WS1:SOF_GetEncryptMethod");
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse:
		return soap_in_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, NULL, NULL, "WS1:SOF_CreateTimeStampRequestResponse");
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest:
		return soap_in_WS1__SOF_USCORECreateTimeStampRequest(soap, NULL, NULL, "WS1:SOF_CreateTimeStampRequest");
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse:
		return soap_in_WS1__SOF_USCORESetEncryptMethodResponse(soap, NULL, NULL, "WS1:SOF_SetEncryptMethodResponse");
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod:
		return soap_in_WS1__SOF_USCORESetEncryptMethod(soap, NULL, NULL, "WS1:SOF_SetEncryptMethod");
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse:
		return soap_in_WS1__SOF_USCOREGetSignMethodResponse(soap, NULL, NULL, "WS1:SOF_GetSignMethodResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethod:
		return soap_in_WS1__SOF_USCOREGetSignMethod(soap, NULL, NULL, "WS1:SOF_GetSignMethod");
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse:
		return soap_in_WS1__SOF_USCORESetWebAppNameResponse(soap, NULL, NULL, "WS1:SOF_SetWebAppNameResponse");
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppName:
		return soap_in_WS1__SOF_USCORESetWebAppName(soap, NULL, NULL, "WS1:SOF_SetWebAppName");
	case SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse:
		return soap_in_WS1__SOF_USCOREGenRandomResponse(soap, NULL, NULL, "WS1:SOF_GenRandomResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGenRandom:
		return soap_in_WS1__SOF_USCOREGenRandom(soap, NULL, NULL, "WS1:SOF_GenRandom");
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse:
		return soap_in_WS1__SOF_USCOREPriKeyDecryptResponse(soap, NULL, NULL, "WS1:SOF_PriKeyDecryptResponse");
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt:
		return soap_in_WS1__SOF_USCOREPriKeyDecrypt(soap, NULL, NULL, "WS1:SOF_PriKeyDecrypt");
	case SOAP_TYPE_WS1__sofSecurityEngineDeal:
		return soap_in_WS1__sofSecurityEngineDeal(soap, NULL, NULL, "WS1:sofSecurityEngineDeal");
	case SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse:
		return soap_in_WS1__SOF_USCOREGetInstanceResponse(soap, NULL, NULL, "WS1:SOF_GetInstanceResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetInstance:
		return soap_in_WS1__SOF_USCOREGetInstance(soap, NULL, NULL, "WS1:SOF_GetInstance");
	case SOAP_TYPE_WS1__SOF_USCORESignFileResponse:
		return soap_in_WS1__SOF_USCORESignFileResponse(soap, NULL, NULL, "WS1:SOF_SignFileResponse");
	case SOAP_TYPE_WS1__SOF_USCORESignFile:
		return soap_in_WS1__SOF_USCORESignFile(soap, NULL, NULL, "WS1:SOF_SignFile");
	case SOAP_TYPE_WS1__SOF_USCORESignDataResponse:
		return soap_in_WS1__SOF_USCORESignDataResponse(soap, NULL, NULL, "WS1:SOF_SignDataResponse");
	case SOAP_TYPE_WS1__SOF_USCORESignData:
		return soap_in_WS1__SOF_USCORESignData(soap, NULL, NULL, "WS1:SOF_SignData");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse:
		return soap_in_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, NULL, NULL, "WS1:SOF_VerifySignedDataXMLResponse");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML:
		return soap_in_WS1__SOF_USCOREVerifySignedDataXML(soap, NULL, NULL, "WS1:SOF_VerifySignedDataXML");
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse:
		return soap_in_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, NULL, NULL, "WS1:SOF_GetXMLSignatureInfoResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo:
		return soap_in_WS1__SOF_USCOREGetXMLSignatureInfo(soap, NULL, NULL, "WS1:SOF_GetXMLSignatureInfo");
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse:
		return soap_in_WS1__SOF_USCOREDelCertTrustListResponse(soap, NULL, NULL, "WS1:SOF_DelCertTrustListResponse");
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList:
		return soap_in_WS1__SOF_USCOREDelCertTrustList(soap, NULL, NULL, "WS1:SOF_DelCertTrustList");
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse:
		return soap_in_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, NULL, NULL, "WS1:SOF_GetCertInfoByOidResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid:
		return soap_in_WS1__SOF_USCOREGetCertInfoByOid(soap, NULL, NULL, "WS1:SOF_GetCertInfoByOid");
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse:
		return soap_in_WS1__SOF_USCOREGetServerCertificateResponse(soap, NULL, NULL, "WS1:SOF_GetServerCertificateResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate:
		return soap_in_WS1__SOF_USCOREGetServerCertificate(soap, NULL, NULL, "WS1:SOF_GetServerCertificate");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse:
		return soap_in_WS1__SOF_USCOREVerifySignedFileResponse(soap, NULL, NULL, "WS1:SOF_VerifySignedFileResponse");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile:
		return soap_in_WS1__SOF_USCOREVerifySignedFile(soap, NULL, NULL, "WS1:SOF_VerifySignedFile");
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse:
		return soap_in_WS1__SOF_USCOREPubKeyEncryptResponse(soap, NULL, NULL, "WS1:SOF_PubKeyEncryptResponse");
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt:
		return soap_in_WS1__SOF_USCOREPubKeyEncrypt(soap, NULL, NULL, "WS1:SOF_PubKeyEncrypt");
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse:
		return soap_in_WS1__SOF_USCOREVerifyTimeStampResponse(soap, NULL, NULL, "WS1:SOF_VerifyTimeStampResponse");
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp:
		return soap_in_WS1__SOF_USCOREVerifyTimeStamp(soap, NULL, NULL, "WS1:SOF_VerifyTimeStamp");
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse:
		return soap_in_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, NULL, NULL, "WS1:SOF_GetP7SignDataInfoResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo:
		return soap_in_WS1__SOF_USCOREGetP7SignDataInfo(soap, NULL, NULL, "WS1:SOF_GetP7SignDataInfo");
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse:
		return soap_in_WS1__SOF_USCORESetCertTrustListResponse(soap, NULL, NULL, "WS1:SOF_SetCertTrustListResponse");
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustList:
		return soap_in_WS1__SOF_USCORESetCertTrustList(soap, NULL, NULL, "WS1:SOF_SetCertTrustList");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response:
		return soap_in_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, NULL, NULL, "WS1:SOF_VerifySignedDataByP7Response");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7:
		return soap_in_WS1__SOF_USCOREVerifySignedDataByP7(soap, NULL, NULL, "WS1:SOF_VerifySignedDataByP7");
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse:
		return soap_in_WS1__SOF_USCOREQueryCertTrustListResponse(soap, NULL, NULL, "WS1:SOF_QueryCertTrustListResponse");
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList:
		return soap_in_WS1__SOF_USCOREQueryCertTrustList(soap, NULL, NULL, "WS1:SOF_QueryCertTrustList");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse:
		return soap_in_WS1__SOF_USCOREVerifySignedDataResponse(soap, NULL, NULL, "WS1:SOF_VerifySignedDataResponse");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedData:
		return soap_in_WS1__SOF_USCOREVerifySignedData(soap, NULL, NULL, "WS1:SOF_VerifySignedData");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptDataResponse:
		return soap_in_PointerToWS1__SOF_USCOREEncryptDataResponse(soap, NULL, NULL, "WS1:SOF_EncryptDataResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptData:
		return soap_in_PointerToWS1__SOF_USCOREEncryptData(soap, NULL, NULL, "WS1:SOF_EncryptData");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, NULL, NULL, "WS1:SOF_QueryCertTrustListAltNamesResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames:
		return soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(soap, NULL, NULL, "WS1:SOF_QueryCertTrustListAltNames");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetCertInfoResponse(soap, NULL, NULL, "WS1:SOF_GetCertInfoResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfo:
		return soap_in_PointerToWS1__SOF_USCOREGetCertInfo(soap, NULL, NULL, "WS1:SOF_GetCertInfo");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataXMLResponse:
		return soap_in_PointerToWS1__SOF_USCORESignDataXMLResponse(soap, NULL, NULL, "WS1:SOF_SignDataXMLResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataXML:
		return soap_in_PointerToWS1__SOF_USCORESignDataXML(soap, NULL, NULL, "WS1:SOF_SignDataXML");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptDataResponse:
		return soap_in_PointerToWS1__SOF_USCOREDecryptDataResponse(soap, NULL, NULL, "WS1:SOF_DecryptDataResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptData:
		return soap_in_PointerToWS1__SOF_USCOREDecryptData(soap, NULL, NULL, "WS1:SOF_DecryptData");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataByP7Response:
		return soap_in_PointerToWS1__SOF_USCORESignDataByP7Response(soap, NULL, NULL, "WS1:SOF_SignDataByP7Response");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataByP7:
		return soap_in_PointerToWS1__SOF_USCORESignDataByP7(soap, NULL, NULL, "WS1:SOF_SignDataByP7");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptFileResponse:
		return soap_in_PointerToWS1__SOF_USCOREEncryptFileResponse(soap, NULL, NULL, "WS1:SOF_EncryptFileResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptFile:
		return soap_in_PointerToWS1__SOF_USCOREEncryptFile(soap, NULL, NULL, "WS1:SOF_EncryptFile");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(soap, NULL, NULL, "WS1:SOF_GetTimeStampInfoResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetTimeStampInfo:
		return soap_in_PointerToWS1__SOF_USCOREGetTimeStampInfo(soap, NULL, NULL, "WS1:SOF_GetTimeStampInfo");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetSignMethodResponse:
		return soap_in_PointerToWS1__SOF_USCORESetSignMethodResponse(soap, NULL, NULL, "WS1:SOF_SetSignMethodResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetSignMethod:
		return soap_in_PointerToWS1__SOF_USCORESetSignMethod(soap, NULL, NULL, "WS1:SOF_SetSignMethod");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptFileResponse:
		return soap_in_PointerToWS1__SOF_USCOREDecryptFileResponse(soap, NULL, NULL, "WS1:SOF_DecryptFileResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptFile:
		return soap_in_PointerToWS1__SOF_USCOREDecryptFile(soap, NULL, NULL, "WS1:SOF_DecryptFile");
	case SOAP_TYPE_PointerToWS1__GetFileResponse:
		return soap_in_PointerToWS1__GetFileResponse(soap, NULL, NULL, "WS1:GetFileResponse");
	case SOAP_TYPE_PointerToWS1__GetFile:
		return soap_in_PointerToWS1__GetFile(soap, NULL, NULL, "WS1:GetFile");
	case SOAP_TYPE_PointerToWS1__DeleteFileResponse:
		return soap_in_PointerToWS1__DeleteFileResponse(soap, NULL, NULL, "WS1:DeleteFileResponse");
	case SOAP_TYPE_PointerToWS1__DeleteFile:
		return soap_in_PointerToWS1__DeleteFile(soap, NULL, NULL, "WS1:DeleteFile");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREValidateCertResponse:
		return soap_in_PointerToWS1__SOF_USCOREValidateCertResponse(soap, NULL, NULL, "WS1:SOF_ValidateCertResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREValidateCert:
		return soap_in_PointerToWS1__SOF_USCOREValidateCert(soap, NULL, NULL, "WS1:SOF_ValidateCert");
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse:
		return soap_in_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(soap, NULL, NULL, "WS1:SOF_CreateTimeStampResponseResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampResponse:
		return soap_in_PointerToWS1__SOF_USCORECreateTimeStampResponse(soap, NULL, NULL, "WS1:SOF_CreateTimeStampResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetEncryptMethodResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(soap, NULL, NULL, "WS1:SOF_GetEncryptMethodResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetEncryptMethod:
		return soap_in_PointerToWS1__SOF_USCOREGetEncryptMethod(soap, NULL, NULL, "WS1:SOF_GetEncryptMethod");
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse:
		return soap_in_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(soap, NULL, NULL, "WS1:SOF_CreateTimeStampRequestResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampRequest:
		return soap_in_PointerToWS1__SOF_USCORECreateTimeStampRequest(soap, NULL, NULL, "WS1:SOF_CreateTimeStampRequest");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetEncryptMethodResponse:
		return soap_in_PointerToWS1__SOF_USCORESetEncryptMethodResponse(soap, NULL, NULL, "WS1:SOF_SetEncryptMethodResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetEncryptMethod:
		return soap_in_PointerToWS1__SOF_USCORESetEncryptMethod(soap, NULL, NULL, "WS1:SOF_SetEncryptMethod");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetWebAppNameResponse:
		return soap_in_PointerToWS1__SOF_USCORESetWebAppNameResponse(soap, NULL, NULL, "WS1:SOF_SetWebAppNameResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetWebAppName:
		return soap_in_PointerToWS1__SOF_USCORESetWebAppName(soap, NULL, NULL, "WS1:SOF_SetWebAppName");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetSignMethodResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetSignMethodResponse(soap, NULL, NULL, "WS1:SOF_GetSignMethodResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetSignMethod:
		return soap_in_PointerToWS1__SOF_USCOREGetSignMethod(soap, NULL, NULL, "WS1:SOF_GetSignMethod");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGenRandomResponse:
		return soap_in_PointerToWS1__SOF_USCOREGenRandomResponse(soap, NULL, NULL, "WS1:SOF_GenRandomResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGenRandom:
		return soap_in_PointerToWS1__SOF_USCOREGenRandom(soap, NULL, NULL, "WS1:SOF_GenRandom");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPriKeyDecryptResponse:
		return soap_in_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(soap, NULL, NULL, "WS1:SOF_PriKeyDecryptResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPriKeyDecrypt:
		return soap_in_PointerToWS1__SOF_USCOREPriKeyDecrypt(soap, NULL, NULL, "WS1:SOF_PriKeyDecrypt");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetInstanceResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetInstanceResponse(soap, NULL, NULL, "WS1:SOF_GetInstanceResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetInstance:
		return soap_in_PointerToWS1__SOF_USCOREGetInstance(soap, NULL, NULL, "WS1:SOF_GetInstance");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignFileResponse:
		return soap_in_PointerToWS1__SOF_USCORESignFileResponse(soap, NULL, NULL, "WS1:SOF_SignFileResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignFile:
		return soap_in_PointerToWS1__SOF_USCORESignFile(soap, NULL, NULL, "WS1:SOF_SignFile");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse:
		return soap_in_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(soap, NULL, NULL, "WS1:SOF_VerifySignedDataXMLResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataXML:
		return soap_in_PointerToWS1__SOF_USCOREVerifySignedDataXML(soap, NULL, NULL, "WS1:SOF_VerifySignedDataXML");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataResponse:
		return soap_in_PointerToWS1__SOF_USCORESignDataResponse(soap, NULL, NULL, "WS1:SOF_SignDataResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignData:
		return soap_in_PointerToWS1__SOF_USCORESignData(soap, NULL, NULL, "WS1:SOF_SignData");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, NULL, NULL, "WS1:SOF_GetXMLSignatureInfoResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetXMLSignatureInfo:
		return soap_in_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(soap, NULL, NULL, "WS1:SOF_GetXMLSignatureInfo");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDelCertTrustListResponse:
		return soap_in_PointerToWS1__SOF_USCOREDelCertTrustListResponse(soap, NULL, NULL, "WS1:SOF_DelCertTrustListResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDelCertTrustList:
		return soap_in_PointerToWS1__SOF_USCOREDelCertTrustList(soap, NULL, NULL, "WS1:SOF_DelCertTrustList");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetServerCertificateResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetServerCertificateResponse(soap, NULL, NULL, "WS1:SOF_GetServerCertificateResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetServerCertificate:
		return soap_in_PointerToWS1__SOF_USCOREGetServerCertificate(soap, NULL, NULL, "WS1:SOF_GetServerCertificate");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(soap, NULL, NULL, "WS1:SOF_GetCertInfoByOidResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoByOid:
		return soap_in_PointerToWS1__SOF_USCOREGetCertInfoByOid(soap, NULL, NULL, "WS1:SOF_GetCertInfoByOid");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedFileResponse:
		return soap_in_PointerToWS1__SOF_USCOREVerifySignedFileResponse(soap, NULL, NULL, "WS1:SOF_VerifySignedFileResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedFile:
		return soap_in_PointerToWS1__SOF_USCOREVerifySignedFile(soap, NULL, NULL, "WS1:SOF_VerifySignedFile");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifyTimeStampResponse:
		return soap_in_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(soap, NULL, NULL, "WS1:SOF_VerifyTimeStampResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifyTimeStamp:
		return soap_in_PointerToWS1__SOF_USCOREVerifyTimeStamp(soap, NULL, NULL, "WS1:SOF_VerifyTimeStamp");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPubKeyEncryptResponse:
		return soap_in_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(soap, NULL, NULL, "WS1:SOF_PubKeyEncryptResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPubKeyEncrypt:
		return soap_in_PointerToWS1__SOF_USCOREPubKeyEncrypt(soap, NULL, NULL, "WS1:SOF_PubKeyEncrypt");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response:
		return soap_in_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(soap, NULL, NULL, "WS1:SOF_VerifySignedDataByP7Response");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataByP7:
		return soap_in_PointerToWS1__SOF_USCOREVerifySignedDataByP7(soap, NULL, NULL, "WS1:SOF_VerifySignedDataByP7");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetCertTrustListResponse:
		return soap_in_PointerToWS1__SOF_USCORESetCertTrustListResponse(soap, NULL, NULL, "WS1:SOF_SetCertTrustListResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetCertTrustList:
		return soap_in_PointerToWS1__SOF_USCORESetCertTrustList(soap, NULL, NULL, "WS1:SOF_SetCertTrustList");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse:
		return soap_in_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(soap, NULL, NULL, "WS1:SOF_GetP7SignDataInfoResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetP7SignDataInfo:
		return soap_in_PointerToWS1__SOF_USCOREGetP7SignDataInfo(soap, NULL, NULL, "WS1:SOF_GetP7SignDataInfo");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListResponse:
		return soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(soap, NULL, NULL, "WS1:SOF_QueryCertTrustListResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustList:
		return soap_in_PointerToWS1__SOF_USCOREQueryCertTrustList(soap, NULL, NULL, "WS1:SOF_QueryCertTrustList");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataResponse:
		return soap_in_PointerToWS1__SOF_USCOREVerifySignedDataResponse(soap, NULL, NULL, "WS1:SOF_VerifySignedDataResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedData:
		return soap_in_PointerToWS1__SOF_USCOREVerifySignedData(soap, NULL, NULL, "WS1:SOF_VerifySignedData");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToWS1__sofSecurityEngineDeal:
		return soap_in_PointerToWS1__sofSecurityEngineDeal(soap, NULL, NULL, "WS1:sofSecurityEngineDeal");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_EncryptDataResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse;
			return soap_in_WS1__SOF_USCOREEncryptDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_EncryptData"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREEncryptData;
			return soap_in_WS1__SOF_USCOREEncryptData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetCertInfoResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse;
			return soap_in_WS1__SOF_USCOREGetCertInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetCertInfo"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetCertInfo;
			return soap_in_WS1__SOF_USCOREGetCertInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_QueryCertTrustListAltNamesResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse;
			return soap_in_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_QueryCertTrustListAltNames"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames;
			return soap_in_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_DecryptDataResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse;
			return soap_in_WS1__SOF_USCOREDecryptDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_DecryptData"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREDecryptData;
			return soap_in_WS1__SOF_USCOREDecryptData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SignDataXMLResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse;
			return soap_in_WS1__SOF_USCORESignDataXMLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SignDataXML"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESignDataXML;
			return soap_in_WS1__SOF_USCORESignDataXML(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_EncryptFileResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse;
			return soap_in_WS1__SOF_USCOREEncryptFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_EncryptFile"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREEncryptFile;
			return soap_in_WS1__SOF_USCOREEncryptFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SignDataByP7Response"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response;
			return soap_in_WS1__SOF_USCORESignDataByP7Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SignDataByP7"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESignDataByP7;
			return soap_in_WS1__SOF_USCORESignDataByP7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetTimeStampInfoResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse;
			return soap_in_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetTimeStampInfo"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo;
			return soap_in_WS1__SOF_USCOREGetTimeStampInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SetSignMethodResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse;
			return soap_in_WS1__SOF_USCORESetSignMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SetSignMethod"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESetSignMethod;
			return soap_in_WS1__SOF_USCORESetSignMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_DecryptFileResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse;
			return soap_in_WS1__SOF_USCOREDecryptFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_DecryptFile"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREDecryptFile;
			return soap_in_WS1__SOF_USCOREDecryptFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:GetFileResponse"))
		{	*type = SOAP_TYPE_WS1__GetFileResponse;
			return soap_in_WS1__GetFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:GetFile"))
		{	*type = SOAP_TYPE_WS1__GetFile;
			return soap_in_WS1__GetFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:DeleteFileResponse"))
		{	*type = SOAP_TYPE_WS1__DeleteFileResponse;
			return soap_in_WS1__DeleteFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:DeleteFile"))
		{	*type = SOAP_TYPE_WS1__DeleteFile;
			return soap_in_WS1__DeleteFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_ValidateCertResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse;
			return soap_in_WS1__SOF_USCOREValidateCertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_ValidateCert"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREValidateCert;
			return soap_in_WS1__SOF_USCOREValidateCert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_CreateTimeStampResponseResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse;
			return soap_in_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_CreateTimeStampResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse;
			return soap_in_WS1__SOF_USCORECreateTimeStampResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetEncryptMethodResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse;
			return soap_in_WS1__SOF_USCOREGetEncryptMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetEncryptMethod"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod;
			return soap_in_WS1__SOF_USCOREGetEncryptMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_CreateTimeStampRequestResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse;
			return soap_in_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_CreateTimeStampRequest"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest;
			return soap_in_WS1__SOF_USCORECreateTimeStampRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SetEncryptMethodResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse;
			return soap_in_WS1__SOF_USCORESetEncryptMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SetEncryptMethod"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod;
			return soap_in_WS1__SOF_USCORESetEncryptMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetSignMethodResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse;
			return soap_in_WS1__SOF_USCOREGetSignMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetSignMethod"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetSignMethod;
			return soap_in_WS1__SOF_USCOREGetSignMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SetWebAppNameResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse;
			return soap_in_WS1__SOF_USCORESetWebAppNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SetWebAppName"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESetWebAppName;
			return soap_in_WS1__SOF_USCORESetWebAppName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GenRandomResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse;
			return soap_in_WS1__SOF_USCOREGenRandomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GenRandom"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGenRandom;
			return soap_in_WS1__SOF_USCOREGenRandom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_PriKeyDecryptResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse;
			return soap_in_WS1__SOF_USCOREPriKeyDecryptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_PriKeyDecrypt"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt;
			return soap_in_WS1__SOF_USCOREPriKeyDecrypt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:sofSecurityEngineDeal"))
		{	*type = SOAP_TYPE_WS1__sofSecurityEngineDeal;
			return soap_in_WS1__sofSecurityEngineDeal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetInstanceResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse;
			return soap_in_WS1__SOF_USCOREGetInstanceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetInstance"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetInstance;
			return soap_in_WS1__SOF_USCOREGetInstance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SignFileResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESignFileResponse;
			return soap_in_WS1__SOF_USCORESignFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SignFile"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESignFile;
			return soap_in_WS1__SOF_USCORESignFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SignDataResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESignDataResponse;
			return soap_in_WS1__SOF_USCORESignDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SignData"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESignData;
			return soap_in_WS1__SOF_USCORESignData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifySignedDataXMLResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse;
			return soap_in_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifySignedDataXML"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML;
			return soap_in_WS1__SOF_USCOREVerifySignedDataXML(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetXMLSignatureInfoResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse;
			return soap_in_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetXMLSignatureInfo"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo;
			return soap_in_WS1__SOF_USCOREGetXMLSignatureInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_DelCertTrustListResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse;
			return soap_in_WS1__SOF_USCOREDelCertTrustListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_DelCertTrustList"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList;
			return soap_in_WS1__SOF_USCOREDelCertTrustList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetCertInfoByOidResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse;
			return soap_in_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetCertInfoByOid"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid;
			return soap_in_WS1__SOF_USCOREGetCertInfoByOid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetServerCertificateResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse;
			return soap_in_WS1__SOF_USCOREGetServerCertificateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetServerCertificate"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate;
			return soap_in_WS1__SOF_USCOREGetServerCertificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifySignedFileResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse;
			return soap_in_WS1__SOF_USCOREVerifySignedFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifySignedFile"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile;
			return soap_in_WS1__SOF_USCOREVerifySignedFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_PubKeyEncryptResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse;
			return soap_in_WS1__SOF_USCOREPubKeyEncryptResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_PubKeyEncrypt"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt;
			return soap_in_WS1__SOF_USCOREPubKeyEncrypt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifyTimeStampResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse;
			return soap_in_WS1__SOF_USCOREVerifyTimeStampResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifyTimeStamp"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp;
			return soap_in_WS1__SOF_USCOREVerifyTimeStamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetP7SignDataInfoResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse;
			return soap_in_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_GetP7SignDataInfo"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo;
			return soap_in_WS1__SOF_USCOREGetP7SignDataInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SetCertTrustListResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse;
			return soap_in_WS1__SOF_USCORESetCertTrustListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_SetCertTrustList"))
		{	*type = SOAP_TYPE_WS1__SOF_USCORESetCertTrustList;
			return soap_in_WS1__SOF_USCORESetCertTrustList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifySignedDataByP7Response"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response;
			return soap_in_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifySignedDataByP7"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7;
			return soap_in_WS1__SOF_USCOREVerifySignedDataByP7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_QueryCertTrustListResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse;
			return soap_in_WS1__SOF_USCOREQueryCertTrustListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_QueryCertTrustList"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList;
			return soap_in_WS1__SOF_USCOREQueryCertTrustList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifySignedDataResponse"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse;
			return soap_in_WS1__SOF_USCOREVerifySignedDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "WS1:SOF_VerifySignedData"))
		{	*type = SOAP_TYPE_WS1__SOF_USCOREVerifySignedData;
			return soap_in_WS1__SOF_USCOREVerifySignedData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse:
		return ((WS1__SOF_USCOREEncryptDataResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_EncryptDataResponse");
	case SOAP_TYPE_WS1__SOF_USCOREEncryptData:
		return ((WS1__SOF_USCOREEncryptData *)ptr)->soap_out(soap, tag, id, "WS1:SOF_EncryptData");
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse:
		return ((WS1__SOF_USCOREGetCertInfoResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetCertInfoResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfo:
		return ((WS1__SOF_USCOREGetCertInfo *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetCertInfo");
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return ((WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_QueryCertTrustListAltNamesResponse");
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames:
		return ((WS1__SOF_USCOREQueryCertTrustListAltNames *)ptr)->soap_out(soap, tag, id, "WS1:SOF_QueryCertTrustListAltNames");
	case SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse:
		return ((WS1__SOF_USCOREDecryptDataResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_DecryptDataResponse");
	case SOAP_TYPE_WS1__SOF_USCOREDecryptData:
		return ((WS1__SOF_USCOREDecryptData *)ptr)->soap_out(soap, tag, id, "WS1:SOF_DecryptData");
	case SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse:
		return ((WS1__SOF_USCORESignDataXMLResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SignDataXMLResponse");
	case SOAP_TYPE_WS1__SOF_USCORESignDataXML:
		return ((WS1__SOF_USCORESignDataXML *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SignDataXML");
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse:
		return ((WS1__SOF_USCOREEncryptFileResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_EncryptFileResponse");
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFile:
		return ((WS1__SOF_USCOREEncryptFile *)ptr)->soap_out(soap, tag, id, "WS1:SOF_EncryptFile");
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response:
		return ((WS1__SOF_USCORESignDataByP7Response *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SignDataByP7Response");
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7:
		return ((WS1__SOF_USCORESignDataByP7 *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SignDataByP7");
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse:
		return ((WS1__SOF_USCOREGetTimeStampInfoResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetTimeStampInfoResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo:
		return ((WS1__SOF_USCOREGetTimeStampInfo *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetTimeStampInfo");
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse:
		return ((WS1__SOF_USCORESetSignMethodResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SetSignMethodResponse");
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethod:
		return ((WS1__SOF_USCORESetSignMethod *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SetSignMethod");
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse:
		return ((WS1__SOF_USCOREDecryptFileResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_DecryptFileResponse");
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFile:
		return ((WS1__SOF_USCOREDecryptFile *)ptr)->soap_out(soap, tag, id, "WS1:SOF_DecryptFile");
	case SOAP_TYPE_WS1__GetFileResponse:
		return ((WS1__GetFileResponse *)ptr)->soap_out(soap, tag, id, "WS1:GetFileResponse");
	case SOAP_TYPE_WS1__GetFile:
		return ((WS1__GetFile *)ptr)->soap_out(soap, tag, id, "WS1:GetFile");
	case SOAP_TYPE_WS1__DeleteFileResponse:
		return ((WS1__DeleteFileResponse *)ptr)->soap_out(soap, tag, id, "WS1:DeleteFileResponse");
	case SOAP_TYPE_WS1__DeleteFile:
		return ((WS1__DeleteFile *)ptr)->soap_out(soap, tag, id, "WS1:DeleteFile");
	case SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse:
		return ((WS1__SOF_USCOREValidateCertResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_ValidateCertResponse");
	case SOAP_TYPE_WS1__SOF_USCOREValidateCert:
		return ((WS1__SOF_USCOREValidateCert *)ptr)->soap_out(soap, tag, id, "WS1:SOF_ValidateCert");
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse:
		return ((WS1__SOF_USCORECreateTimeStampResponseResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_CreateTimeStampResponseResponse");
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse:
		return ((WS1__SOF_USCORECreateTimeStampResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_CreateTimeStampResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse:
		return ((WS1__SOF_USCOREGetEncryptMethodResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetEncryptMethodResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod:
		return ((WS1__SOF_USCOREGetEncryptMethod *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetEncryptMethod");
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse:
		return ((WS1__SOF_USCORECreateTimeStampRequestResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_CreateTimeStampRequestResponse");
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest:
		return ((WS1__SOF_USCORECreateTimeStampRequest *)ptr)->soap_out(soap, tag, id, "WS1:SOF_CreateTimeStampRequest");
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse:
		return ((WS1__SOF_USCORESetEncryptMethodResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SetEncryptMethodResponse");
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod:
		return ((WS1__SOF_USCORESetEncryptMethod *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SetEncryptMethod");
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse:
		return ((WS1__SOF_USCOREGetSignMethodResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetSignMethodResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethod:
		return ((WS1__SOF_USCOREGetSignMethod *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetSignMethod");
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse:
		return ((WS1__SOF_USCORESetWebAppNameResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SetWebAppNameResponse");
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppName:
		return ((WS1__SOF_USCORESetWebAppName *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SetWebAppName");
	case SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse:
		return ((WS1__SOF_USCOREGenRandomResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GenRandomResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGenRandom:
		return ((WS1__SOF_USCOREGenRandom *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GenRandom");
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse:
		return ((WS1__SOF_USCOREPriKeyDecryptResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_PriKeyDecryptResponse");
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt:
		return ((WS1__SOF_USCOREPriKeyDecrypt *)ptr)->soap_out(soap, tag, id, "WS1:SOF_PriKeyDecrypt");
	case SOAP_TYPE_WS1__sofSecurityEngineDeal:
		return ((WS1__sofSecurityEngineDeal *)ptr)->soap_out(soap, tag, id, "WS1:sofSecurityEngineDeal");
	case SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse:
		return ((WS1__SOF_USCOREGetInstanceResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetInstanceResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetInstance:
		return ((WS1__SOF_USCOREGetInstance *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetInstance");
	case SOAP_TYPE_WS1__SOF_USCORESignFileResponse:
		return ((WS1__SOF_USCORESignFileResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SignFileResponse");
	case SOAP_TYPE_WS1__SOF_USCORESignFile:
		return ((WS1__SOF_USCORESignFile *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SignFile");
	case SOAP_TYPE_WS1__SOF_USCORESignDataResponse:
		return ((WS1__SOF_USCORESignDataResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SignDataResponse");
	case SOAP_TYPE_WS1__SOF_USCORESignData:
		return ((WS1__SOF_USCORESignData *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SignData");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse:
		return ((WS1__SOF_USCOREVerifySignedDataXMLResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifySignedDataXMLResponse");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML:
		return ((WS1__SOF_USCOREVerifySignedDataXML *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifySignedDataXML");
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse:
		return ((WS1__SOF_USCOREGetXMLSignatureInfoResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetXMLSignatureInfoResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo:
		return ((WS1__SOF_USCOREGetXMLSignatureInfo *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetXMLSignatureInfo");
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse:
		return ((WS1__SOF_USCOREDelCertTrustListResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_DelCertTrustListResponse");
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList:
		return ((WS1__SOF_USCOREDelCertTrustList *)ptr)->soap_out(soap, tag, id, "WS1:SOF_DelCertTrustList");
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse:
		return ((WS1__SOF_USCOREGetCertInfoByOidResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetCertInfoByOidResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid:
		return ((WS1__SOF_USCOREGetCertInfoByOid *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetCertInfoByOid");
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse:
		return ((WS1__SOF_USCOREGetServerCertificateResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetServerCertificateResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate:
		return ((WS1__SOF_USCOREGetServerCertificate *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetServerCertificate");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse:
		return ((WS1__SOF_USCOREVerifySignedFileResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifySignedFileResponse");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile:
		return ((WS1__SOF_USCOREVerifySignedFile *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifySignedFile");
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse:
		return ((WS1__SOF_USCOREPubKeyEncryptResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_PubKeyEncryptResponse");
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt:
		return ((WS1__SOF_USCOREPubKeyEncrypt *)ptr)->soap_out(soap, tag, id, "WS1:SOF_PubKeyEncrypt");
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse:
		return ((WS1__SOF_USCOREVerifyTimeStampResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifyTimeStampResponse");
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp:
		return ((WS1__SOF_USCOREVerifyTimeStamp *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifyTimeStamp");
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse:
		return ((WS1__SOF_USCOREGetP7SignDataInfoResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetP7SignDataInfoResponse");
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo:
		return ((WS1__SOF_USCOREGetP7SignDataInfo *)ptr)->soap_out(soap, tag, id, "WS1:SOF_GetP7SignDataInfo");
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse:
		return ((WS1__SOF_USCORESetCertTrustListResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SetCertTrustListResponse");
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustList:
		return ((WS1__SOF_USCORESetCertTrustList *)ptr)->soap_out(soap, tag, id, "WS1:SOF_SetCertTrustList");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response:
		return ((WS1__SOF_USCOREVerifySignedDataByP7Response *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifySignedDataByP7Response");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7:
		return ((WS1__SOF_USCOREVerifySignedDataByP7 *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifySignedDataByP7");
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse:
		return ((WS1__SOF_USCOREQueryCertTrustListResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_QueryCertTrustListResponse");
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList:
		return ((WS1__SOF_USCOREQueryCertTrustList *)ptr)->soap_out(soap, tag, id, "WS1:SOF_QueryCertTrustList");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse:
		return ((WS1__SOF_USCOREVerifySignedDataResponse *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifySignedDataResponse");
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedData:
		return ((WS1__SOF_USCOREVerifySignedData *)ptr)->soap_out(soap, tag, id, "WS1:SOF_VerifySignedData");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptDataResponse:
		return soap_out_PointerToWS1__SOF_USCOREEncryptDataResponse(soap, tag, id, (WS1__SOF_USCOREEncryptDataResponse *const*)ptr, "WS1:SOF_EncryptDataResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptData:
		return soap_out_PointerToWS1__SOF_USCOREEncryptData(soap, tag, id, (WS1__SOF_USCOREEncryptData *const*)ptr, "WS1:SOF_EncryptData");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, id, (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*)ptr, "WS1:SOF_QueryCertTrustListAltNamesResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames:
		return soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, id, (WS1__SOF_USCOREQueryCertTrustListAltNames *const*)ptr, "WS1:SOF_QueryCertTrustListAltNames");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetCertInfoResponse(soap, tag, id, (WS1__SOF_USCOREGetCertInfoResponse *const*)ptr, "WS1:SOF_GetCertInfoResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfo:
		return soap_out_PointerToWS1__SOF_USCOREGetCertInfo(soap, tag, id, (WS1__SOF_USCOREGetCertInfo *const*)ptr, "WS1:SOF_GetCertInfo");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataXMLResponse:
		return soap_out_PointerToWS1__SOF_USCORESignDataXMLResponse(soap, tag, id, (WS1__SOF_USCORESignDataXMLResponse *const*)ptr, "WS1:SOF_SignDataXMLResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataXML:
		return soap_out_PointerToWS1__SOF_USCORESignDataXML(soap, tag, id, (WS1__SOF_USCORESignDataXML *const*)ptr, "WS1:SOF_SignDataXML");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptDataResponse:
		return soap_out_PointerToWS1__SOF_USCOREDecryptDataResponse(soap, tag, id, (WS1__SOF_USCOREDecryptDataResponse *const*)ptr, "WS1:SOF_DecryptDataResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptData:
		return soap_out_PointerToWS1__SOF_USCOREDecryptData(soap, tag, id, (WS1__SOF_USCOREDecryptData *const*)ptr, "WS1:SOF_DecryptData");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataByP7Response:
		return soap_out_PointerToWS1__SOF_USCORESignDataByP7Response(soap, tag, id, (WS1__SOF_USCORESignDataByP7Response *const*)ptr, "WS1:SOF_SignDataByP7Response");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataByP7:
		return soap_out_PointerToWS1__SOF_USCORESignDataByP7(soap, tag, id, (WS1__SOF_USCORESignDataByP7 *const*)ptr, "WS1:SOF_SignDataByP7");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptFileResponse:
		return soap_out_PointerToWS1__SOF_USCOREEncryptFileResponse(soap, tag, id, (WS1__SOF_USCOREEncryptFileResponse *const*)ptr, "WS1:SOF_EncryptFileResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptFile:
		return soap_out_PointerToWS1__SOF_USCOREEncryptFile(soap, tag, id, (WS1__SOF_USCOREEncryptFile *const*)ptr, "WS1:SOF_EncryptFile");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, id, (WS1__SOF_USCOREGetTimeStampInfoResponse *const*)ptr, "WS1:SOF_GetTimeStampInfoResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetTimeStampInfo:
		return soap_out_PointerToWS1__SOF_USCOREGetTimeStampInfo(soap, tag, id, (WS1__SOF_USCOREGetTimeStampInfo *const*)ptr, "WS1:SOF_GetTimeStampInfo");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetSignMethodResponse:
		return soap_out_PointerToWS1__SOF_USCORESetSignMethodResponse(soap, tag, id, (WS1__SOF_USCORESetSignMethodResponse *const*)ptr, "WS1:SOF_SetSignMethodResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetSignMethod:
		return soap_out_PointerToWS1__SOF_USCORESetSignMethod(soap, tag, id, (WS1__SOF_USCORESetSignMethod *const*)ptr, "WS1:SOF_SetSignMethod");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptFileResponse:
		return soap_out_PointerToWS1__SOF_USCOREDecryptFileResponse(soap, tag, id, (WS1__SOF_USCOREDecryptFileResponse *const*)ptr, "WS1:SOF_DecryptFileResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptFile:
		return soap_out_PointerToWS1__SOF_USCOREDecryptFile(soap, tag, id, (WS1__SOF_USCOREDecryptFile *const*)ptr, "WS1:SOF_DecryptFile");
	case SOAP_TYPE_PointerToWS1__GetFileResponse:
		return soap_out_PointerToWS1__GetFileResponse(soap, tag, id, (WS1__GetFileResponse *const*)ptr, "WS1:GetFileResponse");
	case SOAP_TYPE_PointerToWS1__GetFile:
		return soap_out_PointerToWS1__GetFile(soap, tag, id, (WS1__GetFile *const*)ptr, "WS1:GetFile");
	case SOAP_TYPE_PointerToWS1__DeleteFileResponse:
		return soap_out_PointerToWS1__DeleteFileResponse(soap, tag, id, (WS1__DeleteFileResponse *const*)ptr, "WS1:DeleteFileResponse");
	case SOAP_TYPE_PointerToWS1__DeleteFile:
		return soap_out_PointerToWS1__DeleteFile(soap, tag, id, (WS1__DeleteFile *const*)ptr, "WS1:DeleteFile");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREValidateCertResponse:
		return soap_out_PointerToWS1__SOF_USCOREValidateCertResponse(soap, tag, id, (WS1__SOF_USCOREValidateCertResponse *const*)ptr, "WS1:SOF_ValidateCertResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREValidateCert:
		return soap_out_PointerToWS1__SOF_USCOREValidateCert(soap, tag, id, (WS1__SOF_USCOREValidateCert *const*)ptr, "WS1:SOF_ValidateCert");
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse:
		return soap_out_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, id, (WS1__SOF_USCORECreateTimeStampResponseResponse *const*)ptr, "WS1:SOF_CreateTimeStampResponseResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampResponse:
		return soap_out_PointerToWS1__SOF_USCORECreateTimeStampResponse(soap, tag, id, (WS1__SOF_USCORECreateTimeStampResponse *const*)ptr, "WS1:SOF_CreateTimeStampResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetEncryptMethodResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(soap, tag, id, (WS1__SOF_USCOREGetEncryptMethodResponse *const*)ptr, "WS1:SOF_GetEncryptMethodResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetEncryptMethod:
		return soap_out_PointerToWS1__SOF_USCOREGetEncryptMethod(soap, tag, id, (WS1__SOF_USCOREGetEncryptMethod *const*)ptr, "WS1:SOF_GetEncryptMethod");
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse:
		return soap_out_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, id, (WS1__SOF_USCORECreateTimeStampRequestResponse *const*)ptr, "WS1:SOF_CreateTimeStampRequestResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampRequest:
		return soap_out_PointerToWS1__SOF_USCORECreateTimeStampRequest(soap, tag, id, (WS1__SOF_USCORECreateTimeStampRequest *const*)ptr, "WS1:SOF_CreateTimeStampRequest");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetEncryptMethodResponse:
		return soap_out_PointerToWS1__SOF_USCORESetEncryptMethodResponse(soap, tag, id, (WS1__SOF_USCORESetEncryptMethodResponse *const*)ptr, "WS1:SOF_SetEncryptMethodResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetEncryptMethod:
		return soap_out_PointerToWS1__SOF_USCORESetEncryptMethod(soap, tag, id, (WS1__SOF_USCORESetEncryptMethod *const*)ptr, "WS1:SOF_SetEncryptMethod");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetWebAppNameResponse:
		return soap_out_PointerToWS1__SOF_USCORESetWebAppNameResponse(soap, tag, id, (WS1__SOF_USCORESetWebAppNameResponse *const*)ptr, "WS1:SOF_SetWebAppNameResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetWebAppName:
		return soap_out_PointerToWS1__SOF_USCORESetWebAppName(soap, tag, id, (WS1__SOF_USCORESetWebAppName *const*)ptr, "WS1:SOF_SetWebAppName");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetSignMethodResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetSignMethodResponse(soap, tag, id, (WS1__SOF_USCOREGetSignMethodResponse *const*)ptr, "WS1:SOF_GetSignMethodResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetSignMethod:
		return soap_out_PointerToWS1__SOF_USCOREGetSignMethod(soap, tag, id, (WS1__SOF_USCOREGetSignMethod *const*)ptr, "WS1:SOF_GetSignMethod");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGenRandomResponse:
		return soap_out_PointerToWS1__SOF_USCOREGenRandomResponse(soap, tag, id, (WS1__SOF_USCOREGenRandomResponse *const*)ptr, "WS1:SOF_GenRandomResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGenRandom:
		return soap_out_PointerToWS1__SOF_USCOREGenRandom(soap, tag, id, (WS1__SOF_USCOREGenRandom *const*)ptr, "WS1:SOF_GenRandom");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPriKeyDecryptResponse:
		return soap_out_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(soap, tag, id, (WS1__SOF_USCOREPriKeyDecryptResponse *const*)ptr, "WS1:SOF_PriKeyDecryptResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPriKeyDecrypt:
		return soap_out_PointerToWS1__SOF_USCOREPriKeyDecrypt(soap, tag, id, (WS1__SOF_USCOREPriKeyDecrypt *const*)ptr, "WS1:SOF_PriKeyDecrypt");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetInstanceResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetInstanceResponse(soap, tag, id, (WS1__SOF_USCOREGetInstanceResponse *const*)ptr, "WS1:SOF_GetInstanceResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetInstance:
		return soap_out_PointerToWS1__SOF_USCOREGetInstance(soap, tag, id, (WS1__SOF_USCOREGetInstance *const*)ptr, "WS1:SOF_GetInstance");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignFileResponse:
		return soap_out_PointerToWS1__SOF_USCORESignFileResponse(soap, tag, id, (WS1__SOF_USCORESignFileResponse *const*)ptr, "WS1:SOF_SignFileResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignFile:
		return soap_out_PointerToWS1__SOF_USCORESignFile(soap, tag, id, (WS1__SOF_USCORESignFile *const*)ptr, "WS1:SOF_SignFile");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse:
		return soap_out_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, id, (WS1__SOF_USCOREVerifySignedDataXMLResponse *const*)ptr, "WS1:SOF_VerifySignedDataXMLResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataXML:
		return soap_out_PointerToWS1__SOF_USCOREVerifySignedDataXML(soap, tag, id, (WS1__SOF_USCOREVerifySignedDataXML *const*)ptr, "WS1:SOF_VerifySignedDataXML");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataResponse:
		return soap_out_PointerToWS1__SOF_USCORESignDataResponse(soap, tag, id, (WS1__SOF_USCORESignDataResponse *const*)ptr, "WS1:SOF_SignDataResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignData:
		return soap_out_PointerToWS1__SOF_USCORESignData(soap, tag, id, (WS1__SOF_USCORESignData *const*)ptr, "WS1:SOF_SignData");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, id, (WS1__SOF_USCOREGetXMLSignatureInfoResponse *const*)ptr, "WS1:SOF_GetXMLSignatureInfoResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetXMLSignatureInfo:
		return soap_out_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(soap, tag, id, (WS1__SOF_USCOREGetXMLSignatureInfo *const*)ptr, "WS1:SOF_GetXMLSignatureInfo");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDelCertTrustListResponse:
		return soap_out_PointerToWS1__SOF_USCOREDelCertTrustListResponse(soap, tag, id, (WS1__SOF_USCOREDelCertTrustListResponse *const*)ptr, "WS1:SOF_DelCertTrustListResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDelCertTrustList:
		return soap_out_PointerToWS1__SOF_USCOREDelCertTrustList(soap, tag, id, (WS1__SOF_USCOREDelCertTrustList *const*)ptr, "WS1:SOF_DelCertTrustList");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetServerCertificateResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetServerCertificateResponse(soap, tag, id, (WS1__SOF_USCOREGetServerCertificateResponse *const*)ptr, "WS1:SOF_GetServerCertificateResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetServerCertificate:
		return soap_out_PointerToWS1__SOF_USCOREGetServerCertificate(soap, tag, id, (WS1__SOF_USCOREGetServerCertificate *const*)ptr, "WS1:SOF_GetServerCertificate");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, id, (WS1__SOF_USCOREGetCertInfoByOidResponse *const*)ptr, "WS1:SOF_GetCertInfoByOidResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoByOid:
		return soap_out_PointerToWS1__SOF_USCOREGetCertInfoByOid(soap, tag, id, (WS1__SOF_USCOREGetCertInfoByOid *const*)ptr, "WS1:SOF_GetCertInfoByOid");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedFileResponse:
		return soap_out_PointerToWS1__SOF_USCOREVerifySignedFileResponse(soap, tag, id, (WS1__SOF_USCOREVerifySignedFileResponse *const*)ptr, "WS1:SOF_VerifySignedFileResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedFile:
		return soap_out_PointerToWS1__SOF_USCOREVerifySignedFile(soap, tag, id, (WS1__SOF_USCOREVerifySignedFile *const*)ptr, "WS1:SOF_VerifySignedFile");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifyTimeStampResponse:
		return soap_out_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(soap, tag, id, (WS1__SOF_USCOREVerifyTimeStampResponse *const*)ptr, "WS1:SOF_VerifyTimeStampResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifyTimeStamp:
		return soap_out_PointerToWS1__SOF_USCOREVerifyTimeStamp(soap, tag, id, (WS1__SOF_USCOREVerifyTimeStamp *const*)ptr, "WS1:SOF_VerifyTimeStamp");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPubKeyEncryptResponse:
		return soap_out_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(soap, tag, id, (WS1__SOF_USCOREPubKeyEncryptResponse *const*)ptr, "WS1:SOF_PubKeyEncryptResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPubKeyEncrypt:
		return soap_out_PointerToWS1__SOF_USCOREPubKeyEncrypt(soap, tag, id, (WS1__SOF_USCOREPubKeyEncrypt *const*)ptr, "WS1:SOF_PubKeyEncrypt");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response:
		return soap_out_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, id, (WS1__SOF_USCOREVerifySignedDataByP7Response *const*)ptr, "WS1:SOF_VerifySignedDataByP7Response");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataByP7:
		return soap_out_PointerToWS1__SOF_USCOREVerifySignedDataByP7(soap, tag, id, (WS1__SOF_USCOREVerifySignedDataByP7 *const*)ptr, "WS1:SOF_VerifySignedDataByP7");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetCertTrustListResponse:
		return soap_out_PointerToWS1__SOF_USCORESetCertTrustListResponse(soap, tag, id, (WS1__SOF_USCORESetCertTrustListResponse *const*)ptr, "WS1:SOF_SetCertTrustListResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetCertTrustList:
		return soap_out_PointerToWS1__SOF_USCORESetCertTrustList(soap, tag, id, (WS1__SOF_USCORESetCertTrustList *const*)ptr, "WS1:SOF_SetCertTrustList");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse:
		return soap_out_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, id, (WS1__SOF_USCOREGetP7SignDataInfoResponse *const*)ptr, "WS1:SOF_GetP7SignDataInfoResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetP7SignDataInfo:
		return soap_out_PointerToWS1__SOF_USCOREGetP7SignDataInfo(soap, tag, id, (WS1__SOF_USCOREGetP7SignDataInfo *const*)ptr, "WS1:SOF_GetP7SignDataInfo");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListResponse:
		return soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(soap, tag, id, (WS1__SOF_USCOREQueryCertTrustListResponse *const*)ptr, "WS1:SOF_QueryCertTrustListResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustList:
		return soap_out_PointerToWS1__SOF_USCOREQueryCertTrustList(soap, tag, id, (WS1__SOF_USCOREQueryCertTrustList *const*)ptr, "WS1:SOF_QueryCertTrustList");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataResponse:
		return soap_out_PointerToWS1__SOF_USCOREVerifySignedDataResponse(soap, tag, id, (WS1__SOF_USCOREVerifySignedDataResponse *const*)ptr, "WS1:SOF_VerifySignedDataResponse");
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedData:
		return soap_out_PointerToWS1__SOF_USCOREVerifySignedData(soap, tag, id, (WS1__SOF_USCOREVerifySignedData *const*)ptr, "WS1:SOF_VerifySignedData");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerToWS1__sofSecurityEngineDeal:
		return soap_out_PointerToWS1__sofSecurityEngineDeal(soap, tag, id, (WS1__sofSecurityEngineDeal *const*)ptr, "WS1:sofSecurityEngineDeal");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse:
		((WS1__SOF_USCOREEncryptDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREEncryptData:
		((WS1__SOF_USCOREEncryptData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse:
		((WS1__SOF_USCOREGetCertInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfo:
		((WS1__SOF_USCOREGetCertInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		((WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames:
		((WS1__SOF_USCOREQueryCertTrustListAltNames *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse:
		((WS1__SOF_USCOREDecryptDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDecryptData:
		((WS1__SOF_USCOREDecryptData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse:
		((WS1__SOF_USCORESignDataXMLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataXML:
		((WS1__SOF_USCORESignDataXML *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse:
		((WS1__SOF_USCOREEncryptFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFile:
		((WS1__SOF_USCOREEncryptFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response:
		((WS1__SOF_USCORESignDataByP7Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7:
		((WS1__SOF_USCORESignDataByP7 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse:
		((WS1__SOF_USCOREGetTimeStampInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo:
		((WS1__SOF_USCOREGetTimeStampInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse:
		((WS1__SOF_USCORESetSignMethodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethod:
		((WS1__SOF_USCORESetSignMethod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse:
		((WS1__SOF_USCOREDecryptFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFile:
		((WS1__SOF_USCOREDecryptFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__GetFileResponse:
		((WS1__GetFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__GetFile:
		((WS1__GetFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__DeleteFileResponse:
		((WS1__DeleteFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__DeleteFile:
		((WS1__DeleteFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse:
		((WS1__SOF_USCOREValidateCertResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREValidateCert:
		((WS1__SOF_USCOREValidateCert *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse:
		((WS1__SOF_USCORECreateTimeStampResponseResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse:
		((WS1__SOF_USCORECreateTimeStampResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse:
		((WS1__SOF_USCOREGetEncryptMethodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod:
		((WS1__SOF_USCOREGetEncryptMethod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse:
		((WS1__SOF_USCORECreateTimeStampRequestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest:
		((WS1__SOF_USCORECreateTimeStampRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse:
		((WS1__SOF_USCORESetEncryptMethodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod:
		((WS1__SOF_USCORESetEncryptMethod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse:
		((WS1__SOF_USCOREGetSignMethodResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethod:
		((WS1__SOF_USCOREGetSignMethod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse:
		((WS1__SOF_USCORESetWebAppNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppName:
		((WS1__SOF_USCORESetWebAppName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse:
		((WS1__SOF_USCOREGenRandomResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGenRandom:
		((WS1__SOF_USCOREGenRandom *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse:
		((WS1__SOF_USCOREPriKeyDecryptResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt:
		((WS1__SOF_USCOREPriKeyDecrypt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__sofSecurityEngineDeal:
		((WS1__sofSecurityEngineDeal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse:
		((WS1__SOF_USCOREGetInstanceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetInstance:
		((WS1__SOF_USCOREGetInstance *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignFileResponse:
		((WS1__SOF_USCORESignFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignFile:
		((WS1__SOF_USCORESignFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataResponse:
		((WS1__SOF_USCORESignDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignData:
		((WS1__SOF_USCORESignData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse:
		((WS1__SOF_USCOREVerifySignedDataXMLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML:
		((WS1__SOF_USCOREVerifySignedDataXML *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse:
		((WS1__SOF_USCOREGetXMLSignatureInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo:
		((WS1__SOF_USCOREGetXMLSignatureInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse:
		((WS1__SOF_USCOREDelCertTrustListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList:
		((WS1__SOF_USCOREDelCertTrustList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse:
		((WS1__SOF_USCOREGetCertInfoByOidResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid:
		((WS1__SOF_USCOREGetCertInfoByOid *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse:
		((WS1__SOF_USCOREGetServerCertificateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate:
		((WS1__SOF_USCOREGetServerCertificate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse:
		((WS1__SOF_USCOREVerifySignedFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile:
		((WS1__SOF_USCOREVerifySignedFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse:
		((WS1__SOF_USCOREPubKeyEncryptResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt:
		((WS1__SOF_USCOREPubKeyEncrypt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse:
		((WS1__SOF_USCOREVerifyTimeStampResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp:
		((WS1__SOF_USCOREVerifyTimeStamp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse:
		((WS1__SOF_USCOREGetP7SignDataInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo:
		((WS1__SOF_USCOREGetP7SignDataInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse:
		((WS1__SOF_USCORESetCertTrustListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustList:
		((WS1__SOF_USCORESetCertTrustList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response:
		((WS1__SOF_USCOREVerifySignedDataByP7Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7:
		((WS1__SOF_USCOREVerifySignedDataByP7 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse:
		((WS1__SOF_USCOREQueryCertTrustListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList:
		((WS1__SOF_USCOREQueryCertTrustList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse:
		((WS1__SOF_USCOREVerifySignedDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedData:
		((WS1__SOF_USCOREVerifySignedData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREEncryptData:
		soap_serialize___WS1__SOF_USCOREEncryptData(soap, (const struct __WS1__SOF_USCOREEncryptData *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustListAltNames:
		soap_serialize___WS1__SOF_USCOREQueryCertTrustListAltNames(soap, (const struct __WS1__SOF_USCOREQueryCertTrustListAltNames *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetCertInfo:
		soap_serialize___WS1__SOF_USCOREGetCertInfo(soap, (const struct __WS1__SOF_USCOREGetCertInfo *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORESignDataXML:
		soap_serialize___WS1__SOF_USCORESignDataXML(soap, (const struct __WS1__SOF_USCORESignDataXML *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREDecryptData:
		soap_serialize___WS1__SOF_USCOREDecryptData(soap, (const struct __WS1__SOF_USCOREDecryptData *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORESignDataByP7:
		soap_serialize___WS1__SOF_USCORESignDataByP7(soap, (const struct __WS1__SOF_USCORESignDataByP7 *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREEncryptFile:
		soap_serialize___WS1__SOF_USCOREEncryptFile(soap, (const struct __WS1__SOF_USCOREEncryptFile *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetTimeStampInfo:
		soap_serialize___WS1__SOF_USCOREGetTimeStampInfo(soap, (const struct __WS1__SOF_USCOREGetTimeStampInfo *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORESetSignMethod:
		soap_serialize___WS1__SOF_USCORESetSignMethod(soap, (const struct __WS1__SOF_USCORESetSignMethod *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREDecryptFile:
		soap_serialize___WS1__SOF_USCOREDecryptFile(soap, (const struct __WS1__SOF_USCOREDecryptFile *)ptr);
		break;
	case SOAP_TYPE___WS1__GetFile:
		soap_serialize___WS1__GetFile(soap, (const struct __WS1__GetFile *)ptr);
		break;
	case SOAP_TYPE___WS1__DeleteFile:
		soap_serialize___WS1__DeleteFile(soap, (const struct __WS1__DeleteFile *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREValidateCert:
		soap_serialize___WS1__SOF_USCOREValidateCert(soap, (const struct __WS1__SOF_USCOREValidateCert *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORECreateTimeStampResponse:
		soap_serialize___WS1__SOF_USCORECreateTimeStampResponse(soap, (const struct __WS1__SOF_USCORECreateTimeStampResponse *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetEncryptMethod:
		soap_serialize___WS1__SOF_USCOREGetEncryptMethod(soap, (const struct __WS1__SOF_USCOREGetEncryptMethod *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORECreateTimeStampRequest:
		soap_serialize___WS1__SOF_USCORECreateTimeStampRequest(soap, (const struct __WS1__SOF_USCORECreateTimeStampRequest *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORESetEncryptMethod:
		soap_serialize___WS1__SOF_USCORESetEncryptMethod(soap, (const struct __WS1__SOF_USCORESetEncryptMethod *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORESetWebAppName:
		soap_serialize___WS1__SOF_USCORESetWebAppName(soap, (const struct __WS1__SOF_USCORESetWebAppName *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetSignMethod:
		soap_serialize___WS1__SOF_USCOREGetSignMethod(soap, (const struct __WS1__SOF_USCOREGetSignMethod *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGenRandom:
		soap_serialize___WS1__SOF_USCOREGenRandom(soap, (const struct __WS1__SOF_USCOREGenRandom *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREPriKeyDecrypt:
		soap_serialize___WS1__SOF_USCOREPriKeyDecrypt(soap, (const struct __WS1__SOF_USCOREPriKeyDecrypt *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetInstance:
		soap_serialize___WS1__SOF_USCOREGetInstance(soap, (const struct __WS1__SOF_USCOREGetInstance *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORESignFile:
		soap_serialize___WS1__SOF_USCORESignFile(soap, (const struct __WS1__SOF_USCORESignFile *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataXML:
		soap_serialize___WS1__SOF_USCOREVerifySignedDataXML(soap, (const struct __WS1__SOF_USCOREVerifySignedDataXML *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORESignData:
		soap_serialize___WS1__SOF_USCORESignData(soap, (const struct __WS1__SOF_USCORESignData *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetXMLSignatureInfo:
		soap_serialize___WS1__SOF_USCOREGetXMLSignatureInfo(soap, (const struct __WS1__SOF_USCOREGetXMLSignatureInfo *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREDelCertTrustList:
		soap_serialize___WS1__SOF_USCOREDelCertTrustList(soap, (const struct __WS1__SOF_USCOREDelCertTrustList *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetServerCertificate:
		soap_serialize___WS1__SOF_USCOREGetServerCertificate(soap, (const struct __WS1__SOF_USCOREGetServerCertificate *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetCertInfoByOid:
		soap_serialize___WS1__SOF_USCOREGetCertInfoByOid(soap, (const struct __WS1__SOF_USCOREGetCertInfoByOid *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedFile:
		soap_serialize___WS1__SOF_USCOREVerifySignedFile(soap, (const struct __WS1__SOF_USCOREVerifySignedFile *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifyTimeStamp:
		soap_serialize___WS1__SOF_USCOREVerifyTimeStamp(soap, (const struct __WS1__SOF_USCOREVerifyTimeStamp *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREPubKeyEncrypt:
		soap_serialize___WS1__SOF_USCOREPubKeyEncrypt(soap, (const struct __WS1__SOF_USCOREPubKeyEncrypt *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataByP7:
		soap_serialize___WS1__SOF_USCOREVerifySignedDataByP7(soap, (const struct __WS1__SOF_USCOREVerifySignedDataByP7 *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCORESetCertTrustList:
		soap_serialize___WS1__SOF_USCORESetCertTrustList(soap, (const struct __WS1__SOF_USCORESetCertTrustList *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetP7SignDataInfo:
		soap_serialize___WS1__SOF_USCOREGetP7SignDataInfo(soap, (const struct __WS1__SOF_USCOREGetP7SignDataInfo *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustList:
		soap_serialize___WS1__SOF_USCOREQueryCertTrustList(soap, (const struct __WS1__SOF_USCOREQueryCertTrustList *)ptr);
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedData:
		soap_serialize___WS1__SOF_USCOREVerifySignedData(soap, (const struct __WS1__SOF_USCOREVerifySignedData *)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptDataResponse:
		soap_serialize_PointerToWS1__SOF_USCOREEncryptDataResponse(soap, (WS1__SOF_USCOREEncryptDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptData:
		soap_serialize_PointerToWS1__SOF_USCOREEncryptData(soap, (WS1__SOF_USCOREEncryptData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames:
		soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(soap, (WS1__SOF_USCOREQueryCertTrustListAltNames *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetCertInfoResponse(soap, (WS1__SOF_USCOREGetCertInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfo:
		soap_serialize_PointerToWS1__SOF_USCOREGetCertInfo(soap, (WS1__SOF_USCOREGetCertInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataXMLResponse:
		soap_serialize_PointerToWS1__SOF_USCORESignDataXMLResponse(soap, (WS1__SOF_USCORESignDataXMLResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataXML:
		soap_serialize_PointerToWS1__SOF_USCORESignDataXML(soap, (WS1__SOF_USCORESignDataXML *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptDataResponse:
		soap_serialize_PointerToWS1__SOF_USCOREDecryptDataResponse(soap, (WS1__SOF_USCOREDecryptDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptData:
		soap_serialize_PointerToWS1__SOF_USCOREDecryptData(soap, (WS1__SOF_USCOREDecryptData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataByP7Response:
		soap_serialize_PointerToWS1__SOF_USCORESignDataByP7Response(soap, (WS1__SOF_USCORESignDataByP7Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataByP7:
		soap_serialize_PointerToWS1__SOF_USCORESignDataByP7(soap, (WS1__SOF_USCORESignDataByP7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptFileResponse:
		soap_serialize_PointerToWS1__SOF_USCOREEncryptFileResponse(soap, (WS1__SOF_USCOREEncryptFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptFile:
		soap_serialize_PointerToWS1__SOF_USCOREEncryptFile(soap, (WS1__SOF_USCOREEncryptFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(soap, (WS1__SOF_USCOREGetTimeStampInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetTimeStampInfo:
		soap_serialize_PointerToWS1__SOF_USCOREGetTimeStampInfo(soap, (WS1__SOF_USCOREGetTimeStampInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetSignMethodResponse:
		soap_serialize_PointerToWS1__SOF_USCORESetSignMethodResponse(soap, (WS1__SOF_USCORESetSignMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetSignMethod:
		soap_serialize_PointerToWS1__SOF_USCORESetSignMethod(soap, (WS1__SOF_USCORESetSignMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptFileResponse:
		soap_serialize_PointerToWS1__SOF_USCOREDecryptFileResponse(soap, (WS1__SOF_USCOREDecryptFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptFile:
		soap_serialize_PointerToWS1__SOF_USCOREDecryptFile(soap, (WS1__SOF_USCOREDecryptFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__GetFileResponse:
		soap_serialize_PointerToWS1__GetFileResponse(soap, (WS1__GetFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__GetFile:
		soap_serialize_PointerToWS1__GetFile(soap, (WS1__GetFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__DeleteFileResponse:
		soap_serialize_PointerToWS1__DeleteFileResponse(soap, (WS1__DeleteFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__DeleteFile:
		soap_serialize_PointerToWS1__DeleteFile(soap, (WS1__DeleteFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREValidateCertResponse:
		soap_serialize_PointerToWS1__SOF_USCOREValidateCertResponse(soap, (WS1__SOF_USCOREValidateCertResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREValidateCert:
		soap_serialize_PointerToWS1__SOF_USCOREValidateCert(soap, (WS1__SOF_USCOREValidateCert *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse:
		soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(soap, (WS1__SOF_USCORECreateTimeStampResponseResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampResponse:
		soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampResponse(soap, (WS1__SOF_USCORECreateTimeStampResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetEncryptMethodResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(soap, (WS1__SOF_USCOREGetEncryptMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetEncryptMethod:
		soap_serialize_PointerToWS1__SOF_USCOREGetEncryptMethod(soap, (WS1__SOF_USCOREGetEncryptMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse:
		soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(soap, (WS1__SOF_USCORECreateTimeStampRequestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampRequest:
		soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampRequest(soap, (WS1__SOF_USCORECreateTimeStampRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetEncryptMethodResponse:
		soap_serialize_PointerToWS1__SOF_USCORESetEncryptMethodResponse(soap, (WS1__SOF_USCORESetEncryptMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetEncryptMethod:
		soap_serialize_PointerToWS1__SOF_USCORESetEncryptMethod(soap, (WS1__SOF_USCORESetEncryptMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetWebAppNameResponse:
		soap_serialize_PointerToWS1__SOF_USCORESetWebAppNameResponse(soap, (WS1__SOF_USCORESetWebAppNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetWebAppName:
		soap_serialize_PointerToWS1__SOF_USCORESetWebAppName(soap, (WS1__SOF_USCORESetWebAppName *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetSignMethodResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetSignMethodResponse(soap, (WS1__SOF_USCOREGetSignMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetSignMethod:
		soap_serialize_PointerToWS1__SOF_USCOREGetSignMethod(soap, (WS1__SOF_USCOREGetSignMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGenRandomResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGenRandomResponse(soap, (WS1__SOF_USCOREGenRandomResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGenRandom:
		soap_serialize_PointerToWS1__SOF_USCOREGenRandom(soap, (WS1__SOF_USCOREGenRandom *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPriKeyDecryptResponse:
		soap_serialize_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(soap, (WS1__SOF_USCOREPriKeyDecryptResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPriKeyDecrypt:
		soap_serialize_PointerToWS1__SOF_USCOREPriKeyDecrypt(soap, (WS1__SOF_USCOREPriKeyDecrypt *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetInstanceResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetInstanceResponse(soap, (WS1__SOF_USCOREGetInstanceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetInstance:
		soap_serialize_PointerToWS1__SOF_USCOREGetInstance(soap, (WS1__SOF_USCOREGetInstance *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignFileResponse:
		soap_serialize_PointerToWS1__SOF_USCORESignFileResponse(soap, (WS1__SOF_USCORESignFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignFile:
		soap_serialize_PointerToWS1__SOF_USCORESignFile(soap, (WS1__SOF_USCORESignFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse:
		soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(soap, (WS1__SOF_USCOREVerifySignedDataXMLResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataXML:
		soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataXML(soap, (WS1__SOF_USCOREVerifySignedDataXML *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignDataResponse:
		soap_serialize_PointerToWS1__SOF_USCORESignDataResponse(soap, (WS1__SOF_USCORESignDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESignData:
		soap_serialize_PointerToWS1__SOF_USCORESignData(soap, (WS1__SOF_USCORESignData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, (WS1__SOF_USCOREGetXMLSignatureInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetXMLSignatureInfo:
		soap_serialize_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(soap, (WS1__SOF_USCOREGetXMLSignatureInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDelCertTrustListResponse:
		soap_serialize_PointerToWS1__SOF_USCOREDelCertTrustListResponse(soap, (WS1__SOF_USCOREDelCertTrustListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREDelCertTrustList:
		soap_serialize_PointerToWS1__SOF_USCOREDelCertTrustList(soap, (WS1__SOF_USCOREDelCertTrustList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetServerCertificateResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetServerCertificateResponse(soap, (WS1__SOF_USCOREGetServerCertificateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetServerCertificate:
		soap_serialize_PointerToWS1__SOF_USCOREGetServerCertificate(soap, (WS1__SOF_USCOREGetServerCertificate *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(soap, (WS1__SOF_USCOREGetCertInfoByOidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoByOid:
		soap_serialize_PointerToWS1__SOF_USCOREGetCertInfoByOid(soap, (WS1__SOF_USCOREGetCertInfoByOid *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedFileResponse:
		soap_serialize_PointerToWS1__SOF_USCOREVerifySignedFileResponse(soap, (WS1__SOF_USCOREVerifySignedFileResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedFile:
		soap_serialize_PointerToWS1__SOF_USCOREVerifySignedFile(soap, (WS1__SOF_USCOREVerifySignedFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifyTimeStampResponse:
		soap_serialize_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(soap, (WS1__SOF_USCOREVerifyTimeStampResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifyTimeStamp:
		soap_serialize_PointerToWS1__SOF_USCOREVerifyTimeStamp(soap, (WS1__SOF_USCOREVerifyTimeStamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPubKeyEncryptResponse:
		soap_serialize_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(soap, (WS1__SOF_USCOREPubKeyEncryptResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREPubKeyEncrypt:
		soap_serialize_PointerToWS1__SOF_USCOREPubKeyEncrypt(soap, (WS1__SOF_USCOREPubKeyEncrypt *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response:
		soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(soap, (WS1__SOF_USCOREVerifySignedDataByP7Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataByP7:
		soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataByP7(soap, (WS1__SOF_USCOREVerifySignedDataByP7 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetCertTrustListResponse:
		soap_serialize_PointerToWS1__SOF_USCORESetCertTrustListResponse(soap, (WS1__SOF_USCORESetCertTrustListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCORESetCertTrustList:
		soap_serialize_PointerToWS1__SOF_USCORESetCertTrustList(soap, (WS1__SOF_USCORESetCertTrustList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse:
		soap_serialize_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(soap, (WS1__SOF_USCOREGetP7SignDataInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREGetP7SignDataInfo:
		soap_serialize_PointerToWS1__SOF_USCOREGetP7SignDataInfo(soap, (WS1__SOF_USCOREGetP7SignDataInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListResponse:
		soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(soap, (WS1__SOF_USCOREQueryCertTrustListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustList:
		soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustList(soap, (WS1__SOF_USCOREQueryCertTrustList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataResponse:
		soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataResponse(soap, (WS1__SOF_USCOREVerifySignedDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedData:
		soap_serialize_PointerToWS1__SOF_USCOREVerifySignedData(soap, (WS1__SOF_USCOREVerifySignedData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToWS1__sofSecurityEngineDeal:
		soap_serialize_PointerToWS1__sofSecurityEngineDeal(soap, (WS1__sofSecurityEngineDeal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__wstring:
		soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedData:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifySignedData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifySignedDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList:
		return (void*)soap_instantiate_WS1__SOF_USCOREQueryCertTrustList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREQueryCertTrustListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustList:
		return (void*)soap_instantiate_WS1__SOF_USCORESetCertTrustList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORESetCertTrustListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifyTimeStamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifyTimeStampResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt:
		return (void*)soap_instantiate_WS1__SOF_USCOREPubKeyEncrypt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREPubKeyEncryptResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifySignedFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifySignedFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetServerCertificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetServerCertificateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetCertInfoByOid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList:
		return (void*)soap_instantiate_WS1__SOF_USCOREDelCertTrustList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREDelCertTrustListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifySignedDataXML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESignData:
		return (void*)soap_instantiate_WS1__SOF_USCORESignData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESignDataResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORESignDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESignFile:
		return (void*)soap_instantiate_WS1__SOF_USCORESignFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESignFileResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORESignFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetInstance:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetInstance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetInstanceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__sofSecurityEngineDeal:
		return (void*)soap_instantiate_WS1__sofSecurityEngineDeal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt:
		return (void*)soap_instantiate_WS1__SOF_USCOREPriKeyDecrypt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREPriKeyDecryptResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGenRandom:
		return (void*)soap_instantiate_WS1__SOF_USCOREGenRandom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGenRandomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppName:
		return (void*)soap_instantiate_WS1__SOF_USCORESetWebAppName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORESetWebAppNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethod:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetSignMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetSignMethodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod:
		return (void*)soap_instantiate_WS1__SOF_USCORESetEncryptMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORESetEncryptMethodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest:
		return (void*)soap_instantiate_WS1__SOF_USCORECreateTimeStampRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetEncryptMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetEncryptMethodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORECreateTimeStampResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREValidateCert:
		return (void*)soap_instantiate_WS1__SOF_USCOREValidateCert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREValidateCertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__DeleteFile:
		return (void*)soap_instantiate_WS1__DeleteFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__DeleteFileResponse:
		return (void*)soap_instantiate_WS1__DeleteFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__GetFile:
		return (void*)soap_instantiate_WS1__GetFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__GetFileResponse:
		return (void*)soap_instantiate_WS1__GetFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFile:
		return (void*)soap_instantiate_WS1__SOF_USCOREDecryptFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREDecryptFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethod:
		return (void*)soap_instantiate_WS1__SOF_USCORESetSignMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORESetSignMethodResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetTimeStampInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7:
		return (void*)soap_instantiate_WS1__SOF_USCORESignDataByP7(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response:
		return (void*)soap_instantiate_WS1__SOF_USCORESignDataByP7Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFile:
		return (void*)soap_instantiate_WS1__SOF_USCOREEncryptFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREEncryptFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESignDataXML:
		return (void*)soap_instantiate_WS1__SOF_USCORESignDataXML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse:
		return (void*)soap_instantiate_WS1__SOF_USCORESignDataXMLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREDecryptData:
		return (void*)soap_instantiate_WS1__SOF_USCOREDecryptData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREDecryptDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames:
		return (void*)soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfo:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetCertInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREGetCertInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREEncryptData:
		return (void*)soap_instantiate_WS1__SOF_USCOREEncryptData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse:
		return (void*)soap_instantiate_WS1__SOF_USCOREEncryptDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedData:
		return (void*)soap_instantiate___WS1__SOF_USCOREVerifySignedData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustList:
		return (void*)soap_instantiate___WS1__SOF_USCOREQueryCertTrustList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetP7SignDataInfo:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetP7SignDataInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORESetCertTrustList:
		return (void*)soap_instantiate___WS1__SOF_USCORESetCertTrustList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataByP7:
		return (void*)soap_instantiate___WS1__SOF_USCOREVerifySignedDataByP7(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREPubKeyEncrypt:
		return (void*)soap_instantiate___WS1__SOF_USCOREPubKeyEncrypt(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREVerifyTimeStamp:
		return (void*)soap_instantiate___WS1__SOF_USCOREVerifyTimeStamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedFile:
		return (void*)soap_instantiate___WS1__SOF_USCOREVerifySignedFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetCertInfoByOid:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetCertInfoByOid(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetServerCertificate:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetServerCertificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREDelCertTrustList:
		return (void*)soap_instantiate___WS1__SOF_USCOREDelCertTrustList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetXMLSignatureInfo:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetXMLSignatureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORESignData:
		return (void*)soap_instantiate___WS1__SOF_USCORESignData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataXML:
		return (void*)soap_instantiate___WS1__SOF_USCOREVerifySignedDataXML(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORESignFile:
		return (void*)soap_instantiate___WS1__SOF_USCORESignFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetInstance:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetInstance(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREPriKeyDecrypt:
		return (void*)soap_instantiate___WS1__SOF_USCOREPriKeyDecrypt(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGenRandom:
		return (void*)soap_instantiate___WS1__SOF_USCOREGenRandom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetSignMethod:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetSignMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORESetWebAppName:
		return (void*)soap_instantiate___WS1__SOF_USCORESetWebAppName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORESetEncryptMethod:
		return (void*)soap_instantiate___WS1__SOF_USCORESetEncryptMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORECreateTimeStampRequest:
		return (void*)soap_instantiate___WS1__SOF_USCORECreateTimeStampRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetEncryptMethod:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetEncryptMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORECreateTimeStampResponse:
		return (void*)soap_instantiate___WS1__SOF_USCORECreateTimeStampResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREValidateCert:
		return (void*)soap_instantiate___WS1__SOF_USCOREValidateCert(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__DeleteFile:
		return (void*)soap_instantiate___WS1__DeleteFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__GetFile:
		return (void*)soap_instantiate___WS1__GetFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREDecryptFile:
		return (void*)soap_instantiate___WS1__SOF_USCOREDecryptFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORESetSignMethod:
		return (void*)soap_instantiate___WS1__SOF_USCORESetSignMethod(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetTimeStampInfo:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetTimeStampInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREEncryptFile:
		return (void*)soap_instantiate___WS1__SOF_USCOREEncryptFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORESignDataByP7:
		return (void*)soap_instantiate___WS1__SOF_USCORESignDataByP7(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREDecryptData:
		return (void*)soap_instantiate___WS1__SOF_USCOREDecryptData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCORESignDataXML:
		return (void*)soap_instantiate___WS1__SOF_USCORESignDataXML(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREGetCertInfo:
		return (void*)soap_instantiate___WS1__SOF_USCOREGetCertInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustListAltNames:
		return (void*)soap_instantiate___WS1__SOF_USCOREQueryCertTrustListAltNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE___WS1__SOF_USCOREEncryptData:
		return (void*)soap_instantiate___WS1__SOF_USCOREEncryptData(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			delete (std::wstring*)p->ptr;
		else
			delete[] (std::wstring*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedData:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifySignedData*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifySignedData*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifySignedDataResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifySignedDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList:
		if (p->size < 0)
			delete (WS1__SOF_USCOREQueryCertTrustList*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREQueryCertTrustList*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREQueryCertTrustListResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREQueryCertTrustListResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifySignedDataByP7*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifySignedDataByP7*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifySignedDataByP7Response*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifySignedDataByP7Response*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustList:
		if (p->size < 0)
			delete (WS1__SOF_USCORESetCertTrustList*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESetCertTrustList*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORESetCertTrustListResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESetCertTrustListResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetP7SignDataInfo*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetP7SignDataInfo*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetP7SignDataInfoResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetP7SignDataInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifyTimeStamp*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifyTimeStamp*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifyTimeStampResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifyTimeStampResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt:
		if (p->size < 0)
			delete (WS1__SOF_USCOREPubKeyEncrypt*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREPubKeyEncrypt*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREPubKeyEncryptResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREPubKeyEncryptResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifySignedFile*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifySignedFile*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifySignedFileResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifySignedFileResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetServerCertificate*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetServerCertificate*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetServerCertificateResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetServerCertificateResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetCertInfoByOid*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetCertInfoByOid*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetCertInfoByOidResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetCertInfoByOidResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList:
		if (p->size < 0)
			delete (WS1__SOF_USCOREDelCertTrustList*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREDelCertTrustList*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREDelCertTrustListResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREDelCertTrustListResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetXMLSignatureInfo*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetXMLSignatureInfo*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetXMLSignatureInfoResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetXMLSignatureInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifySignedDataXML*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifySignedDataXML*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREVerifySignedDataXMLResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREVerifySignedDataXMLResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignData:
		if (p->size < 0)
			delete (WS1__SOF_USCORESignData*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESignData*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORESignDataResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESignDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignFile:
		if (p->size < 0)
			delete (WS1__SOF_USCORESignFile*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESignFile*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignFileResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORESignFileResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESignFileResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetInstance:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetInstance*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetInstance*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetInstanceResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetInstanceResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__sofSecurityEngineDeal:
		if (p->size < 0)
			delete (WS1__sofSecurityEngineDeal*)p->ptr;
		else
			delete[] (WS1__sofSecurityEngineDeal*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt:
		if (p->size < 0)
			delete (WS1__SOF_USCOREPriKeyDecrypt*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREPriKeyDecrypt*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREPriKeyDecryptResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREPriKeyDecryptResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGenRandom:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGenRandom*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGenRandom*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGenRandomResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGenRandomResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppName:
		if (p->size < 0)
			delete (WS1__SOF_USCORESetWebAppName*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESetWebAppName*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORESetWebAppNameResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESetWebAppNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethod:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetSignMethod*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetSignMethod*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetSignMethodResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetSignMethodResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod:
		if (p->size < 0)
			delete (WS1__SOF_USCORESetEncryptMethod*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESetEncryptMethod*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORESetEncryptMethodResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESetEncryptMethodResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest:
		if (p->size < 0)
			delete (WS1__SOF_USCORECreateTimeStampRequest*)p->ptr;
		else
			delete[] (WS1__SOF_USCORECreateTimeStampRequest*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORECreateTimeStampRequestResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORECreateTimeStampRequestResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetEncryptMethod*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetEncryptMethod*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetEncryptMethodResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetEncryptMethodResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORECreateTimeStampResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORECreateTimeStampResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORECreateTimeStampResponseResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORECreateTimeStampResponseResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREValidateCert:
		if (p->size < 0)
			delete (WS1__SOF_USCOREValidateCert*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREValidateCert*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREValidateCertResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREValidateCertResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__DeleteFile:
		if (p->size < 0)
			delete (WS1__DeleteFile*)p->ptr;
		else
			delete[] (WS1__DeleteFile*)p->ptr;
		break;
	case SOAP_TYPE_WS1__DeleteFileResponse:
		if (p->size < 0)
			delete (WS1__DeleteFileResponse*)p->ptr;
		else
			delete[] (WS1__DeleteFileResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__GetFile:
		if (p->size < 0)
			delete (WS1__GetFile*)p->ptr;
		else
			delete[] (WS1__GetFile*)p->ptr;
		break;
	case SOAP_TYPE_WS1__GetFileResponse:
		if (p->size < 0)
			delete (WS1__GetFileResponse*)p->ptr;
		else
			delete[] (WS1__GetFileResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFile:
		if (p->size < 0)
			delete (WS1__SOF_USCOREDecryptFile*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREDecryptFile*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREDecryptFileResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREDecryptFileResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethod:
		if (p->size < 0)
			delete (WS1__SOF_USCORESetSignMethod*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESetSignMethod*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORESetSignMethodResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESetSignMethodResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetTimeStampInfo*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetTimeStampInfo*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetTimeStampInfoResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetTimeStampInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7:
		if (p->size < 0)
			delete (WS1__SOF_USCORESignDataByP7*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESignDataByP7*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response:
		if (p->size < 0)
			delete (WS1__SOF_USCORESignDataByP7Response*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESignDataByP7Response*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFile:
		if (p->size < 0)
			delete (WS1__SOF_USCOREEncryptFile*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREEncryptFile*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREEncryptFileResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREEncryptFileResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataXML:
		if (p->size < 0)
			delete (WS1__SOF_USCORESignDataXML*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESignDataXML*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCORESignDataXMLResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCORESignDataXMLResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDecryptData:
		if (p->size < 0)
			delete (WS1__SOF_USCOREDecryptData*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREDecryptData*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREDecryptDataResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREDecryptDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames:
		if (p->size < 0)
			delete (WS1__SOF_USCOREQueryCertTrustListAltNames*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREQueryCertTrustListAltNames*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfo:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetCertInfo*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetCertInfo*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREGetCertInfoResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREGetCertInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREEncryptData:
		if (p->size < 0)
			delete (WS1__SOF_USCOREEncryptData*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREEncryptData*)p->ptr;
		break;
	case SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse:
		if (p->size < 0)
			delete (WS1__SOF_USCOREEncryptDataResponse*)p->ptr;
		else
			delete[] (WS1__SOF_USCOREEncryptDataResponse*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedData:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREVerifySignedData*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREVerifySignedData*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustList:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREQueryCertTrustList*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREQueryCertTrustList*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetP7SignDataInfo:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetP7SignDataInfo*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetP7SignDataInfo*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORESetCertTrustList:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORESetCertTrustList*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORESetCertTrustList*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataByP7:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREVerifySignedDataByP7*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREVerifySignedDataByP7*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREPubKeyEncrypt:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREPubKeyEncrypt*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREPubKeyEncrypt*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifyTimeStamp:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREVerifyTimeStamp*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREVerifyTimeStamp*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedFile:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREVerifySignedFile*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREVerifySignedFile*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetCertInfoByOid:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetCertInfoByOid*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetCertInfoByOid*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetServerCertificate:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetServerCertificate*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetServerCertificate*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREDelCertTrustList:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREDelCertTrustList*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREDelCertTrustList*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetXMLSignatureInfo:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetXMLSignatureInfo*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetXMLSignatureInfo*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORESignData:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORESignData*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORESignData*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataXML:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREVerifySignedDataXML*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREVerifySignedDataXML*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORESignFile:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORESignFile*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORESignFile*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetInstance:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetInstance*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetInstance*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREPriKeyDecrypt:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREPriKeyDecrypt*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREPriKeyDecrypt*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGenRandom:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGenRandom*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGenRandom*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetSignMethod:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetSignMethod*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetSignMethod*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORESetWebAppName:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORESetWebAppName*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORESetWebAppName*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORESetEncryptMethod:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORESetEncryptMethod*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORESetEncryptMethod*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORECreateTimeStampRequest:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORECreateTimeStampRequest*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORECreateTimeStampRequest*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetEncryptMethod:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetEncryptMethod*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetEncryptMethod*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORECreateTimeStampResponse:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORECreateTimeStampResponse*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORECreateTimeStampResponse*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREValidateCert:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREValidateCert*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREValidateCert*)p->ptr;
		break;
	case SOAP_TYPE___WS1__DeleteFile:
		if (p->size < 0)
			delete (struct __WS1__DeleteFile*)p->ptr;
		else
			delete[] (struct __WS1__DeleteFile*)p->ptr;
		break;
	case SOAP_TYPE___WS1__GetFile:
		if (p->size < 0)
			delete (struct __WS1__GetFile*)p->ptr;
		else
			delete[] (struct __WS1__GetFile*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREDecryptFile:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREDecryptFile*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREDecryptFile*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORESetSignMethod:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORESetSignMethod*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORESetSignMethod*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetTimeStampInfo:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetTimeStampInfo*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetTimeStampInfo*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREEncryptFile:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREEncryptFile*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREEncryptFile*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORESignDataByP7:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORESignDataByP7*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORESignDataByP7*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREDecryptData:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREDecryptData*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREDecryptData*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCORESignDataXML:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCORESignDataXML*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCORESignDataXML*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREGetCertInfo:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREGetCertInfo*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREGetCertInfo*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustListAltNames:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREQueryCertTrustListAltNames*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREQueryCertTrustListAltNames*)p->ptr;
		break;
	case SOAP_TYPE___WS1__SOF_USCOREEncryptData:
		if (p->size < 0)
			delete (struct __WS1__SOF_USCOREEncryptData*)p->ptr;
		else
			delete[] (struct __WS1__SOF_USCOREEncryptData*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	const char *s = soap_code_str(soap_codes_bool, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_wstring_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::wstring * SOAP_FMAC6 soap_new_std__wstring(struct soap *soap, int n)
{	return soap_instantiate_std__wstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__wstring(struct soap *soap, std::wstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::wstring;
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)new std::wstring[n];
		if (size)
			*size = n * sizeof(std::wstring);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

void WS1__SOF_USCOREEncryptDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREEncryptDataResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREEncryptDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREEncryptDataResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREEncryptDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREEncryptDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREEncryptDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREEncryptDataResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREEncryptDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREEncryptDataResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREEncryptDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREEncryptDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptDataResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREEncryptDataResponse(struct soap *soap, WS1__SOF_USCOREEncryptDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREEncryptDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREEncryptDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREEncryptDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptDataResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREEncryptDataResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREEncryptDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREEncryptDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse, sizeof(WS1__SOF_USCOREEncryptDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREEncryptDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREEncryptDataResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREEncryptDataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse, 0, sizeof(WS1__SOF_USCOREEncryptDataResponse), 0, soap_copy_WS1__SOF_USCOREEncryptDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREEncryptDataResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREEncryptDataResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREEncryptDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREEncryptDataResponse(struct soap *soap, WS1__SOF_USCOREEncryptDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptDataResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREEncryptDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREEncryptDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREEncryptDataResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREEncryptDataResponse);
		((WS1__SOF_USCOREEncryptDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREEncryptDataResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREEncryptDataResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREEncryptDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREEncryptDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREEncryptDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREEncryptDataResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREEncryptDataResponse*)p = *(WS1__SOF_USCOREEncryptDataResponse*)q;
}

void WS1__SOF_USCOREEncryptData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREEncryptData*)this)->key);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREEncryptData*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREEncryptData::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREEncryptData*)this)->key = NULL;
	((WS1__SOF_USCOREEncryptData*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREEncryptData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREEncryptData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREEncryptData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREEncryptData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREEncryptData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREEncryptData), type);
	soap_out_PointerTostd__wstring(soap, "key", -1, &(((WS1__SOF_USCOREEncryptData*)a)->key), "");
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCOREEncryptData*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREEncryptData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREEncryptData(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_get_WS1__SOF_USCOREEncryptData(struct soap *soap, WS1__SOF_USCOREEncryptData *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREEncryptData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREEncryptData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREEncryptData(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_in_WS1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, WS1__SOF_USCOREEncryptData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREEncryptData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREEncryptData, sizeof(WS1__SOF_USCOREEncryptData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREEncryptData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREEncryptData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_key1 = 1, soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "key", &(((WS1__SOF_USCOREEncryptData*)a)->key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCOREEncryptData*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREEncryptData *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREEncryptData, 0, sizeof(WS1__SOF_USCOREEncryptData), 0, soap_copy_WS1__SOF_USCOREEncryptData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREEncryptData * SOAP_FMAC6 soap_new_WS1__SOF_USCOREEncryptData(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREEncryptData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREEncryptData(struct soap *soap, WS1__SOF_USCOREEncryptData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREEncryptData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREEncryptData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREEncryptData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREEncryptData;
		if (size)
			*size = sizeof(WS1__SOF_USCOREEncryptData);
		((WS1__SOF_USCOREEncryptData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREEncryptData[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREEncryptData);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREEncryptData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREEncryptData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREEncryptData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREEncryptData %p -> %p\n", q, p));
	*(WS1__SOF_USCOREEncryptData*)p = *(WS1__SOF_USCOREEncryptData*)q;
}

void WS1__SOF_USCOREGetCertInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetCertInfoResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetCertInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetCertInfoResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetCertInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetCertInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetCertInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetCertInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGetCertInfoResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetCertInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetCertInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetCertInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetCertInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetCertInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetCertInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetCertInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse, sizeof(WS1__SOF_USCOREGetCertInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetCertInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGetCertInfoResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetCertInfoResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse, 0, sizeof(WS1__SOF_USCOREGetCertInfoResponse), 0, soap_copy_WS1__SOF_USCOREGetCertInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetCertInfoResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetCertInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetCertInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetCertInfoResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetCertInfoResponse);
		((WS1__SOF_USCOREGetCertInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetCertInfoResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetCertInfoResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetCertInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetCertInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetCertInfoResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetCertInfoResponse*)p = *(WS1__SOF_USCOREGetCertInfoResponse*)q;
}

void WS1__SOF_USCOREGetCertInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetCertInfo*)this)->base64EncodeCert);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetCertInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetCertInfo*)this)->base64EncodeCert = NULL;
	soap_default_int(soap, &((WS1__SOF_USCOREGetCertInfo*)this)->type);
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetCertInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetCertInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetCertInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetCertInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetCertInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfo), type);
	soap_out_PointerTostd__wstring(soap, "base64EncodeCert", -1, &(((WS1__SOF_USCOREGetCertInfo*)a)->base64EncodeCert), "");
	soap_out_int(soap, "type", -1, &(((WS1__SOF_USCOREGetCertInfo*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetCertInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetCertInfo(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetCertInfo(struct soap *soap, WS1__SOF_USCOREGetCertInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetCertInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetCertInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetCertInfo(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, WS1__SOF_USCOREGetCertInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetCertInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfo, sizeof(WS1__SOF_USCOREGetCertInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetCertInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetCertInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_base64EncodeCert1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "base64EncodeCert", &(((WS1__SOF_USCOREGetCertInfo*)a)->base64EncodeCert), "xsd:string"))
				{	soap_flag_base64EncodeCert1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(((WS1__SOF_USCOREGetCertInfo*)a)->type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetCertInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetCertInfo, 0, sizeof(WS1__SOF_USCOREGetCertInfo), 0, soap_copy_WS1__SOF_USCOREGetCertInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetCertInfo * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetCertInfo(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetCertInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetCertInfo(struct soap *soap, WS1__SOF_USCOREGetCertInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetCertInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetCertInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetCertInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetCertInfo;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetCertInfo);
		((WS1__SOF_USCOREGetCertInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetCertInfo[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetCertInfo);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetCertInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetCertInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetCertInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetCertInfo %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetCertInfo*)p = *(WS1__SOF_USCOREGetCertInfo*)q;
}

void WS1__SOF_USCOREQueryCertTrustListAltNamesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREQueryCertTrustListAltNamesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREQueryCertTrustListAltNamesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREQueryCertTrustListAltNamesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREQueryCertTrustListAltNamesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNamesResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREQueryCertTrustListAltNamesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNamesResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse, sizeof(WS1__SOF_USCOREQueryCertTrustListAltNamesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse, 0, sizeof(WS1__SOF_USCOREQueryCertTrustListAltNamesResponse), 0, soap_copy_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREQueryCertTrustListAltNamesResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNamesResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREQueryCertTrustListAltNamesResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREQueryCertTrustListAltNamesResponse);
		((WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREQueryCertTrustListAltNamesResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREQueryCertTrustListAltNamesResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREQueryCertTrustListAltNamesResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)p = *(WS1__SOF_USCOREQueryCertTrustListAltNamesResponse*)q;
}

void WS1__SOF_USCOREQueryCertTrustListAltNames::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREQueryCertTrustListAltNames::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int WS1__SOF_USCOREQueryCertTrustListAltNames::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREQueryCertTrustListAltNames::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREQueryCertTrustListAltNames *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREQueryCertTrustListAltNames::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_get_WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREQueryCertTrustListAltNames::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_in_WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, WS1__SOF_USCOREQueryCertTrustListAltNames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREQueryCertTrustListAltNames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames, sizeof(WS1__SOF_USCOREQueryCertTrustListAltNames), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREQueryCertTrustListAltNames *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREQueryCertTrustListAltNames *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames, 0, sizeof(WS1__SOF_USCOREQueryCertTrustListAltNames), 0, soap_copy_WS1__SOF_USCOREQueryCertTrustListAltNames);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC6 soap_new_WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNames *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREQueryCertTrustListAltNames;
		if (size)
			*size = sizeof(WS1__SOF_USCOREQueryCertTrustListAltNames);
		((WS1__SOF_USCOREQueryCertTrustListAltNames*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREQueryCertTrustListAltNames[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREQueryCertTrustListAltNames);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREQueryCertTrustListAltNames*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREQueryCertTrustListAltNames*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREQueryCertTrustListAltNames %p -> %p\n", q, p));
	*(WS1__SOF_USCOREQueryCertTrustListAltNames*)p = *(WS1__SOF_USCOREQueryCertTrustListAltNames*)q;
}

void WS1__SOF_USCOREDecryptDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREDecryptDataResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREDecryptDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREDecryptDataResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREDecryptDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREDecryptDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREDecryptDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREDecryptDataResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREDecryptDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREDecryptDataResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREDecryptDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREDecryptDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptDataResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREDecryptDataResponse(struct soap *soap, WS1__SOF_USCOREDecryptDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREDecryptDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREDecryptDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREDecryptDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptDataResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREDecryptDataResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREDecryptDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREDecryptDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse, sizeof(WS1__SOF_USCOREDecryptDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREDecryptDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREDecryptDataResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDecryptDataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse, 0, sizeof(WS1__SOF_USCOREDecryptDataResponse), 0, soap_copy_WS1__SOF_USCOREDecryptDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREDecryptDataResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREDecryptDataResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREDecryptDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREDecryptDataResponse(struct soap *soap, WS1__SOF_USCOREDecryptDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptDataResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREDecryptDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREDecryptDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREDecryptDataResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREDecryptDataResponse);
		((WS1__SOF_USCOREDecryptDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREDecryptDataResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREDecryptDataResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREDecryptDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREDecryptDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREDecryptDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREDecryptDataResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREDecryptDataResponse*)p = *(WS1__SOF_USCOREDecryptDataResponse*)q;
}

void WS1__SOF_USCOREDecryptData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREDecryptData*)this)->key);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREDecryptData*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREDecryptData::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREDecryptData*)this)->key = NULL;
	((WS1__SOF_USCOREDecryptData*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREDecryptData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREDecryptData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREDecryptData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREDecryptData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREDecryptData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREDecryptData), type);
	soap_out_PointerTostd__wstring(soap, "key", -1, &(((WS1__SOF_USCOREDecryptData*)a)->key), "");
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCOREDecryptData*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREDecryptData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREDecryptData(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_get_WS1__SOF_USCOREDecryptData(struct soap *soap, WS1__SOF_USCOREDecryptData *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREDecryptData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREDecryptData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREDecryptData(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_in_WS1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, WS1__SOF_USCOREDecryptData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREDecryptData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREDecryptData, sizeof(WS1__SOF_USCOREDecryptData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREDecryptData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREDecryptData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_key1 = 1, soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "key", &(((WS1__SOF_USCOREDecryptData*)a)->key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCOREDecryptData*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDecryptData *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREDecryptData, 0, sizeof(WS1__SOF_USCOREDecryptData), 0, soap_copy_WS1__SOF_USCOREDecryptData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREDecryptData * SOAP_FMAC6 soap_new_WS1__SOF_USCOREDecryptData(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREDecryptData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREDecryptData(struct soap *soap, WS1__SOF_USCOREDecryptData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREDecryptData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREDecryptData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREDecryptData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREDecryptData;
		if (size)
			*size = sizeof(WS1__SOF_USCOREDecryptData);
		((WS1__SOF_USCOREDecryptData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREDecryptData[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREDecryptData);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREDecryptData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREDecryptData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREDecryptData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREDecryptData %p -> %p\n", q, p));
	*(WS1__SOF_USCOREDecryptData*)p = *(WS1__SOF_USCOREDecryptData*)q;
}

void WS1__SOF_USCORESignDataXMLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESignDataXMLResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORESignDataXMLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESignDataXMLResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESignDataXMLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESignDataXMLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESignDataXMLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESignDataXMLResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESignDataXMLResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORESignDataXMLResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESignDataXMLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESignDataXMLResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXMLResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORESignDataXMLResponse(struct soap *soap, WS1__SOF_USCORESignDataXMLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESignDataXMLResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESignDataXMLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESignDataXMLResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXMLResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORESignDataXMLResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataXMLResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESignDataXMLResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse, sizeof(WS1__SOF_USCORESignDataXMLResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESignDataXMLResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORESignDataXMLResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataXMLResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse, 0, sizeof(WS1__SOF_USCORESignDataXMLResponse), 0, soap_copy_WS1__SOF_USCORESignDataXMLResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESignDataXMLResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORESignDataXMLResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESignDataXMLResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESignDataXMLResponse(struct soap *soap, WS1__SOF_USCORESignDataXMLResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXMLResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESignDataXMLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESignDataXMLResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataXMLResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORESignDataXMLResponse);
		((WS1__SOF_USCORESignDataXMLResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataXMLResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESignDataXMLResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESignDataXMLResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESignDataXMLResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESignDataXMLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESignDataXMLResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORESignDataXMLResponse*)p = *(WS1__SOF_USCORESignDataXMLResponse*)q;
}

void WS1__SOF_USCORESignDataXML::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESignDataXML*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCORESignDataXML::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESignDataXML*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESignDataXML::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESignDataXML);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESignDataXML::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESignDataXML(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESignDataXML *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESignDataXML), type);
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCORESignDataXML*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESignDataXML::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESignDataXML(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_get_WS1__SOF_USCORESignDataXML(struct soap *soap, WS1__SOF_USCORESignDataXML *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESignDataXML(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESignDataXML::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESignDataXML(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_in_WS1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataXML *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESignDataXML *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESignDataXML, sizeof(WS1__SOF_USCORESignDataXML), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESignDataXML)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESignDataXML *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCORESignDataXML*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataXML *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESignDataXML, 0, sizeof(WS1__SOF_USCORESignDataXML), 0, soap_copy_WS1__SOF_USCORESignDataXML);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESignDataXML * SOAP_FMAC6 soap_new_WS1__SOF_USCORESignDataXML(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESignDataXML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESignDataXML(struct soap *soap, WS1__SOF_USCORESignDataXML *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESignDataXML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESignDataXML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESignDataXML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataXML;
		if (size)
			*size = sizeof(WS1__SOF_USCORESignDataXML);
		((WS1__SOF_USCORESignDataXML*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataXML[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESignDataXML);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESignDataXML*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESignDataXML*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESignDataXML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESignDataXML %p -> %p\n", q, p));
	*(WS1__SOF_USCORESignDataXML*)p = *(WS1__SOF_USCORESignDataXML*)q;
}

void WS1__SOF_USCOREEncryptFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREEncryptFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((WS1__SOF_USCOREEncryptFileResponse*)this)->return_);
	/* transient soap skipped */
}

int WS1__SOF_USCOREEncryptFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREEncryptFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREEncryptFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREEncryptFileResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREEncryptFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse), type);
	soap_out_bool(soap, "return", -1, &(((WS1__SOF_USCOREEncryptFileResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREEncryptFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREEncryptFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFileResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREEncryptFileResponse(struct soap *soap, WS1__SOF_USCOREEncryptFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREEncryptFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREEncryptFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREEncryptFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFileResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREEncryptFileResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREEncryptFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREEncryptFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse, sizeof(WS1__SOF_USCOREEncryptFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREEncryptFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(((WS1__SOF_USCOREEncryptFileResponse*)a)->return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREEncryptFileResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse, 0, sizeof(WS1__SOF_USCOREEncryptFileResponse), 0, soap_copy_WS1__SOF_USCOREEncryptFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREEncryptFileResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREEncryptFileResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREEncryptFileResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREEncryptFileResponse(struct soap *soap, WS1__SOF_USCOREEncryptFileResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFileResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREEncryptFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREEncryptFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREEncryptFileResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREEncryptFileResponse);
		((WS1__SOF_USCOREEncryptFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREEncryptFileResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREEncryptFileResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREEncryptFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREEncryptFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREEncryptFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREEncryptFileResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREEncryptFileResponse*)p = *(WS1__SOF_USCOREEncryptFileResponse*)q;
}

void WS1__SOF_USCOREEncryptFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREEncryptFile*)this)->key);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREEncryptFile*)this)->inFile);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREEncryptFile*)this)->outFile);
	/* transient soap skipped */
}

void WS1__SOF_USCOREEncryptFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREEncryptFile*)this)->key = NULL;
	((WS1__SOF_USCOREEncryptFile*)this)->inFile = NULL;
	((WS1__SOF_USCOREEncryptFile*)this)->outFile = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREEncryptFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREEncryptFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREEncryptFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREEncryptFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREEncryptFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREEncryptFile), type);
	soap_out_PointerTostd__wstring(soap, "key", -1, &(((WS1__SOF_USCOREEncryptFile*)a)->key), "");
	soap_out_PointerTostd__wstring(soap, "inFile", -1, &(((WS1__SOF_USCOREEncryptFile*)a)->inFile), "");
	soap_out_PointerTostd__wstring(soap, "outFile", -1, &(((WS1__SOF_USCOREEncryptFile*)a)->outFile), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREEncryptFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREEncryptFile(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_get_WS1__SOF_USCOREEncryptFile(struct soap *soap, WS1__SOF_USCOREEncryptFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREEncryptFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREEncryptFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREEncryptFile(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_in_WS1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, WS1__SOF_USCOREEncryptFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREEncryptFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREEncryptFile, sizeof(WS1__SOF_USCOREEncryptFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREEncryptFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREEncryptFile *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_key1 = 1, soap_flag_inFile1 = 1, soap_flag_outFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "key", &(((WS1__SOF_USCOREEncryptFile*)a)->key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_inFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inFile", &(((WS1__SOF_USCOREEncryptFile*)a)->inFile), "xsd:string"))
				{	soap_flag_inFile1--;
					continue;
				}
			if (soap_flag_outFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "outFile", &(((WS1__SOF_USCOREEncryptFile*)a)->outFile), "xsd:string"))
				{	soap_flag_outFile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREEncryptFile *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREEncryptFile, 0, sizeof(WS1__SOF_USCOREEncryptFile), 0, soap_copy_WS1__SOF_USCOREEncryptFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREEncryptFile * SOAP_FMAC6 soap_new_WS1__SOF_USCOREEncryptFile(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREEncryptFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREEncryptFile(struct soap *soap, WS1__SOF_USCOREEncryptFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREEncryptFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREEncryptFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREEncryptFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREEncryptFile;
		if (size)
			*size = sizeof(WS1__SOF_USCOREEncryptFile);
		((WS1__SOF_USCOREEncryptFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREEncryptFile[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREEncryptFile);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREEncryptFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREEncryptFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREEncryptFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREEncryptFile %p -> %p\n", q, p));
	*(WS1__SOF_USCOREEncryptFile*)p = *(WS1__SOF_USCOREEncryptFile*)q;
}

void WS1__SOF_USCORESignDataByP7Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESignDataByP7Response*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORESignDataByP7Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESignDataByP7Response*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESignDataByP7Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESignDataByP7Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESignDataByP7Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESignDataByP7Response(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESignDataByP7Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORESignDataByP7Response*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESignDataByP7Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESignDataByP7Response(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7Response * SOAP_FMAC4 soap_get_WS1__SOF_USCORESignDataByP7Response(struct soap *soap, WS1__SOF_USCORESignDataByP7Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESignDataByP7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESignDataByP7Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESignDataByP7Response(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7Response * SOAP_FMAC4 soap_in_WS1__SOF_USCORESignDataByP7Response(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataByP7Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESignDataByP7Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response, sizeof(WS1__SOF_USCORESignDataByP7Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESignDataByP7Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORESignDataByP7Response*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataByP7Response *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response, 0, sizeof(WS1__SOF_USCORESignDataByP7Response), 0, soap_copy_WS1__SOF_USCORESignDataByP7Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESignDataByP7Response * SOAP_FMAC6 soap_new_WS1__SOF_USCORESignDataByP7Response(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESignDataByP7Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESignDataByP7Response(struct soap *soap, WS1__SOF_USCORESignDataByP7Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7Response * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESignDataByP7Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESignDataByP7Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataByP7Response;
		if (size)
			*size = sizeof(WS1__SOF_USCORESignDataByP7Response);
		((WS1__SOF_USCORESignDataByP7Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataByP7Response[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESignDataByP7Response);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESignDataByP7Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESignDataByP7Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESignDataByP7Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESignDataByP7Response %p -> %p\n", q, p));
	*(WS1__SOF_USCORESignDataByP7Response*)p = *(WS1__SOF_USCORESignDataByP7Response*)q;
}

void WS1__SOF_USCORESignDataByP7::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESignDataByP7*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCORESignDataByP7::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESignDataByP7*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESignDataByP7::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESignDataByP7);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESignDataByP7::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESignDataByP7(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESignDataByP7 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESignDataByP7), type);
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCORESignDataByP7*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESignDataByP7::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESignDataByP7(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_get_WS1__SOF_USCORESignDataByP7(struct soap *soap, WS1__SOF_USCORESignDataByP7 *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESignDataByP7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESignDataByP7::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESignDataByP7(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_in_WS1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataByP7 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESignDataByP7 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESignDataByP7, sizeof(WS1__SOF_USCORESignDataByP7), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESignDataByP7)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESignDataByP7 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCORESignDataByP7*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataByP7 *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESignDataByP7, 0, sizeof(WS1__SOF_USCORESignDataByP7), 0, soap_copy_WS1__SOF_USCORESignDataByP7);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESignDataByP7 * SOAP_FMAC6 soap_new_WS1__SOF_USCORESignDataByP7(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESignDataByP7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESignDataByP7(struct soap *soap, WS1__SOF_USCORESignDataByP7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESignDataByP7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESignDataByP7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESignDataByP7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataByP7;
		if (size)
			*size = sizeof(WS1__SOF_USCORESignDataByP7);
		((WS1__SOF_USCORESignDataByP7*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataByP7[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESignDataByP7);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESignDataByP7*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESignDataByP7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESignDataByP7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESignDataByP7 %p -> %p\n", q, p));
	*(WS1__SOF_USCORESignDataByP7*)p = *(WS1__SOF_USCORESignDataByP7*)q;
}

void WS1__SOF_USCOREGetTimeStampInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetTimeStampInfoResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetTimeStampInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetTimeStampInfoResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetTimeStampInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetTimeStampInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetTimeStampInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGetTimeStampInfoResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetTimeStampInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfoResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetTimeStampInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfoResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetTimeStampInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetTimeStampInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse, sizeof(WS1__SOF_USCOREGetTimeStampInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetTimeStampInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGetTimeStampInfoResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetTimeStampInfoResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse, 0, sizeof(WS1__SOF_USCOREGetTimeStampInfoResponse), 0, soap_copy_WS1__SOF_USCOREGetTimeStampInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetTimeStampInfoResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfoResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetTimeStampInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetTimeStampInfoResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetTimeStampInfoResponse);
		((WS1__SOF_USCOREGetTimeStampInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetTimeStampInfoResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetTimeStampInfoResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetTimeStampInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetTimeStampInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetTimeStampInfoResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetTimeStampInfoResponse*)p = *(WS1__SOF_USCOREGetTimeStampInfoResponse*)q;
}

void WS1__SOF_USCOREGetTimeStampInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetTimeStampInfo*)this)->tsResponseData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetTimeStampInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetTimeStampInfo*)this)->tsResponseData = NULL;
	soap_default_int(soap, &((WS1__SOF_USCOREGetTimeStampInfo*)this)->type);
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetTimeStampInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetTimeStampInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetTimeStampInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetTimeStampInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo), type);
	soap_out_PointerTostd__wstring(soap, "tsResponseData", -1, &(((WS1__SOF_USCOREGetTimeStampInfo*)a)->tsResponseData), "");
	soap_out_int(soap, "type", -1, &(((WS1__SOF_USCOREGetTimeStampInfo*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetTimeStampInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetTimeStampInfo(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetTimeStampInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetTimeStampInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetTimeStampInfo(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, WS1__SOF_USCOREGetTimeStampInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetTimeStampInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo, sizeof(WS1__SOF_USCOREGetTimeStampInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetTimeStampInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_tsResponseData1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tsResponseData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "tsResponseData", &(((WS1__SOF_USCOREGetTimeStampInfo*)a)->tsResponseData), "xsd:string"))
				{	soap_flag_tsResponseData1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(((WS1__SOF_USCOREGetTimeStampInfo*)a)->type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetTimeStampInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo, 0, sizeof(WS1__SOF_USCOREGetTimeStampInfo), 0, soap_copy_WS1__SOF_USCOREGetTimeStampInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetTimeStampInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetTimeStampInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetTimeStampInfo;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetTimeStampInfo);
		((WS1__SOF_USCOREGetTimeStampInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetTimeStampInfo[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetTimeStampInfo);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetTimeStampInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetTimeStampInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetTimeStampInfo %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetTimeStampInfo*)p = *(WS1__SOF_USCOREGetTimeStampInfo*)q;
}

void WS1__SOF_USCORESetSignMethodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESetSignMethodResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORESetSignMethodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESetSignMethodResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESetSignMethodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESetSignMethodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESetSignMethodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESetSignMethodResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESetSignMethodResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORESetSignMethodResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESetSignMethodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESetSignMethodResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethodResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORESetSignMethodResponse(struct soap *soap, WS1__SOF_USCORESetSignMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESetSignMethodResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESetSignMethodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESetSignMethodResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethodResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORESetSignMethodResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESetSignMethodResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESetSignMethodResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse, sizeof(WS1__SOF_USCORESetSignMethodResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESetSignMethodResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORESetSignMethodResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetSignMethodResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse, 0, sizeof(WS1__SOF_USCORESetSignMethodResponse), 0, soap_copy_WS1__SOF_USCORESetSignMethodResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESetSignMethodResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORESetSignMethodResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESetSignMethodResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESetSignMethodResponse(struct soap *soap, WS1__SOF_USCORESetSignMethodResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethodResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESetSignMethodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESetSignMethodResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESetSignMethodResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORESetSignMethodResponse);
		((WS1__SOF_USCORESetSignMethodResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESetSignMethodResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESetSignMethodResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESetSignMethodResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESetSignMethodResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESetSignMethodResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESetSignMethodResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORESetSignMethodResponse*)p = *(WS1__SOF_USCORESetSignMethodResponse*)q;
}

void WS1__SOF_USCORESetSignMethod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCORESetSignMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((WS1__SOF_USCORESetSignMethod*)this)->signMethod);
	/* transient soap skipped */
}

int WS1__SOF_USCORESetSignMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESetSignMethod);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESetSignMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESetSignMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESetSignMethod *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESetSignMethod), type);
	soap_out_int(soap, "signMethod", -1, &(((WS1__SOF_USCORESetSignMethod*)a)->signMethod), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESetSignMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESetSignMethod(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_get_WS1__SOF_USCORESetSignMethod(struct soap *soap, WS1__SOF_USCORESetSignMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESetSignMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESetSignMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESetSignMethod(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_in_WS1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, WS1__SOF_USCORESetSignMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESetSignMethod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESetSignMethod, sizeof(WS1__SOF_USCORESetSignMethod), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESetSignMethod)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESetSignMethod *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_signMethod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signMethod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "signMethod", &(((WS1__SOF_USCORESetSignMethod*)a)->signMethod), "xsd:int"))
				{	soap_flag_signMethod1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_signMethod1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetSignMethod *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESetSignMethod, 0, sizeof(WS1__SOF_USCORESetSignMethod), 0, soap_copy_WS1__SOF_USCORESetSignMethod);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESetSignMethod * SOAP_FMAC6 soap_new_WS1__SOF_USCORESetSignMethod(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESetSignMethod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESetSignMethod(struct soap *soap, WS1__SOF_USCORESetSignMethod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESetSignMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESetSignMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESetSignMethod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESetSignMethod;
		if (size)
			*size = sizeof(WS1__SOF_USCORESetSignMethod);
		((WS1__SOF_USCORESetSignMethod*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESetSignMethod[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESetSignMethod);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESetSignMethod*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESetSignMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESetSignMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESetSignMethod %p -> %p\n", q, p));
	*(WS1__SOF_USCORESetSignMethod*)p = *(WS1__SOF_USCORESetSignMethod*)q;
}

void WS1__SOF_USCOREDecryptFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREDecryptFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((WS1__SOF_USCOREDecryptFileResponse*)this)->return_);
	/* transient soap skipped */
}

int WS1__SOF_USCOREDecryptFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREDecryptFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREDecryptFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREDecryptFileResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREDecryptFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse), type);
	soap_out_bool(soap, "return", -1, &(((WS1__SOF_USCOREDecryptFileResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREDecryptFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREDecryptFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFileResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREDecryptFileResponse(struct soap *soap, WS1__SOF_USCOREDecryptFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREDecryptFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREDecryptFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREDecryptFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFileResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREDecryptFileResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREDecryptFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREDecryptFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse, sizeof(WS1__SOF_USCOREDecryptFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREDecryptFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(((WS1__SOF_USCOREDecryptFileResponse*)a)->return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDecryptFileResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse, 0, sizeof(WS1__SOF_USCOREDecryptFileResponse), 0, soap_copy_WS1__SOF_USCOREDecryptFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREDecryptFileResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREDecryptFileResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREDecryptFileResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREDecryptFileResponse(struct soap *soap, WS1__SOF_USCOREDecryptFileResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFileResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREDecryptFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREDecryptFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREDecryptFileResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREDecryptFileResponse);
		((WS1__SOF_USCOREDecryptFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREDecryptFileResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREDecryptFileResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREDecryptFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREDecryptFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREDecryptFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREDecryptFileResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREDecryptFileResponse*)p = *(WS1__SOF_USCOREDecryptFileResponse*)q;
}

void WS1__SOF_USCOREDecryptFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREDecryptFile*)this)->key);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREDecryptFile*)this)->inFile);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREDecryptFile*)this)->outFile);
	/* transient soap skipped */
}

void WS1__SOF_USCOREDecryptFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREDecryptFile*)this)->key = NULL;
	((WS1__SOF_USCOREDecryptFile*)this)->inFile = NULL;
	((WS1__SOF_USCOREDecryptFile*)this)->outFile = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREDecryptFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREDecryptFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREDecryptFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREDecryptFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREDecryptFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREDecryptFile), type);
	soap_out_PointerTostd__wstring(soap, "key", -1, &(((WS1__SOF_USCOREDecryptFile*)a)->key), "");
	soap_out_PointerTostd__wstring(soap, "inFile", -1, &(((WS1__SOF_USCOREDecryptFile*)a)->inFile), "");
	soap_out_PointerTostd__wstring(soap, "outFile", -1, &(((WS1__SOF_USCOREDecryptFile*)a)->outFile), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREDecryptFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREDecryptFile(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_get_WS1__SOF_USCOREDecryptFile(struct soap *soap, WS1__SOF_USCOREDecryptFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREDecryptFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREDecryptFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREDecryptFile(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_in_WS1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, WS1__SOF_USCOREDecryptFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREDecryptFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREDecryptFile, sizeof(WS1__SOF_USCOREDecryptFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREDecryptFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREDecryptFile *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_key1 = 1, soap_flag_inFile1 = 1, soap_flag_outFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "key", &(((WS1__SOF_USCOREDecryptFile*)a)->key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_inFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inFile", &(((WS1__SOF_USCOREDecryptFile*)a)->inFile), "xsd:string"))
				{	soap_flag_inFile1--;
					continue;
				}
			if (soap_flag_outFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "outFile", &(((WS1__SOF_USCOREDecryptFile*)a)->outFile), "xsd:string"))
				{	soap_flag_outFile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDecryptFile *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREDecryptFile, 0, sizeof(WS1__SOF_USCOREDecryptFile), 0, soap_copy_WS1__SOF_USCOREDecryptFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREDecryptFile * SOAP_FMAC6 soap_new_WS1__SOF_USCOREDecryptFile(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREDecryptFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREDecryptFile(struct soap *soap, WS1__SOF_USCOREDecryptFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREDecryptFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREDecryptFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREDecryptFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREDecryptFile;
		if (size)
			*size = sizeof(WS1__SOF_USCOREDecryptFile);
		((WS1__SOF_USCOREDecryptFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREDecryptFile[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREDecryptFile);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREDecryptFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREDecryptFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREDecryptFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREDecryptFile %p -> %p\n", q, p));
	*(WS1__SOF_USCOREDecryptFile*)p = *(WS1__SOF_USCOREDecryptFile*)q;
}

void WS1__GetFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &((WS1__GetFileResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__GetFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__GetFileResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__GetFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__GetFileResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__GetFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__GetFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__GetFileResponse(struct soap *soap, const char *tag, int id, const WS1__GetFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__GetFileResponse), type);
	soap_out_PointerToxsd__base64Binary(soap, "return", -1, &(((WS1__GetFileResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__GetFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__GetFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__GetFileResponse * SOAP_FMAC4 soap_get_WS1__GetFileResponse(struct soap *soap, WS1__GetFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__GetFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__GetFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__GetFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__GetFileResponse * SOAP_FMAC4 soap_in_WS1__GetFileResponse(struct soap *soap, const char *tag, WS1__GetFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__GetFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__GetFileResponse, sizeof(WS1__GetFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__GetFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__GetFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "return", &(((WS1__GetFileResponse*)a)->return_), "xsd:base64Binary"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__GetFileResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__GetFileResponse, 0, sizeof(WS1__GetFileResponse), 0, soap_copy_WS1__GetFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__GetFileResponse * SOAP_FMAC6 soap_new_WS1__GetFileResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__GetFileResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__GetFileResponse(struct soap *soap, WS1__GetFileResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__GetFileResponse * SOAP_FMAC4 soap_instantiate_WS1__GetFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__GetFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__GetFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__GetFileResponse;
		if (size)
			*size = sizeof(WS1__GetFileResponse);
		((WS1__GetFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__GetFileResponse[n];
		if (size)
			*size = n * sizeof(WS1__GetFileResponse);
		for (int i = 0; i < n; i++)
			((WS1__GetFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__GetFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__GetFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__GetFileResponse %p -> %p\n", q, p));
	*(WS1__GetFileResponse*)p = *(WS1__GetFileResponse*)q;
}

void WS1__GetFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__GetFile*)this)->requestFileName);
	/* transient soap skipped */
}

void WS1__GetFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__GetFile*)this)->requestFileName = NULL;
	/* transient soap skipped */
}

int WS1__GetFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__GetFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__GetFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__GetFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__GetFile(struct soap *soap, const char *tag, int id, const WS1__GetFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__GetFile), type);
	soap_out_PointerTostd__wstring(soap, "requestFileName", -1, &(((WS1__GetFile*)a)->requestFileName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__GetFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__GetFile(soap, this, tag, type);
}

SOAP_FMAC3 WS1__GetFile * SOAP_FMAC4 soap_get_WS1__GetFile(struct soap *soap, WS1__GetFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__GetFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__GetFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__GetFile(soap, tag, this, type);
}

SOAP_FMAC3 WS1__GetFile * SOAP_FMAC4 soap_in_WS1__GetFile(struct soap *soap, const char *tag, WS1__GetFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__GetFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__GetFile, sizeof(WS1__GetFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__GetFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__GetFile *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_requestFileName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "requestFileName", &(((WS1__GetFile*)a)->requestFileName), "xsd:string"))
				{	soap_flag_requestFileName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__GetFile *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__GetFile, 0, sizeof(WS1__GetFile), 0, soap_copy_WS1__GetFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__GetFile * SOAP_FMAC6 soap_new_WS1__GetFile(struct soap *soap, int n)
{	return soap_instantiate_WS1__GetFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__GetFile(struct soap *soap, WS1__GetFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__GetFile * SOAP_FMAC4 soap_instantiate_WS1__GetFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__GetFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__GetFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__GetFile;
		if (size)
			*size = sizeof(WS1__GetFile);
		((WS1__GetFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__GetFile[n];
		if (size)
			*size = n * sizeof(WS1__GetFile);
		for (int i = 0; i < n; i++)
			((WS1__GetFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__GetFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__GetFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__GetFile %p -> %p\n", q, p));
	*(WS1__GetFile*)p = *(WS1__GetFile*)q;
}

void WS1__DeleteFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__DeleteFileResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__DeleteFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__DeleteFileResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__DeleteFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__DeleteFileResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__DeleteFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__DeleteFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__DeleteFileResponse(struct soap *soap, const char *tag, int id, const WS1__DeleteFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__DeleteFileResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__DeleteFileResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__DeleteFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__DeleteFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__DeleteFileResponse * SOAP_FMAC4 soap_get_WS1__DeleteFileResponse(struct soap *soap, WS1__DeleteFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__DeleteFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__DeleteFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__DeleteFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__DeleteFileResponse * SOAP_FMAC4 soap_in_WS1__DeleteFileResponse(struct soap *soap, const char *tag, WS1__DeleteFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__DeleteFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__DeleteFileResponse, sizeof(WS1__DeleteFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__DeleteFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__DeleteFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__DeleteFileResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__DeleteFileResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__DeleteFileResponse, 0, sizeof(WS1__DeleteFileResponse), 0, soap_copy_WS1__DeleteFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__DeleteFileResponse * SOAP_FMAC6 soap_new_WS1__DeleteFileResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__DeleteFileResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__DeleteFileResponse(struct soap *soap, WS1__DeleteFileResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__DeleteFileResponse * SOAP_FMAC4 soap_instantiate_WS1__DeleteFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__DeleteFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__DeleteFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__DeleteFileResponse;
		if (size)
			*size = sizeof(WS1__DeleteFileResponse);
		((WS1__DeleteFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__DeleteFileResponse[n];
		if (size)
			*size = n * sizeof(WS1__DeleteFileResponse);
		for (int i = 0; i < n; i++)
			((WS1__DeleteFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__DeleteFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__DeleteFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__DeleteFileResponse %p -> %p\n", q, p));
	*(WS1__DeleteFileResponse*)p = *(WS1__DeleteFileResponse*)q;
}

void WS1__DeleteFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__DeleteFile*)this)->fileName);
	/* transient soap skipped */
}

void WS1__DeleteFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__DeleteFile*)this)->fileName = NULL;
	/* transient soap skipped */
}

int WS1__DeleteFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__DeleteFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__DeleteFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__DeleteFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__DeleteFile(struct soap *soap, const char *tag, int id, const WS1__DeleteFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__DeleteFile), type);
	soap_out_PointerTostd__wstring(soap, "fileName", -1, &(((WS1__DeleteFile*)a)->fileName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__DeleteFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__DeleteFile(soap, this, tag, type);
}

SOAP_FMAC3 WS1__DeleteFile * SOAP_FMAC4 soap_get_WS1__DeleteFile(struct soap *soap, WS1__DeleteFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__DeleteFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__DeleteFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__DeleteFile(soap, tag, this, type);
}

SOAP_FMAC3 WS1__DeleteFile * SOAP_FMAC4 soap_in_WS1__DeleteFile(struct soap *soap, const char *tag, WS1__DeleteFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__DeleteFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__DeleteFile, sizeof(WS1__DeleteFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__DeleteFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__DeleteFile *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_fileName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fileName", &(((WS1__DeleteFile*)a)->fileName), "xsd:string"))
				{	soap_flag_fileName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__DeleteFile *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__DeleteFile, 0, sizeof(WS1__DeleteFile), 0, soap_copy_WS1__DeleteFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__DeleteFile * SOAP_FMAC6 soap_new_WS1__DeleteFile(struct soap *soap, int n)
{	return soap_instantiate_WS1__DeleteFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__DeleteFile(struct soap *soap, WS1__DeleteFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__DeleteFile * SOAP_FMAC4 soap_instantiate_WS1__DeleteFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__DeleteFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__DeleteFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__DeleteFile;
		if (size)
			*size = sizeof(WS1__DeleteFile);
		((WS1__DeleteFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__DeleteFile[n];
		if (size)
			*size = n * sizeof(WS1__DeleteFile);
		for (int i = 0; i < n; i++)
			((WS1__DeleteFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__DeleteFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__DeleteFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__DeleteFile %p -> %p\n", q, p));
	*(WS1__DeleteFile*)p = *(WS1__DeleteFile*)q;
}

void WS1__SOF_USCOREValidateCertResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREValidateCertResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((WS1__SOF_USCOREValidateCertResponse*)this)->return_);
	/* transient soap skipped */
}

int WS1__SOF_USCOREValidateCertResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREValidateCertResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREValidateCertResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREValidateCertResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREValidateCertResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse), type);
	soap_out_int(soap, "return", -1, &(((WS1__SOF_USCOREValidateCertResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREValidateCertResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREValidateCertResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCertResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREValidateCertResponse(struct soap *soap, WS1__SOF_USCOREValidateCertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREValidateCertResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREValidateCertResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREValidateCertResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCertResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREValidateCertResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREValidateCertResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREValidateCertResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse, sizeof(WS1__SOF_USCOREValidateCertResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREValidateCertResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &(((WS1__SOF_USCOREValidateCertResponse*)a)->return_), "xsd:int"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREValidateCertResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse, 0, sizeof(WS1__SOF_USCOREValidateCertResponse), 0, soap_copy_WS1__SOF_USCOREValidateCertResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREValidateCertResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREValidateCertResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREValidateCertResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREValidateCertResponse(struct soap *soap, WS1__SOF_USCOREValidateCertResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCertResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREValidateCertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREValidateCertResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREValidateCertResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREValidateCertResponse);
		((WS1__SOF_USCOREValidateCertResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREValidateCertResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREValidateCertResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREValidateCertResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREValidateCertResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREValidateCertResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREValidateCertResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREValidateCertResponse*)p = *(WS1__SOF_USCOREValidateCertResponse*)q;
}

void WS1__SOF_USCOREValidateCert::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREValidateCert*)this)->base64EncodeCert);
	/* transient soap skipped */
}

void WS1__SOF_USCOREValidateCert::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREValidateCert*)this)->base64EncodeCert = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREValidateCert::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREValidateCert);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREValidateCert::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREValidateCert(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREValidateCert *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREValidateCert), type);
	soap_out_PointerTostd__wstring(soap, "base64EncodeCert", -1, &(((WS1__SOF_USCOREValidateCert*)a)->base64EncodeCert), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREValidateCert::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREValidateCert(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_get_WS1__SOF_USCOREValidateCert(struct soap *soap, WS1__SOF_USCOREValidateCert *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREValidateCert(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREValidateCert::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREValidateCert(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_in_WS1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, WS1__SOF_USCOREValidateCert *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREValidateCert *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREValidateCert, sizeof(WS1__SOF_USCOREValidateCert), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREValidateCert)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREValidateCert *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_base64EncodeCert1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "base64EncodeCert", &(((WS1__SOF_USCOREValidateCert*)a)->base64EncodeCert), "xsd:string"))
				{	soap_flag_base64EncodeCert1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREValidateCert *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREValidateCert, 0, sizeof(WS1__SOF_USCOREValidateCert), 0, soap_copy_WS1__SOF_USCOREValidateCert);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREValidateCert * SOAP_FMAC6 soap_new_WS1__SOF_USCOREValidateCert(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREValidateCert(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREValidateCert(struct soap *soap, WS1__SOF_USCOREValidateCert *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREValidateCert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREValidateCert(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREValidateCert, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREValidateCert;
		if (size)
			*size = sizeof(WS1__SOF_USCOREValidateCert);
		((WS1__SOF_USCOREValidateCert*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREValidateCert[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREValidateCert);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREValidateCert*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREValidateCert*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREValidateCert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREValidateCert %p -> %p\n", q, p));
	*(WS1__SOF_USCOREValidateCert*)p = *(WS1__SOF_USCOREValidateCert*)q;
}

void WS1__SOF_USCORECreateTimeStampResponseResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORECreateTimeStampResponseResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORECreateTimeStampResponseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORECreateTimeStampResponseResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORECreateTimeStampResponseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORECreateTimeStampResponseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORECreateTimeStampResponseResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORECreateTimeStampResponseResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORECreateTimeStampResponseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponseResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORECreateTimeStampResponseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponseResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const char *tag, WS1__SOF_USCORECreateTimeStampResponseResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORECreateTimeStampResponseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse, sizeof(WS1__SOF_USCORECreateTimeStampResponseResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORECreateTimeStampResponseResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORECreateTimeStampResponseResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORECreateTimeStampResponseResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse, 0, sizeof(WS1__SOF_USCORECreateTimeStampResponseResponse), 0, soap_copy_WS1__SOF_USCORECreateTimeStampResponseResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORECreateTimeStampResponseResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponseResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORECreateTimeStampResponseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORECreateTimeStampResponseResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORECreateTimeStampResponseResponse);
		((WS1__SOF_USCORECreateTimeStampResponseResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORECreateTimeStampResponseResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORECreateTimeStampResponseResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORECreateTimeStampResponseResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORECreateTimeStampResponseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORECreateTimeStampResponseResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORECreateTimeStampResponseResponse*)p = *(WS1__SOF_USCORECreateTimeStampResponseResponse*)q;
}

void WS1__SOF_USCORECreateTimeStampResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORECreateTimeStampResponse*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCORECreateTimeStampResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORECreateTimeStampResponse*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORECreateTimeStampResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORECreateTimeStampResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORECreateTimeStampResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORECreateTimeStampResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse), type);
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCORECreateTimeStampResponse*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORECreateTimeStampResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORECreateTimeStampResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORECreateTimeStampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORECreateTimeStampResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORECreateTimeStampResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, WS1__SOF_USCORECreateTimeStampResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORECreateTimeStampResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse, sizeof(WS1__SOF_USCORECreateTimeStampResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORECreateTimeStampResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCORECreateTimeStampResponse*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORECreateTimeStampResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse, 0, sizeof(WS1__SOF_USCORECreateTimeStampResponse), 0, soap_copy_WS1__SOF_USCORECreateTimeStampResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORECreateTimeStampResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORECreateTimeStampResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORECreateTimeStampResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORECreateTimeStampResponse);
		((WS1__SOF_USCORECreateTimeStampResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORECreateTimeStampResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORECreateTimeStampResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORECreateTimeStampResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORECreateTimeStampResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORECreateTimeStampResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORECreateTimeStampResponse*)p = *(WS1__SOF_USCORECreateTimeStampResponse*)q;
}

void WS1__SOF_USCOREGetEncryptMethodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetEncryptMethodResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetEncryptMethodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetEncryptMethodResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetEncryptMethodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetEncryptMethodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetEncryptMethodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetEncryptMethodResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGetEncryptMethodResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetEncryptMethodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetEncryptMethodResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethodResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCOREGetEncryptMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetEncryptMethodResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetEncryptMethodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetEncryptMethodResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethodResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetEncryptMethodResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetEncryptMethodResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse, sizeof(WS1__SOF_USCOREGetEncryptMethodResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetEncryptMethodResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGetEncryptMethodResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetEncryptMethodResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse, 0, sizeof(WS1__SOF_USCOREGetEncryptMethodResponse), 0, soap_copy_WS1__SOF_USCOREGetEncryptMethodResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetEncryptMethodResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetEncryptMethodResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCOREGetEncryptMethodResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethodResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetEncryptMethodResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetEncryptMethodResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetEncryptMethodResponse);
		((WS1__SOF_USCOREGetEncryptMethodResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetEncryptMethodResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetEncryptMethodResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetEncryptMethodResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetEncryptMethodResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetEncryptMethodResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetEncryptMethodResponse*)p = *(WS1__SOF_USCOREGetEncryptMethodResponse*)q;
}

void WS1__SOF_USCOREGetEncryptMethod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetEncryptMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetEncryptMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetEncryptMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetEncryptMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetEncryptMethod *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetEncryptMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetEncryptMethod(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, WS1__SOF_USCOREGetEncryptMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetEncryptMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetEncryptMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetEncryptMethod(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, WS1__SOF_USCOREGetEncryptMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetEncryptMethod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod, sizeof(WS1__SOF_USCOREGetEncryptMethod), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetEncryptMethod *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetEncryptMethod *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod, 0, sizeof(WS1__SOF_USCOREGetEncryptMethod), 0, soap_copy_WS1__SOF_USCOREGetEncryptMethod);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetEncryptMethod * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetEncryptMethod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, WS1__SOF_USCOREGetEncryptMethod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetEncryptMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetEncryptMethod;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetEncryptMethod);
		((WS1__SOF_USCOREGetEncryptMethod*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetEncryptMethod[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetEncryptMethod);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetEncryptMethod*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetEncryptMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetEncryptMethod %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetEncryptMethod*)p = *(WS1__SOF_USCOREGetEncryptMethod*)q;
}

void WS1__SOF_USCORECreateTimeStampRequestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORECreateTimeStampRequestResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORECreateTimeStampRequestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORECreateTimeStampRequestResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORECreateTimeStampRequestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORECreateTimeStampRequestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORECreateTimeStampRequestResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORECreateTimeStampRequestResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORECreateTimeStampRequestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequestResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORECreateTimeStampRequestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequestResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const char *tag, WS1__SOF_USCORECreateTimeStampRequestResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORECreateTimeStampRequestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse, sizeof(WS1__SOF_USCORECreateTimeStampRequestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORECreateTimeStampRequestResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORECreateTimeStampRequestResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORECreateTimeStampRequestResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse, 0, sizeof(WS1__SOF_USCORECreateTimeStampRequestResponse), 0, soap_copy_WS1__SOF_USCORECreateTimeStampRequestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORECreateTimeStampRequestResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequestResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORECreateTimeStampRequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORECreateTimeStampRequestResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORECreateTimeStampRequestResponse);
		((WS1__SOF_USCORECreateTimeStampRequestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORECreateTimeStampRequestResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORECreateTimeStampRequestResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORECreateTimeStampRequestResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORECreateTimeStampRequestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORECreateTimeStampRequestResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORECreateTimeStampRequestResponse*)p = *(WS1__SOF_USCORECreateTimeStampRequestResponse*)q;
}

void WS1__SOF_USCORECreateTimeStampRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORECreateTimeStampRequest*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCORECreateTimeStampRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORECreateTimeStampRequest*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORECreateTimeStampRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORECreateTimeStampRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORECreateTimeStampRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORECreateTimeStampRequest *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest), type);
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCORECreateTimeStampRequest*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORECreateTimeStampRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORECreateTimeStampRequest(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_get_WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORECreateTimeStampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORECreateTimeStampRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORECreateTimeStampRequest(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_in_WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, WS1__SOF_USCORECreateTimeStampRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORECreateTimeStampRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest, sizeof(WS1__SOF_USCORECreateTimeStampRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORECreateTimeStampRequest *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCORECreateTimeStampRequest*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORECreateTimeStampRequest *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest, 0, sizeof(WS1__SOF_USCORECreateTimeStampRequest), 0, soap_copy_WS1__SOF_USCORECreateTimeStampRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC6 soap_new_WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORECreateTimeStampRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORECreateTimeStampRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORECreateTimeStampRequest;
		if (size)
			*size = sizeof(WS1__SOF_USCORECreateTimeStampRequest);
		((WS1__SOF_USCORECreateTimeStampRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORECreateTimeStampRequest[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORECreateTimeStampRequest);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORECreateTimeStampRequest*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORECreateTimeStampRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORECreateTimeStampRequest %p -> %p\n", q, p));
	*(WS1__SOF_USCORECreateTimeStampRequest*)p = *(WS1__SOF_USCORECreateTimeStampRequest*)q;
}

void WS1__SOF_USCORESetEncryptMethodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESetEncryptMethodResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORESetEncryptMethodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESetEncryptMethodResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESetEncryptMethodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESetEncryptMethodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESetEncryptMethodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESetEncryptMethodResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORESetEncryptMethodResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESetEncryptMethodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESetEncryptMethodResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethodResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCORESetEncryptMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESetEncryptMethodResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESetEncryptMethodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESetEncryptMethodResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethodResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESetEncryptMethodResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESetEncryptMethodResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse, sizeof(WS1__SOF_USCORESetEncryptMethodResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESetEncryptMethodResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORESetEncryptMethodResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetEncryptMethodResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse, 0, sizeof(WS1__SOF_USCORESetEncryptMethodResponse), 0, soap_copy_WS1__SOF_USCORESetEncryptMethodResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESetEncryptMethodResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESetEncryptMethodResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCORESetEncryptMethodResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethodResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESetEncryptMethodResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESetEncryptMethodResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORESetEncryptMethodResponse);
		((WS1__SOF_USCORESetEncryptMethodResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESetEncryptMethodResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESetEncryptMethodResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESetEncryptMethodResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESetEncryptMethodResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESetEncryptMethodResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORESetEncryptMethodResponse*)p = *(WS1__SOF_USCORESetEncryptMethodResponse*)q;
}

void WS1__SOF_USCORESetEncryptMethod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCORESetEncryptMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((WS1__SOF_USCORESetEncryptMethod*)this)->encryptMethod);
	/* transient soap skipped */
}

int WS1__SOF_USCORESetEncryptMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESetEncryptMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESetEncryptMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESetEncryptMethod *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod), type);
	soap_out_int(soap, "encryptMethod", -1, &(((WS1__SOF_USCORESetEncryptMethod*)a)->encryptMethod), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESetEncryptMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESetEncryptMethod(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_get_WS1__SOF_USCORESetEncryptMethod(struct soap *soap, WS1__SOF_USCORESetEncryptMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESetEncryptMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESetEncryptMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESetEncryptMethod(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_in_WS1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, WS1__SOF_USCORESetEncryptMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESetEncryptMethod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod, sizeof(WS1__SOF_USCORESetEncryptMethod), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESetEncryptMethod *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_encryptMethod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_encryptMethod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "encryptMethod", &(((WS1__SOF_USCORESetEncryptMethod*)a)->encryptMethod), "xsd:int"))
				{	soap_flag_encryptMethod1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_encryptMethod1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetEncryptMethod *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod, 0, sizeof(WS1__SOF_USCORESetEncryptMethod), 0, soap_copy_WS1__SOF_USCORESetEncryptMethod);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESetEncryptMethod * SOAP_FMAC6 soap_new_WS1__SOF_USCORESetEncryptMethod(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESetEncryptMethod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESetEncryptMethod(struct soap *soap, WS1__SOF_USCORESetEncryptMethod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESetEncryptMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESetEncryptMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESetEncryptMethod;
		if (size)
			*size = sizeof(WS1__SOF_USCORESetEncryptMethod);
		((WS1__SOF_USCORESetEncryptMethod*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESetEncryptMethod[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESetEncryptMethod);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESetEncryptMethod*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESetEncryptMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESetEncryptMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESetEncryptMethod %p -> %p\n", q, p));
	*(WS1__SOF_USCORESetEncryptMethod*)p = *(WS1__SOF_USCORESetEncryptMethod*)q;
}

void WS1__SOF_USCOREGetSignMethodResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetSignMethodResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetSignMethodResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetSignMethodResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetSignMethodResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetSignMethodResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetSignMethodResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetSignMethodResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGetSignMethodResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetSignMethodResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetSignMethodResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethodResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, WS1__SOF_USCOREGetSignMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetSignMethodResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetSignMethodResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetSignMethodResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethodResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetSignMethodResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetSignMethodResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse, sizeof(WS1__SOF_USCOREGetSignMethodResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetSignMethodResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGetSignMethodResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetSignMethodResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse, 0, sizeof(WS1__SOF_USCOREGetSignMethodResponse), 0, soap_copy_WS1__SOF_USCOREGetSignMethodResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetSignMethodResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetSignMethodResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, WS1__SOF_USCOREGetSignMethodResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethodResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetSignMethodResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetSignMethodResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetSignMethodResponse);
		((WS1__SOF_USCOREGetSignMethodResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetSignMethodResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetSignMethodResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetSignMethodResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetSignMethodResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetSignMethodResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetSignMethodResponse*)p = *(WS1__SOF_USCOREGetSignMethodResponse*)q;
}

void WS1__SOF_USCOREGetSignMethod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetSignMethod::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetSignMethod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetSignMethod);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetSignMethod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetSignMethod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetSignMethod *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetSignMethod), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetSignMethod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetSignMethod(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetSignMethod(struct soap *soap, WS1__SOF_USCOREGetSignMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetSignMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetSignMethod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetSignMethod(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, WS1__SOF_USCOREGetSignMethod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetSignMethod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetSignMethod, sizeof(WS1__SOF_USCOREGetSignMethod), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetSignMethod)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetSignMethod *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetSignMethod *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetSignMethod, 0, sizeof(WS1__SOF_USCOREGetSignMethod), 0, soap_copy_WS1__SOF_USCOREGetSignMethod);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetSignMethod * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetSignMethod(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetSignMethod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetSignMethod(struct soap *soap, WS1__SOF_USCOREGetSignMethod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetSignMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetSignMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetSignMethod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetSignMethod;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetSignMethod);
		((WS1__SOF_USCOREGetSignMethod*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetSignMethod[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetSignMethod);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetSignMethod*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetSignMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetSignMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetSignMethod %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetSignMethod*)p = *(WS1__SOF_USCOREGetSignMethod*)q;
}

void WS1__SOF_USCORESetWebAppNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESetWebAppNameResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORESetWebAppNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESetWebAppNameResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESetWebAppNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESetWebAppNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESetWebAppNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESetWebAppNameResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORESetWebAppNameResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESetWebAppNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESetWebAppNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppNameResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, WS1__SOF_USCORESetWebAppNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESetWebAppNameResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESetWebAppNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESetWebAppNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppNameResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESetWebAppNameResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESetWebAppNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse, sizeof(WS1__SOF_USCORESetWebAppNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESetWebAppNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORESetWebAppNameResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetWebAppNameResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse, 0, sizeof(WS1__SOF_USCORESetWebAppNameResponse), 0, soap_copy_WS1__SOF_USCORESetWebAppNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESetWebAppNameResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESetWebAppNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, WS1__SOF_USCORESetWebAppNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppNameResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESetWebAppNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESetWebAppNameResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORESetWebAppNameResponse);
		((WS1__SOF_USCORESetWebAppNameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESetWebAppNameResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESetWebAppNameResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESetWebAppNameResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESetWebAppNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESetWebAppNameResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORESetWebAppNameResponse*)p = *(WS1__SOF_USCORESetWebAppNameResponse*)q;
}

void WS1__SOF_USCORESetWebAppName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESetWebAppName*)this)->webAppName);
	/* transient soap skipped */
}

void WS1__SOF_USCORESetWebAppName::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESetWebAppName*)this)->webAppName = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESetWebAppName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESetWebAppName);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESetWebAppName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESetWebAppName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESetWebAppName *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESetWebAppName), type);
	soap_out_PointerTostd__wstring(soap, "webAppName", -1, &(((WS1__SOF_USCORESetWebAppName*)a)->webAppName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESetWebAppName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESetWebAppName(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_get_WS1__SOF_USCORESetWebAppName(struct soap *soap, WS1__SOF_USCORESetWebAppName *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESetWebAppName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESetWebAppName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESetWebAppName(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_in_WS1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, WS1__SOF_USCORESetWebAppName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESetWebAppName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESetWebAppName, sizeof(WS1__SOF_USCORESetWebAppName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESetWebAppName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESetWebAppName *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_webAppName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_webAppName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "webAppName", &(((WS1__SOF_USCORESetWebAppName*)a)->webAppName), "xsd:string"))
				{	soap_flag_webAppName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetWebAppName *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESetWebAppName, 0, sizeof(WS1__SOF_USCORESetWebAppName), 0, soap_copy_WS1__SOF_USCORESetWebAppName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESetWebAppName * SOAP_FMAC6 soap_new_WS1__SOF_USCORESetWebAppName(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESetWebAppName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESetWebAppName(struct soap *soap, WS1__SOF_USCORESetWebAppName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESetWebAppName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESetWebAppName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESetWebAppName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESetWebAppName;
		if (size)
			*size = sizeof(WS1__SOF_USCORESetWebAppName);
		((WS1__SOF_USCORESetWebAppName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESetWebAppName[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESetWebAppName);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESetWebAppName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESetWebAppName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESetWebAppName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESetWebAppName %p -> %p\n", q, p));
	*(WS1__SOF_USCORESetWebAppName*)p = *(WS1__SOF_USCORESetWebAppName*)q;
}

void WS1__SOF_USCOREGenRandomResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGenRandomResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGenRandomResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGenRandomResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGenRandomResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGenRandomResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGenRandomResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGenRandomResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGenRandomResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGenRandomResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGenRandomResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGenRandomResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandomResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGenRandomResponse(struct soap *soap, WS1__SOF_USCOREGenRandomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGenRandomResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGenRandomResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGenRandomResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandomResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGenRandomResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGenRandomResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGenRandomResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse, sizeof(WS1__SOF_USCOREGenRandomResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGenRandomResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGenRandomResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGenRandomResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse, 0, sizeof(WS1__SOF_USCOREGenRandomResponse), 0, soap_copy_WS1__SOF_USCOREGenRandomResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGenRandomResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGenRandomResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGenRandomResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGenRandomResponse(struct soap *soap, WS1__SOF_USCOREGenRandomResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandomResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGenRandomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGenRandomResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGenRandomResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGenRandomResponse);
		((WS1__SOF_USCOREGenRandomResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGenRandomResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGenRandomResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGenRandomResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGenRandomResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGenRandomResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGenRandomResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGenRandomResponse*)p = *(WS1__SOF_USCOREGenRandomResponse*)q;
}

void WS1__SOF_USCOREGenRandom::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREGenRandom::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((WS1__SOF_USCOREGenRandom*)this)->len);
	/* transient soap skipped */
}

int WS1__SOF_USCOREGenRandom::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGenRandom);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGenRandom::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGenRandom(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGenRandom *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGenRandom), type);
	soap_out_int(soap, "len", -1, &(((WS1__SOF_USCOREGenRandom*)a)->len), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGenRandom::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGenRandom(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGenRandom(struct soap *soap, WS1__SOF_USCOREGenRandom *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGenRandom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGenRandom::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGenRandom(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, WS1__SOF_USCOREGenRandom *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGenRandom *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGenRandom, sizeof(WS1__SOF_USCOREGenRandom), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGenRandom)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGenRandom *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_len1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_len1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "len", &(((WS1__SOF_USCOREGenRandom*)a)->len), "xsd:int"))
				{	soap_flag_len1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_len1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGenRandom *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGenRandom, 0, sizeof(WS1__SOF_USCOREGenRandom), 0, soap_copy_WS1__SOF_USCOREGenRandom);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGenRandom * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGenRandom(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGenRandom(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGenRandom(struct soap *soap, WS1__SOF_USCOREGenRandom *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGenRandom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGenRandom(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGenRandom, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGenRandom;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGenRandom);
		((WS1__SOF_USCOREGenRandom*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGenRandom[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGenRandom);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGenRandom*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGenRandom*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGenRandom(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGenRandom %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGenRandom*)p = *(WS1__SOF_USCOREGenRandom*)q;
}

void WS1__SOF_USCOREPriKeyDecryptResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREPriKeyDecryptResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREPriKeyDecryptResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREPriKeyDecryptResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREPriKeyDecryptResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREPriKeyDecryptResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREPriKeyDecryptResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREPriKeyDecryptResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREPriKeyDecryptResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREPriKeyDecryptResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREPriKeyDecryptResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecryptResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, WS1__SOF_USCOREPriKeyDecryptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREPriKeyDecryptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREPriKeyDecryptResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREPriKeyDecryptResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecryptResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREPriKeyDecryptResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREPriKeyDecryptResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse, sizeof(WS1__SOF_USCOREPriKeyDecryptResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREPriKeyDecryptResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREPriKeyDecryptResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREPriKeyDecryptResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse, 0, sizeof(WS1__SOF_USCOREPriKeyDecryptResponse), 0, soap_copy_WS1__SOF_USCOREPriKeyDecryptResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREPriKeyDecryptResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREPriKeyDecryptResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, WS1__SOF_USCOREPriKeyDecryptResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecryptResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREPriKeyDecryptResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREPriKeyDecryptResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREPriKeyDecryptResponse);
		((WS1__SOF_USCOREPriKeyDecryptResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREPriKeyDecryptResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREPriKeyDecryptResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREPriKeyDecryptResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREPriKeyDecryptResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREPriKeyDecryptResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREPriKeyDecryptResponse*)p = *(WS1__SOF_USCOREPriKeyDecryptResponse*)q;
}

void WS1__SOF_USCOREPriKeyDecrypt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREPriKeyDecrypt*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREPriKeyDecrypt::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREPriKeyDecrypt*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREPriKeyDecrypt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREPriKeyDecrypt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREPriKeyDecrypt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREPriKeyDecrypt *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt), type);
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCOREPriKeyDecrypt*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREPriKeyDecrypt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREPriKeyDecrypt(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_get_WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, WS1__SOF_USCOREPriKeyDecrypt *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREPriKeyDecrypt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREPriKeyDecrypt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREPriKeyDecrypt(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_in_WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, WS1__SOF_USCOREPriKeyDecrypt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREPriKeyDecrypt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt, sizeof(WS1__SOF_USCOREPriKeyDecrypt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREPriKeyDecrypt *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCOREPriKeyDecrypt*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREPriKeyDecrypt *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt, 0, sizeof(WS1__SOF_USCOREPriKeyDecrypt), 0, soap_copy_WS1__SOF_USCOREPriKeyDecrypt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC6 soap_new_WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREPriKeyDecrypt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, WS1__SOF_USCOREPriKeyDecrypt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREPriKeyDecrypt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREPriKeyDecrypt;
		if (size)
			*size = sizeof(WS1__SOF_USCOREPriKeyDecrypt);
		((WS1__SOF_USCOREPriKeyDecrypt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREPriKeyDecrypt[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREPriKeyDecrypt);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREPriKeyDecrypt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREPriKeyDecrypt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREPriKeyDecrypt %p -> %p\n", q, p));
	*(WS1__SOF_USCOREPriKeyDecrypt*)p = *(WS1__SOF_USCOREPriKeyDecrypt*)q;
}

void WS1__sofSecurityEngineDeal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__sofSecurityEngineDeal*)this)->alias);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__sofSecurityEngineDeal*)this)->encryption);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__sofSecurityEngineDeal*)this)->sessionID);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__sofSecurityEngineDeal*)this)->signature);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__sofSecurityEngineDeal*)this)->valcrl);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__sofSecurityEngineDeal*)this)->valpath);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__sofSecurityEngineDeal*)this)->valtime);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__sofSecurityEngineDeal*)this)->webAppName);
	/* transient soap skipped */
}

void WS1__sofSecurityEngineDeal::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__sofSecurityEngineDeal*)this)->alias = NULL;
	((WS1__sofSecurityEngineDeal*)this)->encryption = NULL;
	((WS1__sofSecurityEngineDeal*)this)->sessionID = NULL;
	((WS1__sofSecurityEngineDeal*)this)->signature = NULL;
	((WS1__sofSecurityEngineDeal*)this)->valcrl = NULL;
	((WS1__sofSecurityEngineDeal*)this)->valpath = NULL;
	((WS1__sofSecurityEngineDeal*)this)->valtime = NULL;
	((WS1__sofSecurityEngineDeal*)this)->webAppName = NULL;
	/* transient soap skipped */
}

int WS1__sofSecurityEngineDeal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__sofSecurityEngineDeal);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__sofSecurityEngineDeal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__sofSecurityEngineDeal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__sofSecurityEngineDeal(struct soap *soap, const char *tag, int id, const WS1__sofSecurityEngineDeal *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__sofSecurityEngineDeal), type);
	soap_out_PointerTostd__wstring(soap, "alias", -1, &(((WS1__sofSecurityEngineDeal*)a)->alias), "");
	soap_out_PointerTostd__wstring(soap, "encryption", -1, &(((WS1__sofSecurityEngineDeal*)a)->encryption), "");
	soap_out_PointerTostd__wstring(soap, "sessionID", -1, &(((WS1__sofSecurityEngineDeal*)a)->sessionID), "");
	soap_out_PointerTostd__wstring(soap, "signature", -1, &(((WS1__sofSecurityEngineDeal*)a)->signature), "");
	soap_out_PointerTostd__wstring(soap, "valcrl", -1, &(((WS1__sofSecurityEngineDeal*)a)->valcrl), "");
	soap_out_PointerTostd__wstring(soap, "valpath", -1, &(((WS1__sofSecurityEngineDeal*)a)->valpath), "");
	soap_out_PointerTostd__wstring(soap, "valtime", -1, &(((WS1__sofSecurityEngineDeal*)a)->valtime), "");
	soap_out_PointerTostd__wstring(soap, "webAppName", -1, &(((WS1__sofSecurityEngineDeal*)a)->webAppName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__sofSecurityEngineDeal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__sofSecurityEngineDeal(soap, this, tag, type);
}

SOAP_FMAC3 WS1__sofSecurityEngineDeal * SOAP_FMAC4 soap_get_WS1__sofSecurityEngineDeal(struct soap *soap, WS1__sofSecurityEngineDeal *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__sofSecurityEngineDeal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__sofSecurityEngineDeal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__sofSecurityEngineDeal(soap, tag, this, type);
}

SOAP_FMAC3 WS1__sofSecurityEngineDeal * SOAP_FMAC4 soap_in_WS1__sofSecurityEngineDeal(struct soap *soap, const char *tag, WS1__sofSecurityEngineDeal *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__sofSecurityEngineDeal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__sofSecurityEngineDeal, sizeof(WS1__sofSecurityEngineDeal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__sofSecurityEngineDeal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__sofSecurityEngineDeal *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alias1 = 1, soap_flag_encryption1 = 1, soap_flag_sessionID1 = 1, soap_flag_signature1 = 1, soap_flag_valcrl1 = 1, soap_flag_valpath1 = 1, soap_flag_valtime1 = 1, soap_flag_webAppName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "alias", &(((WS1__sofSecurityEngineDeal*)a)->alias), "xsd:string"))
				{	soap_flag_alias1--;
					continue;
				}
			if (soap_flag_encryption1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "encryption", &(((WS1__sofSecurityEngineDeal*)a)->encryption), "xsd:string"))
				{	soap_flag_encryption1--;
					continue;
				}
			if (soap_flag_sessionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "sessionID", &(((WS1__sofSecurityEngineDeal*)a)->sessionID), "xsd:string"))
				{	soap_flag_sessionID1--;
					continue;
				}
			if (soap_flag_signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "signature", &(((WS1__sofSecurityEngineDeal*)a)->signature), "xsd:string"))
				{	soap_flag_signature1--;
					continue;
				}
			if (soap_flag_valcrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "valcrl", &(((WS1__sofSecurityEngineDeal*)a)->valcrl), "xsd:string"))
				{	soap_flag_valcrl1--;
					continue;
				}
			if (soap_flag_valpath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "valpath", &(((WS1__sofSecurityEngineDeal*)a)->valpath), "xsd:string"))
				{	soap_flag_valpath1--;
					continue;
				}
			if (soap_flag_valtime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "valtime", &(((WS1__sofSecurityEngineDeal*)a)->valtime), "xsd:string"))
				{	soap_flag_valtime1--;
					continue;
				}
			if (soap_flag_webAppName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "webAppName", &(((WS1__sofSecurityEngineDeal*)a)->webAppName), "xsd:string"))
				{	soap_flag_webAppName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__sofSecurityEngineDeal *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__sofSecurityEngineDeal, 0, sizeof(WS1__sofSecurityEngineDeal), 0, soap_copy_WS1__sofSecurityEngineDeal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__sofSecurityEngineDeal * SOAP_FMAC6 soap_new_WS1__sofSecurityEngineDeal(struct soap *soap, int n)
{	return soap_instantiate_WS1__sofSecurityEngineDeal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__sofSecurityEngineDeal(struct soap *soap, WS1__sofSecurityEngineDeal *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__sofSecurityEngineDeal * SOAP_FMAC4 soap_instantiate_WS1__sofSecurityEngineDeal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__sofSecurityEngineDeal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__sofSecurityEngineDeal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__sofSecurityEngineDeal;
		if (size)
			*size = sizeof(WS1__sofSecurityEngineDeal);
		((WS1__sofSecurityEngineDeal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__sofSecurityEngineDeal[n];
		if (size)
			*size = n * sizeof(WS1__sofSecurityEngineDeal);
		for (int i = 0; i < n; i++)
			((WS1__sofSecurityEngineDeal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__sofSecurityEngineDeal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__sofSecurityEngineDeal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__sofSecurityEngineDeal %p -> %p\n", q, p));
	*(WS1__sofSecurityEngineDeal*)p = *(WS1__sofSecurityEngineDeal*)q;
}

void WS1__SOF_USCOREGetInstanceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__sofSecurityEngineDeal(soap, &((WS1__SOF_USCOREGetInstanceResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetInstanceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetInstanceResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetInstanceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetInstanceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetInstanceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetInstanceResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetInstanceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse), type);
	soap_out_PointerToWS1__sofSecurityEngineDeal(soap, "return", -1, &(((WS1__SOF_USCOREGetInstanceResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetInstanceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetInstanceResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstanceResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetInstanceResponse(struct soap *soap, WS1__SOF_USCOREGetInstanceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetInstanceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetInstanceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetInstanceResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstanceResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetInstanceResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetInstanceResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetInstanceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse, sizeof(WS1__SOF_USCOREGetInstanceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetInstanceResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__sofSecurityEngineDeal(soap, "return", &(((WS1__SOF_USCOREGetInstanceResponse*)a)->return_), "WS1:sofSecurityEngineDeal"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetInstanceResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse, 0, sizeof(WS1__SOF_USCOREGetInstanceResponse), 0, soap_copy_WS1__SOF_USCOREGetInstanceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetInstanceResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetInstanceResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetInstanceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetInstanceResponse(struct soap *soap, WS1__SOF_USCOREGetInstanceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstanceResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetInstanceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetInstanceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetInstanceResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetInstanceResponse);
		((WS1__SOF_USCOREGetInstanceResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetInstanceResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetInstanceResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetInstanceResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetInstanceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetInstanceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetInstanceResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetInstanceResponse*)p = *(WS1__SOF_USCOREGetInstanceResponse*)q;
}

void WS1__SOF_USCOREGetInstance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetInstance*)this)->appName);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetInstance::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetInstance*)this)->appName = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetInstance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetInstance);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetInstance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetInstance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetInstance *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetInstance), type);
	soap_out_PointerTostd__wstring(soap, "appName", -1, &(((WS1__SOF_USCOREGetInstance*)a)->appName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetInstance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetInstance(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetInstance(struct soap *soap, WS1__SOF_USCOREGetInstance *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetInstance(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetInstance::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetInstance(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, WS1__SOF_USCOREGetInstance *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetInstance *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetInstance, sizeof(WS1__SOF_USCOREGetInstance), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetInstance)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetInstance *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_appName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "appName", &(((WS1__SOF_USCOREGetInstance*)a)->appName), "xsd:string"))
				{	soap_flag_appName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetInstance *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetInstance, 0, sizeof(WS1__SOF_USCOREGetInstance), 0, soap_copy_WS1__SOF_USCOREGetInstance);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetInstance * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetInstance(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetInstance(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetInstance(struct soap *soap, WS1__SOF_USCOREGetInstance *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetInstance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetInstance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetInstance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetInstance;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetInstance);
		((WS1__SOF_USCOREGetInstance*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetInstance[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetInstance);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetInstance*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetInstance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetInstance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetInstance %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetInstance*)p = *(WS1__SOF_USCOREGetInstance*)q;
}

void WS1__SOF_USCORESignFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESignFileResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORESignFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESignFileResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESignFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESignFileResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESignFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESignFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESignFileResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESignFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESignFileResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORESignFileResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESignFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESignFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignFileResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORESignFileResponse(struct soap *soap, WS1__SOF_USCORESignFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESignFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESignFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESignFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignFileResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORESignFileResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESignFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESignFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESignFileResponse, sizeof(WS1__SOF_USCORESignFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESignFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESignFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORESignFileResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignFileResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESignFileResponse, 0, sizeof(WS1__SOF_USCORESignFileResponse), 0, soap_copy_WS1__SOF_USCORESignFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESignFileResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORESignFileResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESignFileResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESignFileResponse(struct soap *soap, WS1__SOF_USCORESignFileResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESignFileResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESignFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESignFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESignFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESignFileResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORESignFileResponse);
		((WS1__SOF_USCORESignFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESignFileResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESignFileResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESignFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESignFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESignFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESignFileResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORESignFileResponse*)p = *(WS1__SOF_USCORESignFileResponse*)q;
}

void WS1__SOF_USCORESignFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESignFile*)this)->inFile);
	/* transient soap skipped */
}

void WS1__SOF_USCORESignFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESignFile*)this)->inFile = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESignFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESignFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESignFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESignFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESignFile(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESignFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESignFile), type);
	soap_out_PointerTostd__wstring(soap, "inFile", -1, &(((WS1__SOF_USCORESignFile*)a)->inFile), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESignFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESignFile(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignFile * SOAP_FMAC4 soap_get_WS1__SOF_USCORESignFile(struct soap *soap, WS1__SOF_USCORESignFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESignFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESignFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESignFile(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignFile * SOAP_FMAC4 soap_in_WS1__SOF_USCORESignFile(struct soap *soap, const char *tag, WS1__SOF_USCORESignFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESignFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESignFile, sizeof(WS1__SOF_USCORESignFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESignFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESignFile *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_inFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inFile", &(((WS1__SOF_USCORESignFile*)a)->inFile), "xsd:string"))
				{	soap_flag_inFile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignFile *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESignFile, 0, sizeof(WS1__SOF_USCORESignFile), 0, soap_copy_WS1__SOF_USCORESignFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESignFile * SOAP_FMAC6 soap_new_WS1__SOF_USCORESignFile(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESignFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESignFile(struct soap *soap, WS1__SOF_USCORESignFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESignFile * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESignFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESignFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESignFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESignFile;
		if (size)
			*size = sizeof(WS1__SOF_USCORESignFile);
		((WS1__SOF_USCORESignFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESignFile[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESignFile);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESignFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESignFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESignFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESignFile %p -> %p\n", q, p));
	*(WS1__SOF_USCORESignFile*)p = *(WS1__SOF_USCORESignFile*)q;
}

void WS1__SOF_USCORESignDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESignDataResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORESignDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESignDataResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESignDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESignDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESignDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESignDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESignDataResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESignDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESignDataResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORESignDataResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESignDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESignDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORESignDataResponse(struct soap *soap, WS1__SOF_USCORESignDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESignDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESignDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESignDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORESignDataResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESignDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESignDataResponse, sizeof(WS1__SOF_USCORESignDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESignDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESignDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORESignDataResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESignDataResponse, 0, sizeof(WS1__SOF_USCORESignDataResponse), 0, soap_copy_WS1__SOF_USCORESignDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESignDataResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORESignDataResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESignDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESignDataResponse(struct soap *soap, WS1__SOF_USCORESignDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESignDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESignDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESignDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORESignDataResponse);
		((WS1__SOF_USCORESignDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESignDataResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESignDataResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESignDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESignDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESignDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESignDataResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORESignDataResponse*)p = *(WS1__SOF_USCORESignDataResponse*)q;
}

void WS1__SOF_USCORESignData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESignData*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCORESignData::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESignData*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESignData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESignData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESignData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESignData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESignData(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESignData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESignData), type);
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCORESignData*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESignData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESignData(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignData * SOAP_FMAC4 soap_get_WS1__SOF_USCORESignData(struct soap *soap, WS1__SOF_USCORESignData *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESignData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESignData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESignData(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignData * SOAP_FMAC4 soap_in_WS1__SOF_USCORESignData(struct soap *soap, const char *tag, WS1__SOF_USCORESignData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESignData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESignData, sizeof(WS1__SOF_USCORESignData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESignData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESignData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCORESignData*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignData *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESignData, 0, sizeof(WS1__SOF_USCORESignData), 0, soap_copy_WS1__SOF_USCORESignData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESignData * SOAP_FMAC6 soap_new_WS1__SOF_USCORESignData(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESignData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESignData(struct soap *soap, WS1__SOF_USCORESignData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESignData * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESignData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESignData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESignData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESignData;
		if (size)
			*size = sizeof(WS1__SOF_USCORESignData);
		((WS1__SOF_USCORESignData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESignData[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESignData);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESignData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESignData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESignData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESignData %p -> %p\n", q, p));
	*(WS1__SOF_USCORESignData*)p = *(WS1__SOF_USCORESignData*)q;
}

void WS1__SOF_USCOREVerifySignedDataXMLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifySignedDataXMLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((WS1__SOF_USCOREVerifySignedDataXMLResponse*)this)->return_);
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifySignedDataXMLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifySignedDataXMLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifySignedDataXMLResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse), type);
	soap_out_bool(soap, "return", -1, &(((WS1__SOF_USCOREVerifySignedDataXMLResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifySignedDataXMLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXMLResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXMLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifySignedDataXMLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXMLResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataXMLResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifySignedDataXMLResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse, sizeof(WS1__SOF_USCOREVerifySignedDataXMLResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifySignedDataXMLResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(((WS1__SOF_USCOREVerifySignedDataXMLResponse*)a)->return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataXMLResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse, 0, sizeof(WS1__SOF_USCOREVerifySignedDataXMLResponse), 0, soap_copy_WS1__SOF_USCOREVerifySignedDataXMLResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifySignedDataXMLResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXMLResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXMLResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifySignedDataXMLResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataXMLResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifySignedDataXMLResponse);
		((WS1__SOF_USCOREVerifySignedDataXMLResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataXMLResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifySignedDataXMLResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifySignedDataXMLResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifySignedDataXMLResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifySignedDataXMLResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifySignedDataXMLResponse*)p = *(WS1__SOF_USCOREVerifySignedDataXMLResponse*)q;
}

void WS1__SOF_USCOREVerifySignedDataXML::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifySignedDataXML*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifySignedDataXML::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREVerifySignedDataXML*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifySignedDataXML::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifySignedDataXML::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifySignedDataXML(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifySignedDataXML *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML), type);
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCOREVerifySignedDataXML*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifySignedDataXML::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifySignedDataXML(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXML *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifySignedDataXML(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifySignedDataXML::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifySignedDataXML(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataXML *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifySignedDataXML *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML, sizeof(WS1__SOF_USCOREVerifySignedDataXML), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifySignedDataXML *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCOREVerifySignedDataXML*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataXML *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML, 0, sizeof(WS1__SOF_USCOREVerifySignedDataXML), 0, soap_copy_WS1__SOF_USCOREVerifySignedDataXML);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifySignedDataXML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXML *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifySignedDataXML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataXML;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifySignedDataXML);
		((WS1__SOF_USCOREVerifySignedDataXML*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataXML[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifySignedDataXML);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifySignedDataXML*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifySignedDataXML*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifySignedDataXML %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifySignedDataXML*)p = *(WS1__SOF_USCOREVerifySignedDataXML*)q;
}

void WS1__SOF_USCOREGetXMLSignatureInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetXMLSignatureInfoResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetXMLSignatureInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetXMLSignatureInfoResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetXMLSignatureInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetXMLSignatureInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetXMLSignatureInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGetXMLSignatureInfoResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetXMLSignatureInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfoResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetXMLSignatureInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfoResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetXMLSignatureInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetXMLSignatureInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse, sizeof(WS1__SOF_USCOREGetXMLSignatureInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetXMLSignatureInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGetXMLSignatureInfoResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetXMLSignatureInfoResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse, 0, sizeof(WS1__SOF_USCOREGetXMLSignatureInfoResponse), 0, soap_copy_WS1__SOF_USCOREGetXMLSignatureInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetXMLSignatureInfoResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfoResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetXMLSignatureInfoResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetXMLSignatureInfoResponse);
		((WS1__SOF_USCOREGetXMLSignatureInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetXMLSignatureInfoResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetXMLSignatureInfoResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetXMLSignatureInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetXMLSignatureInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetXMLSignatureInfoResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetXMLSignatureInfoResponse*)p = *(WS1__SOF_USCOREGetXMLSignatureInfoResponse*)q;
}

void WS1__SOF_USCOREGetXMLSignatureInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetXMLSignatureInfo*)this)->XMLSignedData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetXMLSignatureInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetXMLSignatureInfo*)this)->XMLSignedData = NULL;
	soap_default_short(soap, &((WS1__SOF_USCOREGetXMLSignatureInfo*)this)->type);
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetXMLSignatureInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetXMLSignatureInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetXMLSignatureInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetXMLSignatureInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo), type);
	soap_out_PointerTostd__wstring(soap, "XMLSignedData", -1, &(((WS1__SOF_USCOREGetXMLSignatureInfo*)a)->XMLSignedData), "");
	soap_out_short(soap, "type", -1, &(((WS1__SOF_USCOREGetXMLSignatureInfo*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetXMLSignatureInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetXMLSignatureInfo(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetXMLSignatureInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetXMLSignatureInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetXMLSignatureInfo(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, WS1__SOF_USCOREGetXMLSignatureInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetXMLSignatureInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo, sizeof(WS1__SOF_USCOREGetXMLSignatureInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetXMLSignatureInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_XMLSignedData1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XMLSignedData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "XMLSignedData", &(((WS1__SOF_USCOREGetXMLSignatureInfo*)a)->XMLSignedData), "xsd:string"))
				{	soap_flag_XMLSignedData1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "type", &(((WS1__SOF_USCOREGetXMLSignatureInfo*)a)->type), "xsd:short"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetXMLSignatureInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo, 0, sizeof(WS1__SOF_USCOREGetXMLSignatureInfo), 0, soap_copy_WS1__SOF_USCOREGetXMLSignatureInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetXMLSignatureInfo;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetXMLSignatureInfo);
		((WS1__SOF_USCOREGetXMLSignatureInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetXMLSignatureInfo[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetXMLSignatureInfo);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetXMLSignatureInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetXMLSignatureInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetXMLSignatureInfo %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetXMLSignatureInfo*)p = *(WS1__SOF_USCOREGetXMLSignatureInfo*)q;
}

void WS1__SOF_USCOREDelCertTrustListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREDelCertTrustListResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREDelCertTrustListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREDelCertTrustListResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREDelCertTrustListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREDelCertTrustListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREDelCertTrustListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREDelCertTrustListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREDelCertTrustListResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREDelCertTrustListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREDelCertTrustListResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustListResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREDelCertTrustListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREDelCertTrustListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREDelCertTrustListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREDelCertTrustListResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustListResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREDelCertTrustListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREDelCertTrustListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse, sizeof(WS1__SOF_USCOREDelCertTrustListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREDelCertTrustListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREDelCertTrustListResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDelCertTrustListResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse, 0, sizeof(WS1__SOF_USCOREDelCertTrustListResponse), 0, soap_copy_WS1__SOF_USCOREDelCertTrustListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREDelCertTrustListResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREDelCertTrustListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREDelCertTrustListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustListResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREDelCertTrustListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREDelCertTrustListResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREDelCertTrustListResponse);
		((WS1__SOF_USCOREDelCertTrustListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREDelCertTrustListResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREDelCertTrustListResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREDelCertTrustListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREDelCertTrustListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREDelCertTrustListResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREDelCertTrustListResponse*)p = *(WS1__SOF_USCOREDelCertTrustListResponse*)q;
}

void WS1__SOF_USCOREDelCertTrustList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREDelCertTrustList*)this)->fCtlAltname);
	/* transient soap skipped */
}

void WS1__SOF_USCOREDelCertTrustList::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREDelCertTrustList*)this)->fCtlAltname = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREDelCertTrustList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREDelCertTrustList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREDelCertTrustList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREDelCertTrustList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList), type);
	soap_out_PointerTostd__wstring(soap, "fCtlAltname", -1, &(((WS1__SOF_USCOREDelCertTrustList*)a)->fCtlAltname), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREDelCertTrustList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREDelCertTrustList(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_get_WS1__SOF_USCOREDelCertTrustList(struct soap *soap, WS1__SOF_USCOREDelCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREDelCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREDelCertTrustList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREDelCertTrustList(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_in_WS1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, WS1__SOF_USCOREDelCertTrustList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREDelCertTrustList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList, sizeof(WS1__SOF_USCOREDelCertTrustList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREDelCertTrustList *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_fCtlAltname1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fCtlAltname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fCtlAltname", &(((WS1__SOF_USCOREDelCertTrustList*)a)->fCtlAltname), "xsd:string"))
				{	soap_flag_fCtlAltname1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDelCertTrustList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList, 0, sizeof(WS1__SOF_USCOREDelCertTrustList), 0, soap_copy_WS1__SOF_USCOREDelCertTrustList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREDelCertTrustList * SOAP_FMAC6 soap_new_WS1__SOF_USCOREDelCertTrustList(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREDelCertTrustList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREDelCertTrustList(struct soap *soap, WS1__SOF_USCOREDelCertTrustList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREDelCertTrustList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREDelCertTrustList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREDelCertTrustList;
		if (size)
			*size = sizeof(WS1__SOF_USCOREDelCertTrustList);
		((WS1__SOF_USCOREDelCertTrustList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREDelCertTrustList[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREDelCertTrustList);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREDelCertTrustList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREDelCertTrustList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREDelCertTrustList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREDelCertTrustList %p -> %p\n", q, p));
	*(WS1__SOF_USCOREDelCertTrustList*)p = *(WS1__SOF_USCOREDelCertTrustList*)q;
}

void WS1__SOF_USCOREGetCertInfoByOidResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetCertInfoByOidResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetCertInfoByOidResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetCertInfoByOidResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetCertInfoByOidResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetCertInfoByOidResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetCertInfoByOidResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGetCertInfoByOidResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetCertInfoByOidResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOidResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetCertInfoByOidResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOidResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetCertInfoByOidResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetCertInfoByOidResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse, sizeof(WS1__SOF_USCOREGetCertInfoByOidResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetCertInfoByOidResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGetCertInfoByOidResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetCertInfoByOidResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse, 0, sizeof(WS1__SOF_USCOREGetCertInfoByOidResponse), 0, soap_copy_WS1__SOF_USCOREGetCertInfoByOidResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetCertInfoByOidResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOidResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOidResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetCertInfoByOidResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetCertInfoByOidResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetCertInfoByOidResponse);
		((WS1__SOF_USCOREGetCertInfoByOidResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetCertInfoByOidResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetCertInfoByOidResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetCertInfoByOidResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetCertInfoByOidResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetCertInfoByOidResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetCertInfoByOidResponse*)p = *(WS1__SOF_USCOREGetCertInfoByOidResponse*)q;
}

void WS1__SOF_USCOREGetCertInfoByOid::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetCertInfoByOid*)this)->base64EncodeCert);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetCertInfoByOid*)this)->oid);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetCertInfoByOid::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetCertInfoByOid*)this)->base64EncodeCert = NULL;
	((WS1__SOF_USCOREGetCertInfoByOid*)this)->oid = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetCertInfoByOid::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetCertInfoByOid::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetCertInfoByOid(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetCertInfoByOid *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid), type);
	soap_out_PointerTostd__wstring(soap, "base64EncodeCert", -1, &(((WS1__SOF_USCOREGetCertInfoByOid*)a)->base64EncodeCert), "");
	soap_out_PointerTostd__wstring(soap, "oid", -1, &(((WS1__SOF_USCOREGetCertInfoByOid*)a)->oid), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetCertInfoByOid::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetCertInfoByOid(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOid *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetCertInfoByOid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetCertInfoByOid::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetCertInfoByOid(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, WS1__SOF_USCOREGetCertInfoByOid *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetCertInfoByOid *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid, sizeof(WS1__SOF_USCOREGetCertInfoByOid), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetCertInfoByOid *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_base64EncodeCert1 = 1, soap_flag_oid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "base64EncodeCert", &(((WS1__SOF_USCOREGetCertInfoByOid*)a)->base64EncodeCert), "xsd:string"))
				{	soap_flag_base64EncodeCert1--;
					continue;
				}
			if (soap_flag_oid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "oid", &(((WS1__SOF_USCOREGetCertInfoByOid*)a)->oid), "xsd:string"))
				{	soap_flag_oid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetCertInfoByOid *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid, 0, sizeof(WS1__SOF_USCOREGetCertInfoByOid), 0, soap_copy_WS1__SOF_USCOREGetCertInfoByOid);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetCertInfoByOid(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOid *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetCertInfoByOid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetCertInfoByOid;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetCertInfoByOid);
		((WS1__SOF_USCOREGetCertInfoByOid*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetCertInfoByOid[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetCertInfoByOid);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetCertInfoByOid*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetCertInfoByOid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetCertInfoByOid %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetCertInfoByOid*)p = *(WS1__SOF_USCOREGetCertInfoByOid*)q;
}

void WS1__SOF_USCOREGetServerCertificateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetServerCertificateResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetServerCertificateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetServerCertificateResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetServerCertificateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetServerCertificateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetServerCertificateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetServerCertificateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGetServerCertificateResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetServerCertificateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetServerCertificateResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificateResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, WS1__SOF_USCOREGetServerCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetServerCertificateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetServerCertificateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetServerCertificateResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificateResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetServerCertificateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetServerCertificateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse, sizeof(WS1__SOF_USCOREGetServerCertificateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetServerCertificateResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGetServerCertificateResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetServerCertificateResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse, 0, sizeof(WS1__SOF_USCOREGetServerCertificateResponse), 0, soap_copy_WS1__SOF_USCOREGetServerCertificateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetServerCertificateResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetServerCertificateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, WS1__SOF_USCOREGetServerCertificateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificateResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetServerCertificateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetServerCertificateResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetServerCertificateResponse);
		((WS1__SOF_USCOREGetServerCertificateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetServerCertificateResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetServerCertificateResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetServerCertificateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetServerCertificateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetServerCertificateResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetServerCertificateResponse*)p = *(WS1__SOF_USCOREGetServerCertificateResponse*)q;
}

void WS1__SOF_USCOREGetServerCertificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetServerCertificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((WS1__SOF_USCOREGetServerCertificate*)this)->certUsage);
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetServerCertificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetServerCertificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetServerCertificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetServerCertificate *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate), type);
	soap_out_int(soap, "certUsage", -1, &(((WS1__SOF_USCOREGetServerCertificate*)a)->certUsage), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetServerCertificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetServerCertificate(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetServerCertificate(struct soap *soap, WS1__SOF_USCOREGetServerCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetServerCertificate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetServerCertificate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetServerCertificate(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, WS1__SOF_USCOREGetServerCertificate *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetServerCertificate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate, sizeof(WS1__SOF_USCOREGetServerCertificate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetServerCertificate *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_certUsage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_certUsage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "certUsage", &(((WS1__SOF_USCOREGetServerCertificate*)a)->certUsage), "xsd:int"))
				{	soap_flag_certUsage1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_certUsage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetServerCertificate *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate, 0, sizeof(WS1__SOF_USCOREGetServerCertificate), 0, soap_copy_WS1__SOF_USCOREGetServerCertificate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetServerCertificate * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetServerCertificate(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetServerCertificate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetServerCertificate(struct soap *soap, WS1__SOF_USCOREGetServerCertificate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetServerCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetServerCertificate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetServerCertificate;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetServerCertificate);
		((WS1__SOF_USCOREGetServerCertificate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetServerCertificate[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetServerCertificate);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetServerCertificate*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetServerCertificate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetServerCertificate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetServerCertificate %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetServerCertificate*)p = *(WS1__SOF_USCOREGetServerCertificate*)q;
}

void WS1__SOF_USCOREVerifySignedFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifySignedFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((WS1__SOF_USCOREVerifySignedFileResponse*)this)->return_);
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifySignedFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifySignedFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifySignedFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifySignedFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse), type);
	soap_out_bool(soap, "return", -1, &(((WS1__SOF_USCOREVerifySignedFileResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifySignedFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifySignedFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFileResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifySignedFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifySignedFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifySignedFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFileResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifySignedFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse, sizeof(WS1__SOF_USCOREVerifySignedFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifySignedFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(((WS1__SOF_USCOREVerifySignedFileResponse*)a)->return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedFileResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse, 0, sizeof(WS1__SOF_USCOREVerifySignedFileResponse), 0, soap_copy_WS1__SOF_USCOREVerifySignedFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifySignedFileResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifySignedFileResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedFileResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFileResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifySignedFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedFileResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifySignedFileResponse);
		((WS1__SOF_USCOREVerifySignedFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedFileResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifySignedFileResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifySignedFileResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifySignedFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifySignedFileResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifySignedFileResponse*)p = *(WS1__SOF_USCOREVerifySignedFileResponse*)q;
}

void WS1__SOF_USCOREVerifySignedFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifySignedFile*)this)->base64EncodeCert);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifySignedFile*)this)->inFile);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifySignedFile*)this)->signValue);
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifySignedFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREVerifySignedFile*)this)->base64EncodeCert = NULL;
	((WS1__SOF_USCOREVerifySignedFile*)this)->inFile = NULL;
	((WS1__SOF_USCOREVerifySignedFile*)this)->signValue = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifySignedFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifySignedFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifySignedFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifySignedFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile), type);
	soap_out_PointerTostd__wstring(soap, "base64EncodeCert", -1, &(((WS1__SOF_USCOREVerifySignedFile*)a)->base64EncodeCert), "");
	soap_out_PointerTostd__wstring(soap, "inFile", -1, &(((WS1__SOF_USCOREVerifySignedFile*)a)->inFile), "");
	soap_out_PointerTostd__wstring(soap, "signValue", -1, &(((WS1__SOF_USCOREVerifySignedFile*)a)->signValue), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifySignedFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifySignedFile(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifySignedFile(struct soap *soap, WS1__SOF_USCOREVerifySignedFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifySignedFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifySignedFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifySignedFile(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedFile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifySignedFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile, sizeof(WS1__SOF_USCOREVerifySignedFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifySignedFile *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_base64EncodeCert1 = 1, soap_flag_inFile1 = 1, soap_flag_signValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "base64EncodeCert", &(((WS1__SOF_USCOREVerifySignedFile*)a)->base64EncodeCert), "xsd:string"))
				{	soap_flag_base64EncodeCert1--;
					continue;
				}
			if (soap_flag_inFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inFile", &(((WS1__SOF_USCOREVerifySignedFile*)a)->inFile), "xsd:string"))
				{	soap_flag_inFile1--;
					continue;
				}
			if (soap_flag_signValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "signValue", &(((WS1__SOF_USCOREVerifySignedFile*)a)->signValue), "xsd:string"))
				{	soap_flag_signValue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedFile *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile, 0, sizeof(WS1__SOF_USCOREVerifySignedFile), 0, soap_copy_WS1__SOF_USCOREVerifySignedFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifySignedFile * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifySignedFile(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifySignedFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifySignedFile(struct soap *soap, WS1__SOF_USCOREVerifySignedFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifySignedFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifySignedFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedFile;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifySignedFile);
		((WS1__SOF_USCOREVerifySignedFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedFile[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifySignedFile);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifySignedFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifySignedFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifySignedFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifySignedFile %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifySignedFile*)p = *(WS1__SOF_USCOREVerifySignedFile*)q;
}

void WS1__SOF_USCOREPubKeyEncryptResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREPubKeyEncryptResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREPubKeyEncryptResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREPubKeyEncryptResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREPubKeyEncryptResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREPubKeyEncryptResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREPubKeyEncryptResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREPubKeyEncryptResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREPubKeyEncryptResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREPubKeyEncryptResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREPubKeyEncryptResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncryptResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, WS1__SOF_USCOREPubKeyEncryptResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREPubKeyEncryptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREPubKeyEncryptResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREPubKeyEncryptResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncryptResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREPubKeyEncryptResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREPubKeyEncryptResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse, sizeof(WS1__SOF_USCOREPubKeyEncryptResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREPubKeyEncryptResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREPubKeyEncryptResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREPubKeyEncryptResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse, 0, sizeof(WS1__SOF_USCOREPubKeyEncryptResponse), 0, soap_copy_WS1__SOF_USCOREPubKeyEncryptResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREPubKeyEncryptResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREPubKeyEncryptResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, WS1__SOF_USCOREPubKeyEncryptResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncryptResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREPubKeyEncryptResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREPubKeyEncryptResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREPubKeyEncryptResponse);
		((WS1__SOF_USCOREPubKeyEncryptResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREPubKeyEncryptResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREPubKeyEncryptResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREPubKeyEncryptResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREPubKeyEncryptResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREPubKeyEncryptResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREPubKeyEncryptResponse*)p = *(WS1__SOF_USCOREPubKeyEncryptResponse*)q;
}

void WS1__SOF_USCOREPubKeyEncrypt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREPubKeyEncrypt*)this)->base64EncodeCert);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREPubKeyEncrypt*)this)->inData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREPubKeyEncrypt::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREPubKeyEncrypt*)this)->base64EncodeCert = NULL;
	((WS1__SOF_USCOREPubKeyEncrypt*)this)->inData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREPubKeyEncrypt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREPubKeyEncrypt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREPubKeyEncrypt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREPubKeyEncrypt *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt), type);
	soap_out_PointerTostd__wstring(soap, "base64EncodeCert", -1, &(((WS1__SOF_USCOREPubKeyEncrypt*)a)->base64EncodeCert), "");
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCOREPubKeyEncrypt*)a)->inData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREPubKeyEncrypt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREPubKeyEncrypt(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_get_WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, WS1__SOF_USCOREPubKeyEncrypt *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREPubKeyEncrypt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREPubKeyEncrypt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREPubKeyEncrypt(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_in_WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, WS1__SOF_USCOREPubKeyEncrypt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREPubKeyEncrypt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt, sizeof(WS1__SOF_USCOREPubKeyEncrypt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREPubKeyEncrypt *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_base64EncodeCert1 = 1, soap_flag_inData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "base64EncodeCert", &(((WS1__SOF_USCOREPubKeyEncrypt*)a)->base64EncodeCert), "xsd:string"))
				{	soap_flag_base64EncodeCert1--;
					continue;
				}
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCOREPubKeyEncrypt*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREPubKeyEncrypt *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt, 0, sizeof(WS1__SOF_USCOREPubKeyEncrypt), 0, soap_copy_WS1__SOF_USCOREPubKeyEncrypt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC6 soap_new_WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREPubKeyEncrypt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, WS1__SOF_USCOREPubKeyEncrypt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREPubKeyEncrypt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREPubKeyEncrypt;
		if (size)
			*size = sizeof(WS1__SOF_USCOREPubKeyEncrypt);
		((WS1__SOF_USCOREPubKeyEncrypt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREPubKeyEncrypt[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREPubKeyEncrypt);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREPubKeyEncrypt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREPubKeyEncrypt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREPubKeyEncrypt %p -> %p\n", q, p));
	*(WS1__SOF_USCOREPubKeyEncrypt*)p = *(WS1__SOF_USCOREPubKeyEncrypt*)q;
}

void WS1__SOF_USCOREVerifyTimeStampResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifyTimeStampResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((WS1__SOF_USCOREVerifyTimeStampResponse*)this)->return_);
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifyTimeStampResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifyTimeStampResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifyTimeStampResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifyTimeStampResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse), type);
	soap_out_bool(soap, "return", -1, &(((WS1__SOF_USCOREVerifyTimeStampResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifyTimeStampResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifyTimeStampResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStampResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, WS1__SOF_USCOREVerifyTimeStampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifyTimeStampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifyTimeStampResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifyTimeStampResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStampResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifyTimeStampResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifyTimeStampResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse, sizeof(WS1__SOF_USCOREVerifyTimeStampResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifyTimeStampResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(((WS1__SOF_USCOREVerifyTimeStampResponse*)a)->return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifyTimeStampResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse, 0, sizeof(WS1__SOF_USCOREVerifyTimeStampResponse), 0, soap_copy_WS1__SOF_USCOREVerifyTimeStampResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifyTimeStampResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifyTimeStampResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, WS1__SOF_USCOREVerifyTimeStampResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStampResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifyTimeStampResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifyTimeStampResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifyTimeStampResponse);
		((WS1__SOF_USCOREVerifyTimeStampResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifyTimeStampResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifyTimeStampResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifyTimeStampResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifyTimeStampResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifyTimeStampResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifyTimeStampResponse*)p = *(WS1__SOF_USCOREVerifyTimeStampResponse*)q;
}

void WS1__SOF_USCOREVerifyTimeStamp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifyTimeStamp*)this)->content);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifyTimeStamp*)this)->tsResponseData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifyTimeStamp::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREVerifyTimeStamp*)this)->content = NULL;
	((WS1__SOF_USCOREVerifyTimeStamp*)this)->tsResponseData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifyTimeStamp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifyTimeStamp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifyTimeStamp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifyTimeStamp *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp), type);
	soap_out_PointerTostd__wstring(soap, "content", -1, &(((WS1__SOF_USCOREVerifyTimeStamp*)a)->content), "");
	soap_out_PointerTostd__wstring(soap, "tsResponseData", -1, &(((WS1__SOF_USCOREVerifyTimeStamp*)a)->tsResponseData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifyTimeStamp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifyTimeStamp(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, WS1__SOF_USCOREVerifyTimeStamp *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifyTimeStamp(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifyTimeStamp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifyTimeStamp(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifyTimeStamp *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifyTimeStamp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp, sizeof(WS1__SOF_USCOREVerifyTimeStamp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifyTimeStamp *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_content1 = 1, soap_flag_tsResponseData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "content", &(((WS1__SOF_USCOREVerifyTimeStamp*)a)->content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_tsResponseData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "tsResponseData", &(((WS1__SOF_USCOREVerifyTimeStamp*)a)->tsResponseData), "xsd:string"))
				{	soap_flag_tsResponseData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifyTimeStamp *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp, 0, sizeof(WS1__SOF_USCOREVerifyTimeStamp), 0, soap_copy_WS1__SOF_USCOREVerifyTimeStamp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifyTimeStamp(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, WS1__SOF_USCOREVerifyTimeStamp *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifyTimeStamp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifyTimeStamp;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifyTimeStamp);
		((WS1__SOF_USCOREVerifyTimeStamp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifyTimeStamp[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifyTimeStamp);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifyTimeStamp*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifyTimeStamp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifyTimeStamp %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifyTimeStamp*)p = *(WS1__SOF_USCOREVerifyTimeStamp*)q;
}

void WS1__SOF_USCOREGetP7SignDataInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetP7SignDataInfoResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetP7SignDataInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetP7SignDataInfoResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetP7SignDataInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetP7SignDataInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetP7SignDataInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREGetP7SignDataInfoResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetP7SignDataInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfoResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetP7SignDataInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfoResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetP7SignDataInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetP7SignDataInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse, sizeof(WS1__SOF_USCOREGetP7SignDataInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetP7SignDataInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREGetP7SignDataInfoResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetP7SignDataInfoResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse, 0, sizeof(WS1__SOF_USCOREGetP7SignDataInfoResponse), 0, soap_copy_WS1__SOF_USCOREGetP7SignDataInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetP7SignDataInfoResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfoResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetP7SignDataInfoResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetP7SignDataInfoResponse);
		((WS1__SOF_USCOREGetP7SignDataInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetP7SignDataInfoResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetP7SignDataInfoResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetP7SignDataInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetP7SignDataInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetP7SignDataInfoResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetP7SignDataInfoResponse*)p = *(WS1__SOF_USCOREGetP7SignDataInfoResponse*)q;
}

void WS1__SOF_USCOREGetP7SignDataInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREGetP7SignDataInfo*)this)->pkcs7SignData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREGetP7SignDataInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREGetP7SignDataInfo*)this)->pkcs7SignData = NULL;
	soap_default_int(soap, &((WS1__SOF_USCOREGetP7SignDataInfo*)this)->type);
	/* transient soap skipped */
}

int WS1__SOF_USCOREGetP7SignDataInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREGetP7SignDataInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREGetP7SignDataInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREGetP7SignDataInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo), type);
	soap_out_PointerTostd__wstring(soap, "pkcs7SignData", -1, &(((WS1__SOF_USCOREGetP7SignDataInfo*)a)->pkcs7SignData), "");
	soap_out_int(soap, "type", -1, &(((WS1__SOF_USCOREGetP7SignDataInfo*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREGetP7SignDataInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREGetP7SignDataInfo(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_get_WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREGetP7SignDataInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREGetP7SignDataInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREGetP7SignDataInfo(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_in_WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, WS1__SOF_USCOREGetP7SignDataInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREGetP7SignDataInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo, sizeof(WS1__SOF_USCOREGetP7SignDataInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREGetP7SignDataInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_pkcs7SignData1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pkcs7SignData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "pkcs7SignData", &(((WS1__SOF_USCOREGetP7SignDataInfo*)a)->pkcs7SignData), "xsd:string"))
				{	soap_flag_pkcs7SignData1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(((WS1__SOF_USCOREGetP7SignDataInfo*)a)->type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetP7SignDataInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo, 0, sizeof(WS1__SOF_USCOREGetP7SignDataInfo), 0, soap_copy_WS1__SOF_USCOREGetP7SignDataInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC6 soap_new_WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetP7SignDataInfo;
		if (size)
			*size = sizeof(WS1__SOF_USCOREGetP7SignDataInfo);
		((WS1__SOF_USCOREGetP7SignDataInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREGetP7SignDataInfo[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREGetP7SignDataInfo);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREGetP7SignDataInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREGetP7SignDataInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREGetP7SignDataInfo %p -> %p\n", q, p));
	*(WS1__SOF_USCOREGetP7SignDataInfo*)p = *(WS1__SOF_USCOREGetP7SignDataInfo*)q;
}

void WS1__SOF_USCORESetCertTrustListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESetCertTrustListResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCORESetCertTrustListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESetCertTrustListResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCORESetCertTrustListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESetCertTrustListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESetCertTrustListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESetCertTrustListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCORESetCertTrustListResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESetCertTrustListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESetCertTrustListResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustListResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, WS1__SOF_USCORESetCertTrustListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESetCertTrustListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESetCertTrustListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESetCertTrustListResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustListResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESetCertTrustListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESetCertTrustListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse, sizeof(WS1__SOF_USCORESetCertTrustListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESetCertTrustListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCORESetCertTrustListResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetCertTrustListResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse, 0, sizeof(WS1__SOF_USCORESetCertTrustListResponse), 0, soap_copy_WS1__SOF_USCORESetCertTrustListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESetCertTrustListResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESetCertTrustListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, WS1__SOF_USCORESetCertTrustListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustListResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESetCertTrustListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESetCertTrustListResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCORESetCertTrustListResponse);
		((WS1__SOF_USCORESetCertTrustListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESetCertTrustListResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESetCertTrustListResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESetCertTrustListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESetCertTrustListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESetCertTrustListResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCORESetCertTrustListResponse*)p = *(WS1__SOF_USCORESetCertTrustListResponse*)q;
}

void WS1__SOF_USCORESetCertTrustList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESetCertTrustList*)this)->fCtlAltname);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCORESetCertTrustList*)this)->fCtlContent);
	/* transient soap skipped */
}

void WS1__SOF_USCORESetCertTrustList::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCORESetCertTrustList*)this)->fCtlAltname = NULL;
	((WS1__SOF_USCORESetCertTrustList*)this)->fCtlContent = NULL;
	soap_default_int(soap, &((WS1__SOF_USCORESetCertTrustList*)this)->fCtlContentLen);
	/* transient soap skipped */
}

int WS1__SOF_USCORESetCertTrustList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCORESetCertTrustList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCORESetCertTrustList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCORESetCertTrustList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, int id, const WS1__SOF_USCORESetCertTrustList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCORESetCertTrustList), type);
	soap_out_PointerTostd__wstring(soap, "fCtlAltname", -1, &(((WS1__SOF_USCORESetCertTrustList*)a)->fCtlAltname), "");
	soap_out_PointerTostd__wstring(soap, "fCtlContent", -1, &(((WS1__SOF_USCORESetCertTrustList*)a)->fCtlContent), "");
	soap_out_int(soap, "fCtlContentLen", -1, &(((WS1__SOF_USCORESetCertTrustList*)a)->fCtlContentLen), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCORESetCertTrustList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCORESetCertTrustList(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_get_WS1__SOF_USCORESetCertTrustList(struct soap *soap, WS1__SOF_USCORESetCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCORESetCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCORESetCertTrustList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCORESetCertTrustList(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_in_WS1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, WS1__SOF_USCORESetCertTrustList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCORESetCertTrustList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCORESetCertTrustList, sizeof(WS1__SOF_USCORESetCertTrustList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCORESetCertTrustList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCORESetCertTrustList *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_fCtlAltname1 = 1, soap_flag_fCtlContent1 = 1, soap_flag_fCtlContentLen1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fCtlAltname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fCtlAltname", &(((WS1__SOF_USCORESetCertTrustList*)a)->fCtlAltname), "xsd:string"))
				{	soap_flag_fCtlAltname1--;
					continue;
				}
			if (soap_flag_fCtlContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fCtlContent", &(((WS1__SOF_USCORESetCertTrustList*)a)->fCtlContent), "xsd:string"))
				{	soap_flag_fCtlContent1--;
					continue;
				}
			if (soap_flag_fCtlContentLen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fCtlContentLen", &(((WS1__SOF_USCORESetCertTrustList*)a)->fCtlContentLen), "xsd:int"))
				{	soap_flag_fCtlContentLen1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fCtlContentLen1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetCertTrustList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCORESetCertTrustList, 0, sizeof(WS1__SOF_USCORESetCertTrustList), 0, soap_copy_WS1__SOF_USCORESetCertTrustList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCORESetCertTrustList * SOAP_FMAC6 soap_new_WS1__SOF_USCORESetCertTrustList(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCORESetCertTrustList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCORESetCertTrustList(struct soap *soap, WS1__SOF_USCORESetCertTrustList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCORESetCertTrustList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCORESetCertTrustList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCORESetCertTrustList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCORESetCertTrustList;
		if (size)
			*size = sizeof(WS1__SOF_USCORESetCertTrustList);
		((WS1__SOF_USCORESetCertTrustList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCORESetCertTrustList[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCORESetCertTrustList);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCORESetCertTrustList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCORESetCertTrustList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCORESetCertTrustList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCORESetCertTrustList %p -> %p\n", q, p));
	*(WS1__SOF_USCORESetCertTrustList*)p = *(WS1__SOF_USCORESetCertTrustList*)q;
}

void WS1__SOF_USCOREVerifySignedDataByP7Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifySignedDataByP7Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((WS1__SOF_USCOREVerifySignedDataByP7Response*)this)->return_);
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifySignedDataByP7Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifySignedDataByP7Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifySignedDataByP7Response *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response), type);
	soap_out_bool(soap, "return", -1, &(((WS1__SOF_USCOREVerifySignedDataByP7Response*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifySignedDataByP7Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7Response * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifySignedDataByP7Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7Response * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataByP7Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifySignedDataByP7Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response, sizeof(WS1__SOF_USCOREVerifySignedDataByP7Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifySignedDataByP7Response *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(((WS1__SOF_USCOREVerifySignedDataByP7Response*)a)->return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataByP7Response *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response, 0, sizeof(WS1__SOF_USCOREVerifySignedDataByP7Response), 0, soap_copy_WS1__SOF_USCOREVerifySignedDataByP7Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifySignedDataByP7Response * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7Response *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7Response * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataByP7Response;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifySignedDataByP7Response);
		((WS1__SOF_USCOREVerifySignedDataByP7Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataByP7Response[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifySignedDataByP7Response);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifySignedDataByP7Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifySignedDataByP7Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifySignedDataByP7Response %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifySignedDataByP7Response*)p = *(WS1__SOF_USCOREVerifySignedDataByP7Response*)q;
}

void WS1__SOF_USCOREVerifySignedDataByP7::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifySignedDataByP7*)this)->pkcs7SignData);
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifySignedDataByP7::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREVerifySignedDataByP7*)this)->pkcs7SignData = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifySignedDataByP7::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifySignedDataByP7::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifySignedDataByP7(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifySignedDataByP7 *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7), type);
	soap_out_PointerTostd__wstring(soap, "pkcs7SignData", -1, &(((WS1__SOF_USCOREVerifySignedDataByP7*)a)->pkcs7SignData), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifySignedDataByP7::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifySignedDataByP7(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7 *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifySignedDataByP7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifySignedDataByP7::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifySignedDataByP7(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataByP7 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifySignedDataByP7 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7, sizeof(WS1__SOF_USCOREVerifySignedDataByP7), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifySignedDataByP7 *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_pkcs7SignData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pkcs7SignData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "pkcs7SignData", &(((WS1__SOF_USCOREVerifySignedDataByP7*)a)->pkcs7SignData), "xsd:string"))
				{	soap_flag_pkcs7SignData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataByP7 *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7, 0, sizeof(WS1__SOF_USCOREVerifySignedDataByP7), 0, soap_copy_WS1__SOF_USCOREVerifySignedDataByP7);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataByP7;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifySignedDataByP7);
		((WS1__SOF_USCOREVerifySignedDataByP7*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataByP7[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifySignedDataByP7);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifySignedDataByP7*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifySignedDataByP7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifySignedDataByP7 %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifySignedDataByP7*)p = *(WS1__SOF_USCOREVerifySignedDataByP7*)q;
}

void WS1__SOF_USCOREQueryCertTrustListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREQueryCertTrustListResponse*)this)->return_);
	/* transient soap skipped */
}

void WS1__SOF_USCOREQueryCertTrustListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREQueryCertTrustListResponse*)this)->return_ = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREQueryCertTrustListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREQueryCertTrustListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREQueryCertTrustListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREQueryCertTrustListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse), type);
	soap_out_PointerTostd__wstring(soap, "return", -1, &(((WS1__SOF_USCOREQueryCertTrustListResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREQueryCertTrustListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREQueryCertTrustListResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREQueryCertTrustListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREQueryCertTrustListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREQueryCertTrustListResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREQueryCertTrustListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREQueryCertTrustListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse, sizeof(WS1__SOF_USCOREQueryCertTrustListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREQueryCertTrustListResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "return", &(((WS1__SOF_USCOREQueryCertTrustListResponse*)a)->return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREQueryCertTrustListResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse, 0, sizeof(WS1__SOF_USCOREQueryCertTrustListResponse), 0, soap_copy_WS1__SOF_USCOREQueryCertTrustListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREQueryCertTrustListResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREQueryCertTrustListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREQueryCertTrustListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREQueryCertTrustListResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREQueryCertTrustListResponse);
		((WS1__SOF_USCOREQueryCertTrustListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREQueryCertTrustListResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREQueryCertTrustListResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREQueryCertTrustListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREQueryCertTrustListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREQueryCertTrustListResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREQueryCertTrustListResponse*)p = *(WS1__SOF_USCOREQueryCertTrustListResponse*)q;
}

void WS1__SOF_USCOREQueryCertTrustList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREQueryCertTrustList*)this)->fCtlAltname);
	/* transient soap skipped */
}

void WS1__SOF_USCOREQueryCertTrustList::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREQueryCertTrustList*)this)->fCtlAltname = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREQueryCertTrustList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREQueryCertTrustList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREQueryCertTrustList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREQueryCertTrustList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList), type);
	soap_out_PointerTostd__wstring(soap, "fCtlAltname", -1, &(((WS1__SOF_USCOREQueryCertTrustList*)a)->fCtlAltname), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREQueryCertTrustList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREQueryCertTrustList(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_get_WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, WS1__SOF_USCOREQueryCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREQueryCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREQueryCertTrustList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREQueryCertTrustList(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_in_WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, WS1__SOF_USCOREQueryCertTrustList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREQueryCertTrustList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList, sizeof(WS1__SOF_USCOREQueryCertTrustList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREQueryCertTrustList *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_fCtlAltname1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fCtlAltname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fCtlAltname", &(((WS1__SOF_USCOREQueryCertTrustList*)a)->fCtlAltname), "xsd:string"))
				{	soap_flag_fCtlAltname1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREQueryCertTrustList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList, 0, sizeof(WS1__SOF_USCOREQueryCertTrustList), 0, soap_copy_WS1__SOF_USCOREQueryCertTrustList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREQueryCertTrustList * SOAP_FMAC6 soap_new_WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREQueryCertTrustList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, WS1__SOF_USCOREQueryCertTrustList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREQueryCertTrustList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREQueryCertTrustList;
		if (size)
			*size = sizeof(WS1__SOF_USCOREQueryCertTrustList);
		((WS1__SOF_USCOREQueryCertTrustList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREQueryCertTrustList[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREQueryCertTrustList);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREQueryCertTrustList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREQueryCertTrustList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREQueryCertTrustList %p -> %p\n", q, p));
	*(WS1__SOF_USCOREQueryCertTrustList*)p = *(WS1__SOF_USCOREQueryCertTrustList*)q;
}

void WS1__SOF_USCOREVerifySignedDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifySignedDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((WS1__SOF_USCOREVerifySignedDataResponse*)this)->return_);
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifySignedDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifySignedDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifySignedDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifySignedDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse), type);
	soap_out_bool(soap, "return", -1, &(((WS1__SOF_USCOREVerifySignedDataResponse*)a)->return_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifySignedDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifySignedDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataResponse * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifySignedDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifySignedDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifySignedDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataResponse * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifySignedDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse, sizeof(WS1__SOF_USCOREVerifySignedDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifySignedDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(((WS1__SOF_USCOREVerifySignedDataResponse*)a)->return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse, 0, sizeof(WS1__SOF_USCOREVerifySignedDataResponse), 0, soap_copy_WS1__SOF_USCOREVerifySignedDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifySignedDataResponse * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifySignedDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataResponse * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifySignedDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataResponse;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifySignedDataResponse);
		((WS1__SOF_USCOREVerifySignedDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedDataResponse[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifySignedDataResponse);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifySignedDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifySignedDataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifySignedDataResponse %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifySignedDataResponse*)p = *(WS1__SOF_USCOREVerifySignedDataResponse*)q;
}

void WS1__SOF_USCOREVerifySignedData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifySignedData*)this)->base64EncodeCert);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifySignedData*)this)->inData);
	soap_serialize_PointerTostd__wstring(soap, &((WS1__SOF_USCOREVerifySignedData*)this)->signValue);
	/* transient soap skipped */
}

void WS1__SOF_USCOREVerifySignedData::soap_default(struct soap *soap)
{
	this->soap = soap;
	((WS1__SOF_USCOREVerifySignedData*)this)->base64EncodeCert = NULL;
	((WS1__SOF_USCOREVerifySignedData*)this)->inData = NULL;
	((WS1__SOF_USCOREVerifySignedData*)this)->signValue = NULL;
	/* transient soap skipped */
}

int WS1__SOF_USCOREVerifySignedData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_WS1__SOF_USCOREVerifySignedData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int WS1__SOF_USCOREVerifySignedData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_WS1__SOF_USCOREVerifySignedData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_WS1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, int id, const WS1__SOF_USCOREVerifySignedData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedData), type);
	soap_out_PointerTostd__wstring(soap, "base64EncodeCert", -1, &(((WS1__SOF_USCOREVerifySignedData*)a)->base64EncodeCert), "");
	soap_out_PointerTostd__wstring(soap, "inData", -1, &(((WS1__SOF_USCOREVerifySignedData*)a)->inData), "");
	soap_out_PointerTostd__wstring(soap, "signValue", -1, &(((WS1__SOF_USCOREVerifySignedData*)a)->signValue), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *WS1__SOF_USCOREVerifySignedData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_WS1__SOF_USCOREVerifySignedData(soap, this, tag, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_get_WS1__SOF_USCOREVerifySignedData(struct soap *soap, WS1__SOF_USCOREVerifySignedData *p, const char *tag, const char *type)
{
	if ((p = soap_in_WS1__SOF_USCOREVerifySignedData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *WS1__SOF_USCOREVerifySignedData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_WS1__SOF_USCOREVerifySignedData(soap, tag, this, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_in_WS1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (WS1__SOF_USCOREVerifySignedData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedData, sizeof(WS1__SOF_USCOREVerifySignedData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_WS1__SOF_USCOREVerifySignedData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (WS1__SOF_USCOREVerifySignedData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_base64EncodeCert1 = 1, soap_flag_inData1 = 1, soap_flag_signValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64EncodeCert1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "base64EncodeCert", &(((WS1__SOF_USCOREVerifySignedData*)a)->base64EncodeCert), "xsd:string"))
				{	soap_flag_base64EncodeCert1--;
					continue;
				}
			if (soap_flag_inData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "inData", &(((WS1__SOF_USCOREVerifySignedData*)a)->inData), "xsd:string"))
				{	soap_flag_inData1--;
					continue;
				}
			if (soap_flag_signValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "signValue", &(((WS1__SOF_USCOREVerifySignedData*)a)->signValue), "xsd:string"))
				{	soap_flag_signValue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedData *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_WS1__SOF_USCOREVerifySignedData, 0, sizeof(WS1__SOF_USCOREVerifySignedData), 0, soap_copy_WS1__SOF_USCOREVerifySignedData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 WS1__SOF_USCOREVerifySignedData * SOAP_FMAC6 soap_new_WS1__SOF_USCOREVerifySignedData(struct soap *soap, int n)
{	return soap_instantiate_WS1__SOF_USCOREVerifySignedData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_WS1__SOF_USCOREVerifySignedData(struct soap *soap, WS1__SOF_USCOREVerifySignedData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_instantiate_WS1__SOF_USCOREVerifySignedData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_WS1__SOF_USCOREVerifySignedData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_WS1__SOF_USCOREVerifySignedData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedData;
		if (size)
			*size = sizeof(WS1__SOF_USCOREVerifySignedData);
		((WS1__SOF_USCOREVerifySignedData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new WS1__SOF_USCOREVerifySignedData[n];
		if (size)
			*size = n * sizeof(WS1__SOF_USCOREVerifySignedData);
		for (int i = 0; i < n; i++)
			((WS1__SOF_USCOREVerifySignedData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (WS1__SOF_USCOREVerifySignedData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_WS1__SOF_USCOREVerifySignedData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying WS1__SOF_USCOREVerifySignedData %p -> %p\n", q, p));
	*(WS1__SOF_USCOREVerifySignedData*)p = *(WS1__SOF_USCOREVerifySignedData*)q;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREEncryptData(struct soap *soap, const struct __WS1__SOF_USCOREEncryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREEncryptData(soap, &a->WS1__SOF_USCOREEncryptData_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREEncryptData(struct soap *soap, struct __WS1__SOF_USCOREEncryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREEncryptData_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREEncryptData(struct soap *soap, const struct __WS1__SOF_USCOREEncryptData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREEncryptData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREEncryptData *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREEncryptData(soap, "WS1:SOF_EncryptData", -1, &a->WS1__SOF_USCOREEncryptData_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_get___WS1__SOF_USCOREEncryptData(struct soap *soap, struct __WS1__SOF_USCOREEncryptData *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREEncryptData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_in___WS1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREEncryptData *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREEncryptData_ = 1;
	a = (struct __WS1__SOF_USCOREEncryptData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREEncryptData, sizeof(struct __WS1__SOF_USCOREEncryptData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREEncryptData(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREEncryptData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREEncryptData(soap, "WS1:SOF_EncryptData", &a->WS1__SOF_USCOREEncryptData_, "WS1:SOF_EncryptData"))
				{	soap_flag_WS1__SOF_USCOREEncryptData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREEncryptData * SOAP_FMAC6 soap_new___WS1__SOF_USCOREEncryptData(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREEncryptData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREEncryptData(struct soap *soap, struct __WS1__SOF_USCOREEncryptData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREEncryptData * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREEncryptData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREEncryptData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREEncryptData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREEncryptData;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREEncryptData);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREEncryptData[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREEncryptData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREEncryptData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREEncryptData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREEncryptData %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREEncryptData*)p = *(struct __WS1__SOF_USCOREEncryptData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const struct __WS1__SOF_USCOREQueryCertTrustListAltNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(soap, &a->WS1__SOF_USCOREQueryCertTrustListAltNames_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct __WS1__SOF_USCOREQueryCertTrustListAltNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREQueryCertTrustListAltNames_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const struct __WS1__SOF_USCOREQueryCertTrustListAltNames *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREQueryCertTrustListAltNames *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(soap, "WS1:SOF_QueryCertTrustListAltNames", -1, &a->WS1__SOF_USCOREQueryCertTrustListAltNames_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_get___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct __WS1__SOF_USCOREQueryCertTrustListAltNames *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_in___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREQueryCertTrustListAltNames *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREQueryCertTrustListAltNames_ = 1;
	a = (struct __WS1__SOF_USCOREQueryCertTrustListAltNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustListAltNames, sizeof(struct __WS1__SOF_USCOREQueryCertTrustListAltNames), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREQueryCertTrustListAltNames(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREQueryCertTrustListAltNames_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(soap, "WS1:SOF_QueryCertTrustListAltNames", &a->WS1__SOF_USCOREQueryCertTrustListAltNames_, "WS1:SOF_QueryCertTrustListAltNames"))
				{	soap_flag_WS1__SOF_USCOREQueryCertTrustListAltNames_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC6 soap_new___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREQueryCertTrustListAltNames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, struct __WS1__SOF_USCOREQueryCertTrustListAltNames *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREQueryCertTrustListAltNames * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREQueryCertTrustListAltNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustListAltNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREQueryCertTrustListAltNames;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREQueryCertTrustListAltNames);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREQueryCertTrustListAltNames[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREQueryCertTrustListAltNames);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREQueryCertTrustListAltNames*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREQueryCertTrustListAltNames %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREQueryCertTrustListAltNames*)p = *(struct __WS1__SOF_USCOREQueryCertTrustListAltNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetCertInfo(struct soap *soap, const struct __WS1__SOF_USCOREGetCertInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetCertInfo(soap, &a->WS1__SOF_USCOREGetCertInfo_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetCertInfo(struct soap *soap, struct __WS1__SOF_USCOREGetCertInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetCertInfo_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetCertInfo(struct soap *soap, const struct __WS1__SOF_USCOREGetCertInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetCertInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetCertInfo *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetCertInfo(soap, "WS1:SOF_GetCertInfo", -1, &a->WS1__SOF_USCOREGetCertInfo_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetCertInfo(struct soap *soap, struct __WS1__SOF_USCOREGetCertInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetCertInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetCertInfo *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetCertInfo_ = 1;
	a = (struct __WS1__SOF_USCOREGetCertInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetCertInfo, sizeof(struct __WS1__SOF_USCOREGetCertInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetCertInfo(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetCertInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetCertInfo(soap, "WS1:SOF_GetCertInfo", &a->WS1__SOF_USCOREGetCertInfo_, "WS1:SOF_GetCertInfo"))
				{	soap_flag_WS1__SOF_USCOREGetCertInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetCertInfo * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetCertInfo(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetCertInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetCertInfo(struct soap *soap, struct __WS1__SOF_USCOREGetCertInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetCertInfo * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetCertInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetCertInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetCertInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetCertInfo;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetCertInfo);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetCertInfo[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetCertInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetCertInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetCertInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetCertInfo %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetCertInfo*)p = *(struct __WS1__SOF_USCOREGetCertInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORESignDataXML(struct soap *soap, const struct __WS1__SOF_USCORESignDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORESignDataXML(soap, &a->WS1__SOF_USCORESignDataXML_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORESignDataXML(struct soap *soap, struct __WS1__SOF_USCORESignDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORESignDataXML_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORESignDataXML(struct soap *soap, const struct __WS1__SOF_USCORESignDataXML *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORESignDataXML(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORESignDataXML *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORESignDataXML(soap, "WS1:SOF_SignDataXML", -1, &a->WS1__SOF_USCORESignDataXML_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_get___WS1__SOF_USCORESignDataXML(struct soap *soap, struct __WS1__SOF_USCORESignDataXML *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORESignDataXML(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_in___WS1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, struct __WS1__SOF_USCORESignDataXML *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORESignDataXML_ = 1;
	a = (struct __WS1__SOF_USCORESignDataXML *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORESignDataXML, sizeof(struct __WS1__SOF_USCORESignDataXML), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORESignDataXML(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORESignDataXML_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORESignDataXML(soap, "WS1:SOF_SignDataXML", &a->WS1__SOF_USCORESignDataXML_, "WS1:SOF_SignDataXML"))
				{	soap_flag_WS1__SOF_USCORESignDataXML_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORESignDataXML * SOAP_FMAC6 soap_new___WS1__SOF_USCORESignDataXML(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORESignDataXML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORESignDataXML(struct soap *soap, struct __WS1__SOF_USCORESignDataXML *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignDataXML * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORESignDataXML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORESignDataXML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORESignDataXML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESignDataXML;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORESignDataXML);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESignDataXML[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORESignDataXML);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORESignDataXML*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORESignDataXML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORESignDataXML %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORESignDataXML*)p = *(struct __WS1__SOF_USCORESignDataXML*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREDecryptData(struct soap *soap, const struct __WS1__SOF_USCOREDecryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREDecryptData(soap, &a->WS1__SOF_USCOREDecryptData_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREDecryptData(struct soap *soap, struct __WS1__SOF_USCOREDecryptData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREDecryptData_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREDecryptData(struct soap *soap, const struct __WS1__SOF_USCOREDecryptData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREDecryptData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREDecryptData *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREDecryptData(soap, "WS1:SOF_DecryptData", -1, &a->WS1__SOF_USCOREDecryptData_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_get___WS1__SOF_USCOREDecryptData(struct soap *soap, struct __WS1__SOF_USCOREDecryptData *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREDecryptData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_in___WS1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREDecryptData *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREDecryptData_ = 1;
	a = (struct __WS1__SOF_USCOREDecryptData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREDecryptData, sizeof(struct __WS1__SOF_USCOREDecryptData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREDecryptData(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREDecryptData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREDecryptData(soap, "WS1:SOF_DecryptData", &a->WS1__SOF_USCOREDecryptData_, "WS1:SOF_DecryptData"))
				{	soap_flag_WS1__SOF_USCOREDecryptData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREDecryptData * SOAP_FMAC6 soap_new___WS1__SOF_USCOREDecryptData(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREDecryptData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREDecryptData(struct soap *soap, struct __WS1__SOF_USCOREDecryptData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDecryptData * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREDecryptData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREDecryptData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREDecryptData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREDecryptData;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREDecryptData);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREDecryptData[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREDecryptData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREDecryptData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREDecryptData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREDecryptData %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREDecryptData*)p = *(struct __WS1__SOF_USCOREDecryptData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORESignDataByP7(struct soap *soap, const struct __WS1__SOF_USCORESignDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORESignDataByP7(soap, &a->WS1__SOF_USCORESignDataByP7_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORESignDataByP7(struct soap *soap, struct __WS1__SOF_USCORESignDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORESignDataByP7_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORESignDataByP7(struct soap *soap, const struct __WS1__SOF_USCORESignDataByP7 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORESignDataByP7(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORESignDataByP7 *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORESignDataByP7(soap, "WS1:SOF_SignDataByP7", -1, &a->WS1__SOF_USCORESignDataByP7_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_get___WS1__SOF_USCORESignDataByP7(struct soap *soap, struct __WS1__SOF_USCORESignDataByP7 *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORESignDataByP7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_in___WS1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, struct __WS1__SOF_USCORESignDataByP7 *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORESignDataByP7_ = 1;
	a = (struct __WS1__SOF_USCORESignDataByP7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORESignDataByP7, sizeof(struct __WS1__SOF_USCORESignDataByP7), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORESignDataByP7(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORESignDataByP7_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORESignDataByP7(soap, "WS1:SOF_SignDataByP7", &a->WS1__SOF_USCORESignDataByP7_, "WS1:SOF_SignDataByP7"))
				{	soap_flag_WS1__SOF_USCORESignDataByP7_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORESignDataByP7 * SOAP_FMAC6 soap_new___WS1__SOF_USCORESignDataByP7(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORESignDataByP7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORESignDataByP7(struct soap *soap, struct __WS1__SOF_USCORESignDataByP7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignDataByP7 * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORESignDataByP7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORESignDataByP7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORESignDataByP7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESignDataByP7;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORESignDataByP7);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESignDataByP7[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORESignDataByP7);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORESignDataByP7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORESignDataByP7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORESignDataByP7 %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORESignDataByP7*)p = *(struct __WS1__SOF_USCORESignDataByP7*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREEncryptFile(struct soap *soap, const struct __WS1__SOF_USCOREEncryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREEncryptFile(soap, &a->WS1__SOF_USCOREEncryptFile_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREEncryptFile(struct soap *soap, struct __WS1__SOF_USCOREEncryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREEncryptFile_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREEncryptFile(struct soap *soap, const struct __WS1__SOF_USCOREEncryptFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREEncryptFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREEncryptFile *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREEncryptFile(soap, "WS1:SOF_EncryptFile", -1, &a->WS1__SOF_USCOREEncryptFile_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_get___WS1__SOF_USCOREEncryptFile(struct soap *soap, struct __WS1__SOF_USCOREEncryptFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREEncryptFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_in___WS1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREEncryptFile *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREEncryptFile_ = 1;
	a = (struct __WS1__SOF_USCOREEncryptFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREEncryptFile, sizeof(struct __WS1__SOF_USCOREEncryptFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREEncryptFile(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREEncryptFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREEncryptFile(soap, "WS1:SOF_EncryptFile", &a->WS1__SOF_USCOREEncryptFile_, "WS1:SOF_EncryptFile"))
				{	soap_flag_WS1__SOF_USCOREEncryptFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREEncryptFile * SOAP_FMAC6 soap_new___WS1__SOF_USCOREEncryptFile(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREEncryptFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREEncryptFile(struct soap *soap, struct __WS1__SOF_USCOREEncryptFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREEncryptFile * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREEncryptFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREEncryptFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREEncryptFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREEncryptFile;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREEncryptFile);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREEncryptFile[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREEncryptFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREEncryptFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREEncryptFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREEncryptFile %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREEncryptFile*)p = *(struct __WS1__SOF_USCOREEncryptFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const struct __WS1__SOF_USCOREGetTimeStampInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetTimeStampInfo(soap, &a->WS1__SOF_USCOREGetTimeStampInfo_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct __WS1__SOF_USCOREGetTimeStampInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetTimeStampInfo_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const struct __WS1__SOF_USCOREGetTimeStampInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetTimeStampInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetTimeStampInfo *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetTimeStampInfo(soap, "WS1:SOF_GetTimeStampInfo", -1, &a->WS1__SOF_USCOREGetTimeStampInfo_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct __WS1__SOF_USCOREGetTimeStampInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetTimeStampInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetTimeStampInfo *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetTimeStampInfo_ = 1;
	a = (struct __WS1__SOF_USCOREGetTimeStampInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetTimeStampInfo, sizeof(struct __WS1__SOF_USCOREGetTimeStampInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetTimeStampInfo(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetTimeStampInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetTimeStampInfo(soap, "WS1:SOF_GetTimeStampInfo", &a->WS1__SOF_USCOREGetTimeStampInfo_, "WS1:SOF_GetTimeStampInfo"))
				{	soap_flag_WS1__SOF_USCOREGetTimeStampInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetTimeStampInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, struct __WS1__SOF_USCOREGetTimeStampInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetTimeStampInfo * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetTimeStampInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetTimeStampInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetTimeStampInfo;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetTimeStampInfo);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetTimeStampInfo[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetTimeStampInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetTimeStampInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetTimeStampInfo %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetTimeStampInfo*)p = *(struct __WS1__SOF_USCOREGetTimeStampInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORESetSignMethod(struct soap *soap, const struct __WS1__SOF_USCORESetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORESetSignMethod(soap, &a->WS1__SOF_USCORESetSignMethod_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORESetSignMethod(struct soap *soap, struct __WS1__SOF_USCORESetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORESetSignMethod_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORESetSignMethod(struct soap *soap, const struct __WS1__SOF_USCORESetSignMethod *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORESetSignMethod(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORESetSignMethod *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORESetSignMethod(soap, "WS1:SOF_SetSignMethod", -1, &a->WS1__SOF_USCORESetSignMethod_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_get___WS1__SOF_USCORESetSignMethod(struct soap *soap, struct __WS1__SOF_USCORESetSignMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORESetSignMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_in___WS1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, struct __WS1__SOF_USCORESetSignMethod *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORESetSignMethod_ = 1;
	a = (struct __WS1__SOF_USCORESetSignMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORESetSignMethod, sizeof(struct __WS1__SOF_USCORESetSignMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORESetSignMethod(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORESetSignMethod_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORESetSignMethod(soap, "WS1:SOF_SetSignMethod", &a->WS1__SOF_USCORESetSignMethod_, "WS1:SOF_SetSignMethod"))
				{	soap_flag_WS1__SOF_USCORESetSignMethod_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORESetSignMethod * SOAP_FMAC6 soap_new___WS1__SOF_USCORESetSignMethod(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORESetSignMethod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORESetSignMethod(struct soap *soap, struct __WS1__SOF_USCORESetSignMethod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetSignMethod * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORESetSignMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORESetSignMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORESetSignMethod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESetSignMethod;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORESetSignMethod);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESetSignMethod[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORESetSignMethod);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORESetSignMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORESetSignMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORESetSignMethod %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORESetSignMethod*)p = *(struct __WS1__SOF_USCORESetSignMethod*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREDecryptFile(struct soap *soap, const struct __WS1__SOF_USCOREDecryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREDecryptFile(soap, &a->WS1__SOF_USCOREDecryptFile_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREDecryptFile(struct soap *soap, struct __WS1__SOF_USCOREDecryptFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREDecryptFile_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREDecryptFile(struct soap *soap, const struct __WS1__SOF_USCOREDecryptFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREDecryptFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREDecryptFile *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREDecryptFile(soap, "WS1:SOF_DecryptFile", -1, &a->WS1__SOF_USCOREDecryptFile_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_get___WS1__SOF_USCOREDecryptFile(struct soap *soap, struct __WS1__SOF_USCOREDecryptFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREDecryptFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_in___WS1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREDecryptFile *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREDecryptFile_ = 1;
	a = (struct __WS1__SOF_USCOREDecryptFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREDecryptFile, sizeof(struct __WS1__SOF_USCOREDecryptFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREDecryptFile(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREDecryptFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREDecryptFile(soap, "WS1:SOF_DecryptFile", &a->WS1__SOF_USCOREDecryptFile_, "WS1:SOF_DecryptFile"))
				{	soap_flag_WS1__SOF_USCOREDecryptFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREDecryptFile * SOAP_FMAC6 soap_new___WS1__SOF_USCOREDecryptFile(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREDecryptFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREDecryptFile(struct soap *soap, struct __WS1__SOF_USCOREDecryptFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDecryptFile * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREDecryptFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREDecryptFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREDecryptFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREDecryptFile;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREDecryptFile);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREDecryptFile[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREDecryptFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREDecryptFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREDecryptFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREDecryptFile %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREDecryptFile*)p = *(struct __WS1__SOF_USCOREDecryptFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__GetFile(struct soap *soap, const struct __WS1__GetFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__GetFile(soap, &a->WS1__GetFile_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__GetFile(struct soap *soap, struct __WS1__GetFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__GetFile_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__GetFile(struct soap *soap, const struct __WS1__GetFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__GetFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__GetFile(struct soap *soap, const char *tag, int id, const struct __WS1__GetFile *a, const char *type)
{
	soap_out_PointerToWS1__GetFile(soap, "WS1:GetFile", -1, &a->WS1__GetFile_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__GetFile * SOAP_FMAC4 soap_get___WS1__GetFile(struct soap *soap, struct __WS1__GetFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__GetFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__GetFile * SOAP_FMAC4 soap_in___WS1__GetFile(struct soap *soap, const char *tag, struct __WS1__GetFile *a, const char *type)
{
	short soap_flag_WS1__GetFile_ = 1;
	a = (struct __WS1__GetFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__GetFile, sizeof(struct __WS1__GetFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__GetFile(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__GetFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__GetFile(soap, "WS1:GetFile", &a->WS1__GetFile_, "WS1:GetFile"))
				{	soap_flag_WS1__GetFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__GetFile * SOAP_FMAC6 soap_new___WS1__GetFile(struct soap *soap, int n)
{	return soap_instantiate___WS1__GetFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__GetFile(struct soap *soap, struct __WS1__GetFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__GetFile * SOAP_FMAC4 soap_instantiate___WS1__GetFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__GetFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__GetFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__GetFile;
		if (size)
			*size = sizeof(struct __WS1__GetFile);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__GetFile[n];
		if (size)
			*size = n * sizeof(struct __WS1__GetFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__GetFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__GetFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__GetFile %p -> %p\n", q, p));
	*(struct __WS1__GetFile*)p = *(struct __WS1__GetFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__DeleteFile(struct soap *soap, const struct __WS1__DeleteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__DeleteFile(soap, &a->WS1__DeleteFile_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__DeleteFile(struct soap *soap, struct __WS1__DeleteFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__DeleteFile_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__DeleteFile(struct soap *soap, const struct __WS1__DeleteFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__DeleteFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__DeleteFile(struct soap *soap, const char *tag, int id, const struct __WS1__DeleteFile *a, const char *type)
{
	soap_out_PointerToWS1__DeleteFile(soap, "WS1:DeleteFile", -1, &a->WS1__DeleteFile_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__DeleteFile * SOAP_FMAC4 soap_get___WS1__DeleteFile(struct soap *soap, struct __WS1__DeleteFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__DeleteFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__DeleteFile * SOAP_FMAC4 soap_in___WS1__DeleteFile(struct soap *soap, const char *tag, struct __WS1__DeleteFile *a, const char *type)
{
	short soap_flag_WS1__DeleteFile_ = 1;
	a = (struct __WS1__DeleteFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__DeleteFile, sizeof(struct __WS1__DeleteFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__DeleteFile(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__DeleteFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__DeleteFile(soap, "WS1:DeleteFile", &a->WS1__DeleteFile_, "WS1:DeleteFile"))
				{	soap_flag_WS1__DeleteFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__DeleteFile * SOAP_FMAC6 soap_new___WS1__DeleteFile(struct soap *soap, int n)
{	return soap_instantiate___WS1__DeleteFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__DeleteFile(struct soap *soap, struct __WS1__DeleteFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__DeleteFile * SOAP_FMAC4 soap_instantiate___WS1__DeleteFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__DeleteFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__DeleteFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__DeleteFile;
		if (size)
			*size = sizeof(struct __WS1__DeleteFile);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__DeleteFile[n];
		if (size)
			*size = n * sizeof(struct __WS1__DeleteFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__DeleteFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__DeleteFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__DeleteFile %p -> %p\n", q, p));
	*(struct __WS1__DeleteFile*)p = *(struct __WS1__DeleteFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREValidateCert(struct soap *soap, const struct __WS1__SOF_USCOREValidateCert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREValidateCert(soap, &a->WS1__SOF_USCOREValidateCert_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREValidateCert(struct soap *soap, struct __WS1__SOF_USCOREValidateCert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREValidateCert_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREValidateCert(struct soap *soap, const struct __WS1__SOF_USCOREValidateCert *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREValidateCert(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREValidateCert *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREValidateCert(soap, "WS1:SOF_ValidateCert", -1, &a->WS1__SOF_USCOREValidateCert_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_get___WS1__SOF_USCOREValidateCert(struct soap *soap, struct __WS1__SOF_USCOREValidateCert *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREValidateCert(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_in___WS1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREValidateCert *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREValidateCert_ = 1;
	a = (struct __WS1__SOF_USCOREValidateCert *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREValidateCert, sizeof(struct __WS1__SOF_USCOREValidateCert), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREValidateCert(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREValidateCert_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREValidateCert(soap, "WS1:SOF_ValidateCert", &a->WS1__SOF_USCOREValidateCert_, "WS1:SOF_ValidateCert"))
				{	soap_flag_WS1__SOF_USCOREValidateCert_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREValidateCert * SOAP_FMAC6 soap_new___WS1__SOF_USCOREValidateCert(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREValidateCert(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREValidateCert(struct soap *soap, struct __WS1__SOF_USCOREValidateCert *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREValidateCert * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREValidateCert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREValidateCert(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREValidateCert, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREValidateCert;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREValidateCert);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREValidateCert[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREValidateCert);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREValidateCert*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREValidateCert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREValidateCert %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREValidateCert*)p = *(struct __WS1__SOF_USCOREValidateCert*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const struct __WS1__SOF_USCORECreateTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampResponse(soap, &a->WS1__SOF_USCORECreateTimeStampResponse_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct __WS1__SOF_USCORECreateTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORECreateTimeStampResponse_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const struct __WS1__SOF_USCORECreateTimeStampResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORECreateTimeStampResponse(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORECreateTimeStampResponse *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORECreateTimeStampResponse(soap, "WS1:SOF_CreateTimeStampResponse", -1, &a->WS1__SOF_USCORECreateTimeStampResponse_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_get___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct __WS1__SOF_USCORECreateTimeStampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORECreateTimeStampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_in___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, struct __WS1__SOF_USCORECreateTimeStampResponse *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORECreateTimeStampResponse_ = 1;
	a = (struct __WS1__SOF_USCORECreateTimeStampResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORECreateTimeStampResponse, sizeof(struct __WS1__SOF_USCORECreateTimeStampResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORECreateTimeStampResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORECreateTimeStampResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORECreateTimeStampResponse(soap, "WS1:SOF_CreateTimeStampResponse", &a->WS1__SOF_USCORECreateTimeStampResponse_, "WS1:SOF_CreateTimeStampResponse"))
				{	soap_flag_WS1__SOF_USCORECreateTimeStampResponse_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC6 soap_new___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORECreateTimeStampResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, struct __WS1__SOF_USCORECreateTimeStampResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORECreateTimeStampResponse * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORECreateTimeStampResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORECreateTimeStampResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORECreateTimeStampResponse;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORECreateTimeStampResponse);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORECreateTimeStampResponse[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORECreateTimeStampResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORECreateTimeStampResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORECreateTimeStampResponse %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORECreateTimeStampResponse*)p = *(struct __WS1__SOF_USCORECreateTimeStampResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, const struct __WS1__SOF_USCOREGetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetEncryptMethod(soap, &a->WS1__SOF_USCOREGetEncryptMethod_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct __WS1__SOF_USCOREGetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetEncryptMethod_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, const struct __WS1__SOF_USCOREGetEncryptMethod *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetEncryptMethod(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetEncryptMethod *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetEncryptMethod(soap, "WS1:SOF_GetEncryptMethod", -1, &a->WS1__SOF_USCOREGetEncryptMethod_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct __WS1__SOF_USCOREGetEncryptMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetEncryptMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetEncryptMethod *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetEncryptMethod_ = 1;
	a = (struct __WS1__SOF_USCOREGetEncryptMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetEncryptMethod, sizeof(struct __WS1__SOF_USCOREGetEncryptMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetEncryptMethod(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetEncryptMethod_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetEncryptMethod(soap, "WS1:SOF_GetEncryptMethod", &a->WS1__SOF_USCOREGetEncryptMethod_, "WS1:SOF_GetEncryptMethod"))
				{	soap_flag_WS1__SOF_USCOREGetEncryptMethod_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetEncryptMethod * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetEncryptMethod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, struct __WS1__SOF_USCOREGetEncryptMethod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetEncryptMethod * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetEncryptMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetEncryptMethod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetEncryptMethod;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetEncryptMethod);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetEncryptMethod[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetEncryptMethod);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetEncryptMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetEncryptMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetEncryptMethod %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetEncryptMethod*)p = *(struct __WS1__SOF_USCOREGetEncryptMethod*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const struct __WS1__SOF_USCORECreateTimeStampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampRequest(soap, &a->WS1__SOF_USCORECreateTimeStampRequest_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct __WS1__SOF_USCORECreateTimeStampRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORECreateTimeStampRequest_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const struct __WS1__SOF_USCORECreateTimeStampRequest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORECreateTimeStampRequest(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORECreateTimeStampRequest *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORECreateTimeStampRequest(soap, "WS1:SOF_CreateTimeStampRequest", -1, &a->WS1__SOF_USCORECreateTimeStampRequest_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_get___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct __WS1__SOF_USCORECreateTimeStampRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORECreateTimeStampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_in___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, struct __WS1__SOF_USCORECreateTimeStampRequest *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORECreateTimeStampRequest_ = 1;
	a = (struct __WS1__SOF_USCORECreateTimeStampRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORECreateTimeStampRequest, sizeof(struct __WS1__SOF_USCORECreateTimeStampRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORECreateTimeStampRequest(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORECreateTimeStampRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORECreateTimeStampRequest(soap, "WS1:SOF_CreateTimeStampRequest", &a->WS1__SOF_USCORECreateTimeStampRequest_, "WS1:SOF_CreateTimeStampRequest"))
				{	soap_flag_WS1__SOF_USCORECreateTimeStampRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC6 soap_new___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORECreateTimeStampRequest(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, struct __WS1__SOF_USCORECreateTimeStampRequest *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORECreateTimeStampRequest * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORECreateTimeStampRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORECreateTimeStampRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORECreateTimeStampRequest;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORECreateTimeStampRequest);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORECreateTimeStampRequest[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORECreateTimeStampRequest);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORECreateTimeStampRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORECreateTimeStampRequest %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORECreateTimeStampRequest*)p = *(struct __WS1__SOF_USCORECreateTimeStampRequest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, const struct __WS1__SOF_USCORESetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORESetEncryptMethod(soap, &a->WS1__SOF_USCORESetEncryptMethod_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, struct __WS1__SOF_USCORESetEncryptMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORESetEncryptMethod_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, const struct __WS1__SOF_USCORESetEncryptMethod *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORESetEncryptMethod(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORESetEncryptMethod *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORESetEncryptMethod(soap, "WS1:SOF_SetEncryptMethod", -1, &a->WS1__SOF_USCORESetEncryptMethod_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_get___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, struct __WS1__SOF_USCORESetEncryptMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORESetEncryptMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_in___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, struct __WS1__SOF_USCORESetEncryptMethod *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORESetEncryptMethod_ = 1;
	a = (struct __WS1__SOF_USCORESetEncryptMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORESetEncryptMethod, sizeof(struct __WS1__SOF_USCORESetEncryptMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORESetEncryptMethod(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORESetEncryptMethod_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORESetEncryptMethod(soap, "WS1:SOF_SetEncryptMethod", &a->WS1__SOF_USCORESetEncryptMethod_, "WS1:SOF_SetEncryptMethod"))
				{	soap_flag_WS1__SOF_USCORESetEncryptMethod_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORESetEncryptMethod * SOAP_FMAC6 soap_new___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORESetEncryptMethod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, struct __WS1__SOF_USCORESetEncryptMethod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetEncryptMethod * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORESetEncryptMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORESetEncryptMethod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESetEncryptMethod;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORESetEncryptMethod);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESetEncryptMethod[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORESetEncryptMethod);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORESetEncryptMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORESetEncryptMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORESetEncryptMethod %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORESetEncryptMethod*)p = *(struct __WS1__SOF_USCORESetEncryptMethod*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORESetWebAppName(struct soap *soap, const struct __WS1__SOF_USCORESetWebAppName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORESetWebAppName(soap, &a->WS1__SOF_USCORESetWebAppName_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORESetWebAppName(struct soap *soap, struct __WS1__SOF_USCORESetWebAppName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORESetWebAppName_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORESetWebAppName(struct soap *soap, const struct __WS1__SOF_USCORESetWebAppName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORESetWebAppName(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORESetWebAppName *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORESetWebAppName(soap, "WS1:SOF_SetWebAppName", -1, &a->WS1__SOF_USCORESetWebAppName_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_get___WS1__SOF_USCORESetWebAppName(struct soap *soap, struct __WS1__SOF_USCORESetWebAppName *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORESetWebAppName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_in___WS1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, struct __WS1__SOF_USCORESetWebAppName *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORESetWebAppName_ = 1;
	a = (struct __WS1__SOF_USCORESetWebAppName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORESetWebAppName, sizeof(struct __WS1__SOF_USCORESetWebAppName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORESetWebAppName(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORESetWebAppName_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORESetWebAppName(soap, "WS1:SOF_SetWebAppName", &a->WS1__SOF_USCORESetWebAppName_, "WS1:SOF_SetWebAppName"))
				{	soap_flag_WS1__SOF_USCORESetWebAppName_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORESetWebAppName * SOAP_FMAC6 soap_new___WS1__SOF_USCORESetWebAppName(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORESetWebAppName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORESetWebAppName(struct soap *soap, struct __WS1__SOF_USCORESetWebAppName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetWebAppName * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORESetWebAppName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORESetWebAppName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORESetWebAppName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESetWebAppName;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORESetWebAppName);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESetWebAppName[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORESetWebAppName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORESetWebAppName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORESetWebAppName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORESetWebAppName %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORESetWebAppName*)p = *(struct __WS1__SOF_USCORESetWebAppName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetSignMethod(struct soap *soap, const struct __WS1__SOF_USCOREGetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetSignMethod(soap, &a->WS1__SOF_USCOREGetSignMethod_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetSignMethod(struct soap *soap, struct __WS1__SOF_USCOREGetSignMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetSignMethod_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetSignMethod(struct soap *soap, const struct __WS1__SOF_USCOREGetSignMethod *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetSignMethod(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetSignMethod *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetSignMethod(soap, "WS1:SOF_GetSignMethod", -1, &a->WS1__SOF_USCOREGetSignMethod_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetSignMethod(struct soap *soap, struct __WS1__SOF_USCOREGetSignMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetSignMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetSignMethod *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetSignMethod_ = 1;
	a = (struct __WS1__SOF_USCOREGetSignMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetSignMethod, sizeof(struct __WS1__SOF_USCOREGetSignMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetSignMethod(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetSignMethod_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetSignMethod(soap, "WS1:SOF_GetSignMethod", &a->WS1__SOF_USCOREGetSignMethod_, "WS1:SOF_GetSignMethod"))
				{	soap_flag_WS1__SOF_USCOREGetSignMethod_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetSignMethod * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetSignMethod(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetSignMethod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetSignMethod(struct soap *soap, struct __WS1__SOF_USCOREGetSignMethod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetSignMethod * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetSignMethod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetSignMethod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetSignMethod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetSignMethod;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetSignMethod);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetSignMethod[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetSignMethod);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetSignMethod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetSignMethod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetSignMethod %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetSignMethod*)p = *(struct __WS1__SOF_USCOREGetSignMethod*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGenRandom(struct soap *soap, const struct __WS1__SOF_USCOREGenRandom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGenRandom(soap, &a->WS1__SOF_USCOREGenRandom_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGenRandom(struct soap *soap, struct __WS1__SOF_USCOREGenRandom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGenRandom_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGenRandom(struct soap *soap, const struct __WS1__SOF_USCOREGenRandom *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGenRandom(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGenRandom *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGenRandom(soap, "WS1:SOF_GenRandom", -1, &a->WS1__SOF_USCOREGenRandom_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGenRandom(struct soap *soap, struct __WS1__SOF_USCOREGenRandom *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGenRandom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGenRandom *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGenRandom_ = 1;
	a = (struct __WS1__SOF_USCOREGenRandom *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGenRandom, sizeof(struct __WS1__SOF_USCOREGenRandom), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGenRandom(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGenRandom_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGenRandom(soap, "WS1:SOF_GenRandom", &a->WS1__SOF_USCOREGenRandom_, "WS1:SOF_GenRandom"))
				{	soap_flag_WS1__SOF_USCOREGenRandom_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGenRandom * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGenRandom(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGenRandom(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGenRandom(struct soap *soap, struct __WS1__SOF_USCOREGenRandom *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGenRandom * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGenRandom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGenRandom(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGenRandom, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGenRandom;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGenRandom);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGenRandom[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGenRandom);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGenRandom*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGenRandom(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGenRandom %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGenRandom*)p = *(struct __WS1__SOF_USCOREGenRandom*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const struct __WS1__SOF_USCOREPriKeyDecrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREPriKeyDecrypt(soap, &a->WS1__SOF_USCOREPriKeyDecrypt_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct __WS1__SOF_USCOREPriKeyDecrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREPriKeyDecrypt_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const struct __WS1__SOF_USCOREPriKeyDecrypt *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREPriKeyDecrypt(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREPriKeyDecrypt *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREPriKeyDecrypt(soap, "WS1:SOF_PriKeyDecrypt", -1, &a->WS1__SOF_USCOREPriKeyDecrypt_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_get___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct __WS1__SOF_USCOREPriKeyDecrypt *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREPriKeyDecrypt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_in___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREPriKeyDecrypt *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREPriKeyDecrypt_ = 1;
	a = (struct __WS1__SOF_USCOREPriKeyDecrypt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREPriKeyDecrypt, sizeof(struct __WS1__SOF_USCOREPriKeyDecrypt), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREPriKeyDecrypt(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREPriKeyDecrypt_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREPriKeyDecrypt(soap, "WS1:SOF_PriKeyDecrypt", &a->WS1__SOF_USCOREPriKeyDecrypt_, "WS1:SOF_PriKeyDecrypt"))
				{	soap_flag_WS1__SOF_USCOREPriKeyDecrypt_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC6 soap_new___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREPriKeyDecrypt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, struct __WS1__SOF_USCOREPriKeyDecrypt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREPriKeyDecrypt * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREPriKeyDecrypt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREPriKeyDecrypt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREPriKeyDecrypt;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREPriKeyDecrypt);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREPriKeyDecrypt[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREPriKeyDecrypt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREPriKeyDecrypt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREPriKeyDecrypt %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREPriKeyDecrypt*)p = *(struct __WS1__SOF_USCOREPriKeyDecrypt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetInstance(struct soap *soap, const struct __WS1__SOF_USCOREGetInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetInstance(soap, &a->WS1__SOF_USCOREGetInstance_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetInstance(struct soap *soap, struct __WS1__SOF_USCOREGetInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetInstance_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetInstance(struct soap *soap, const struct __WS1__SOF_USCOREGetInstance *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetInstance(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetInstance *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetInstance(soap, "WS1:SOF_GetInstance", -1, &a->WS1__SOF_USCOREGetInstance_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetInstance(struct soap *soap, struct __WS1__SOF_USCOREGetInstance *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetInstance(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetInstance *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetInstance_ = 1;
	a = (struct __WS1__SOF_USCOREGetInstance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetInstance, sizeof(struct __WS1__SOF_USCOREGetInstance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetInstance(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetInstance_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetInstance(soap, "WS1:SOF_GetInstance", &a->WS1__SOF_USCOREGetInstance_, "WS1:SOF_GetInstance"))
				{	soap_flag_WS1__SOF_USCOREGetInstance_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetInstance * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetInstance(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetInstance(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetInstance(struct soap *soap, struct __WS1__SOF_USCOREGetInstance *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetInstance * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetInstance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetInstance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetInstance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetInstance;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetInstance);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetInstance[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetInstance);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetInstance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetInstance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetInstance %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetInstance*)p = *(struct __WS1__SOF_USCOREGetInstance*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORESignFile(struct soap *soap, const struct __WS1__SOF_USCORESignFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORESignFile(soap, &a->WS1__SOF_USCORESignFile_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORESignFile(struct soap *soap, struct __WS1__SOF_USCORESignFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORESignFile_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORESignFile(struct soap *soap, const struct __WS1__SOF_USCORESignFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORESignFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORESignFile(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORESignFile *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORESignFile(soap, "WS1:SOF_SignFile", -1, &a->WS1__SOF_USCORESignFile_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignFile * SOAP_FMAC4 soap_get___WS1__SOF_USCORESignFile(struct soap *soap, struct __WS1__SOF_USCORESignFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORESignFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignFile * SOAP_FMAC4 soap_in___WS1__SOF_USCORESignFile(struct soap *soap, const char *tag, struct __WS1__SOF_USCORESignFile *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORESignFile_ = 1;
	a = (struct __WS1__SOF_USCORESignFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORESignFile, sizeof(struct __WS1__SOF_USCORESignFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORESignFile(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORESignFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORESignFile(soap, "WS1:SOF_SignFile", &a->WS1__SOF_USCORESignFile_, "WS1:SOF_SignFile"))
				{	soap_flag_WS1__SOF_USCORESignFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORESignFile * SOAP_FMAC6 soap_new___WS1__SOF_USCORESignFile(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORESignFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORESignFile(struct soap *soap, struct __WS1__SOF_USCORESignFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignFile * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORESignFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORESignFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORESignFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESignFile;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORESignFile);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESignFile[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORESignFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORESignFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORESignFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORESignFile %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORESignFile*)p = *(struct __WS1__SOF_USCORESignFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const struct __WS1__SOF_USCOREVerifySignedDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataXML(soap, &a->WS1__SOF_USCOREVerifySignedDataXML_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedDataXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREVerifySignedDataXML_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const struct __WS1__SOF_USCOREVerifySignedDataXML *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREVerifySignedDataXML(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREVerifySignedDataXML *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREVerifySignedDataXML(soap, "WS1:SOF_VerifySignedDataXML", -1, &a->WS1__SOF_USCOREVerifySignedDataXML_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_get___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedDataXML *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREVerifySignedDataXML(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_in___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREVerifySignedDataXML *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREVerifySignedDataXML_ = 1;
	a = (struct __WS1__SOF_USCOREVerifySignedDataXML *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataXML, sizeof(struct __WS1__SOF_USCOREVerifySignedDataXML), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREVerifySignedDataXML(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREVerifySignedDataXML_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREVerifySignedDataXML(soap, "WS1:SOF_VerifySignedDataXML", &a->WS1__SOF_USCOREVerifySignedDataXML_, "WS1:SOF_VerifySignedDataXML"))
				{	soap_flag_WS1__SOF_USCOREVerifySignedDataXML_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC6 soap_new___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREVerifySignedDataXML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedDataXML *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedDataXML * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREVerifySignedDataXML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataXML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifySignedDataXML;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREVerifySignedDataXML);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifySignedDataXML[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREVerifySignedDataXML);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREVerifySignedDataXML*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREVerifySignedDataXML %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREVerifySignedDataXML*)p = *(struct __WS1__SOF_USCOREVerifySignedDataXML*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORESignData(struct soap *soap, const struct __WS1__SOF_USCORESignData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORESignData(soap, &a->WS1__SOF_USCORESignData_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORESignData(struct soap *soap, struct __WS1__SOF_USCORESignData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORESignData_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORESignData(struct soap *soap, const struct __WS1__SOF_USCORESignData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORESignData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORESignData(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORESignData *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORESignData(soap, "WS1:SOF_SignData", -1, &a->WS1__SOF_USCORESignData_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignData * SOAP_FMAC4 soap_get___WS1__SOF_USCORESignData(struct soap *soap, struct __WS1__SOF_USCORESignData *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORESignData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignData * SOAP_FMAC4 soap_in___WS1__SOF_USCORESignData(struct soap *soap, const char *tag, struct __WS1__SOF_USCORESignData *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORESignData_ = 1;
	a = (struct __WS1__SOF_USCORESignData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORESignData, sizeof(struct __WS1__SOF_USCORESignData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORESignData(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORESignData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORESignData(soap, "WS1:SOF_SignData", &a->WS1__SOF_USCORESignData_, "WS1:SOF_SignData"))
				{	soap_flag_WS1__SOF_USCORESignData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORESignData * SOAP_FMAC6 soap_new___WS1__SOF_USCORESignData(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORESignData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORESignData(struct soap *soap, struct __WS1__SOF_USCORESignData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORESignData * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORESignData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORESignData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORESignData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESignData;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORESignData);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESignData[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORESignData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORESignData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORESignData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORESignData %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORESignData*)p = *(struct __WS1__SOF_USCORESignData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const struct __WS1__SOF_USCOREGetXMLSignatureInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(soap, &a->WS1__SOF_USCOREGetXMLSignatureInfo_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct __WS1__SOF_USCOREGetXMLSignatureInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetXMLSignatureInfo_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const struct __WS1__SOF_USCOREGetXMLSignatureInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetXMLSignatureInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetXMLSignatureInfo *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(soap, "WS1:SOF_GetXMLSignatureInfo", -1, &a->WS1__SOF_USCOREGetXMLSignatureInfo_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct __WS1__SOF_USCOREGetXMLSignatureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetXMLSignatureInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetXMLSignatureInfo *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetXMLSignatureInfo_ = 1;
	a = (struct __WS1__SOF_USCOREGetXMLSignatureInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetXMLSignatureInfo, sizeof(struct __WS1__SOF_USCOREGetXMLSignatureInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetXMLSignatureInfo(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetXMLSignatureInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(soap, "WS1:SOF_GetXMLSignatureInfo", &a->WS1__SOF_USCOREGetXMLSignatureInfo_, "WS1:SOF_GetXMLSignatureInfo"))
				{	soap_flag_WS1__SOF_USCOREGetXMLSignatureInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetXMLSignatureInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, struct __WS1__SOF_USCOREGetXMLSignatureInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetXMLSignatureInfo * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetXMLSignatureInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetXMLSignatureInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetXMLSignatureInfo;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetXMLSignatureInfo);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetXMLSignatureInfo[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetXMLSignatureInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetXMLSignatureInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetXMLSignatureInfo %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetXMLSignatureInfo*)p = *(struct __WS1__SOF_USCOREGetXMLSignatureInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, const struct __WS1__SOF_USCOREDelCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREDelCertTrustList(soap, &a->WS1__SOF_USCOREDelCertTrustList_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, struct __WS1__SOF_USCOREDelCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREDelCertTrustList_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, const struct __WS1__SOF_USCOREDelCertTrustList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREDelCertTrustList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREDelCertTrustList *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREDelCertTrustList(soap, "WS1:SOF_DelCertTrustList", -1, &a->WS1__SOF_USCOREDelCertTrustList_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_get___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, struct __WS1__SOF_USCOREDelCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREDelCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_in___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREDelCertTrustList *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREDelCertTrustList_ = 1;
	a = (struct __WS1__SOF_USCOREDelCertTrustList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREDelCertTrustList, sizeof(struct __WS1__SOF_USCOREDelCertTrustList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREDelCertTrustList(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREDelCertTrustList_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREDelCertTrustList(soap, "WS1:SOF_DelCertTrustList", &a->WS1__SOF_USCOREDelCertTrustList_, "WS1:SOF_DelCertTrustList"))
				{	soap_flag_WS1__SOF_USCOREDelCertTrustList_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREDelCertTrustList * SOAP_FMAC6 soap_new___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREDelCertTrustList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, struct __WS1__SOF_USCOREDelCertTrustList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREDelCertTrustList * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREDelCertTrustList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREDelCertTrustList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREDelCertTrustList;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREDelCertTrustList);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREDelCertTrustList[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREDelCertTrustList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREDelCertTrustList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREDelCertTrustList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREDelCertTrustList %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREDelCertTrustList*)p = *(struct __WS1__SOF_USCOREDelCertTrustList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, const struct __WS1__SOF_USCOREGetServerCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetServerCertificate(soap, &a->WS1__SOF_USCOREGetServerCertificate_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, struct __WS1__SOF_USCOREGetServerCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetServerCertificate_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, const struct __WS1__SOF_USCOREGetServerCertificate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetServerCertificate(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetServerCertificate *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetServerCertificate(soap, "WS1:SOF_GetServerCertificate", -1, &a->WS1__SOF_USCOREGetServerCertificate_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, struct __WS1__SOF_USCOREGetServerCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetServerCertificate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetServerCertificate *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetServerCertificate_ = 1;
	a = (struct __WS1__SOF_USCOREGetServerCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetServerCertificate, sizeof(struct __WS1__SOF_USCOREGetServerCertificate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetServerCertificate(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetServerCertificate_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetServerCertificate(soap, "WS1:SOF_GetServerCertificate", &a->WS1__SOF_USCOREGetServerCertificate_, "WS1:SOF_GetServerCertificate"))
				{	soap_flag_WS1__SOF_USCOREGetServerCertificate_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetServerCertificate * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetServerCertificate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, struct __WS1__SOF_USCOREGetServerCertificate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetServerCertificate * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetServerCertificate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetServerCertificate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetServerCertificate;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetServerCertificate);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetServerCertificate[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetServerCertificate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetServerCertificate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetServerCertificate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetServerCertificate %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetServerCertificate*)p = *(struct __WS1__SOF_USCOREGetServerCertificate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const struct __WS1__SOF_USCOREGetCertInfoByOid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetCertInfoByOid(soap, &a->WS1__SOF_USCOREGetCertInfoByOid_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct __WS1__SOF_USCOREGetCertInfoByOid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetCertInfoByOid_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const struct __WS1__SOF_USCOREGetCertInfoByOid *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetCertInfoByOid(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetCertInfoByOid *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetCertInfoByOid(soap, "WS1:SOF_GetCertInfoByOid", -1, &a->WS1__SOF_USCOREGetCertInfoByOid_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct __WS1__SOF_USCOREGetCertInfoByOid *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetCertInfoByOid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetCertInfoByOid *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetCertInfoByOid_ = 1;
	a = (struct __WS1__SOF_USCOREGetCertInfoByOid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetCertInfoByOid, sizeof(struct __WS1__SOF_USCOREGetCertInfoByOid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetCertInfoByOid(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetCertInfoByOid_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetCertInfoByOid(soap, "WS1:SOF_GetCertInfoByOid", &a->WS1__SOF_USCOREGetCertInfoByOid_, "WS1:SOF_GetCertInfoByOid"))
				{	soap_flag_WS1__SOF_USCOREGetCertInfoByOid_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetCertInfoByOid(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, struct __WS1__SOF_USCOREGetCertInfoByOid *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetCertInfoByOid * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetCertInfoByOid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetCertInfoByOid, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetCertInfoByOid;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetCertInfoByOid);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetCertInfoByOid[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetCertInfoByOid);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetCertInfoByOid*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetCertInfoByOid %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetCertInfoByOid*)p = *(struct __WS1__SOF_USCOREGetCertInfoByOid*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, const struct __WS1__SOF_USCOREVerifySignedFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREVerifySignedFile(soap, &a->WS1__SOF_USCOREVerifySignedFile_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREVerifySignedFile_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, const struct __WS1__SOF_USCOREVerifySignedFile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREVerifySignedFile(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREVerifySignedFile *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREVerifySignedFile(soap, "WS1:SOF_VerifySignedFile", -1, &a->WS1__SOF_USCOREVerifySignedFile_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_get___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREVerifySignedFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_in___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREVerifySignedFile *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREVerifySignedFile_ = 1;
	a = (struct __WS1__SOF_USCOREVerifySignedFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREVerifySignedFile, sizeof(struct __WS1__SOF_USCOREVerifySignedFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREVerifySignedFile(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREVerifySignedFile_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREVerifySignedFile(soap, "WS1:SOF_VerifySignedFile", &a->WS1__SOF_USCOREVerifySignedFile_, "WS1:SOF_VerifySignedFile"))
				{	soap_flag_WS1__SOF_USCOREVerifySignedFile_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREVerifySignedFile * SOAP_FMAC6 soap_new___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREVerifySignedFile(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedFile *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedFile * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREVerifySignedFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREVerifySignedFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifySignedFile;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREVerifySignedFile);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifySignedFile[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREVerifySignedFile);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREVerifySignedFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREVerifySignedFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREVerifySignedFile %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREVerifySignedFile*)p = *(struct __WS1__SOF_USCOREVerifySignedFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const struct __WS1__SOF_USCOREVerifyTimeStamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREVerifyTimeStamp(soap, &a->WS1__SOF_USCOREVerifyTimeStamp_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct __WS1__SOF_USCOREVerifyTimeStamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREVerifyTimeStamp_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const struct __WS1__SOF_USCOREVerifyTimeStamp *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREVerifyTimeStamp(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREVerifyTimeStamp *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREVerifyTimeStamp(soap, "WS1:SOF_VerifyTimeStamp", -1, &a->WS1__SOF_USCOREVerifyTimeStamp_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_get___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct __WS1__SOF_USCOREVerifyTimeStamp *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREVerifyTimeStamp(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_in___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREVerifyTimeStamp *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREVerifyTimeStamp_ = 1;
	a = (struct __WS1__SOF_USCOREVerifyTimeStamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREVerifyTimeStamp, sizeof(struct __WS1__SOF_USCOREVerifyTimeStamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREVerifyTimeStamp(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREVerifyTimeStamp_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREVerifyTimeStamp(soap, "WS1:SOF_VerifyTimeStamp", &a->WS1__SOF_USCOREVerifyTimeStamp_, "WS1:SOF_VerifyTimeStamp"))
				{	soap_flag_WS1__SOF_USCOREVerifyTimeStamp_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC6 soap_new___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREVerifyTimeStamp(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, struct __WS1__SOF_USCOREVerifyTimeStamp *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifyTimeStamp * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREVerifyTimeStamp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREVerifyTimeStamp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifyTimeStamp;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREVerifyTimeStamp);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifyTimeStamp[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREVerifyTimeStamp);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREVerifyTimeStamp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREVerifyTimeStamp %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREVerifyTimeStamp*)p = *(struct __WS1__SOF_USCOREVerifyTimeStamp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const struct __WS1__SOF_USCOREPubKeyEncrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREPubKeyEncrypt(soap, &a->WS1__SOF_USCOREPubKeyEncrypt_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct __WS1__SOF_USCOREPubKeyEncrypt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREPubKeyEncrypt_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const struct __WS1__SOF_USCOREPubKeyEncrypt *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREPubKeyEncrypt(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREPubKeyEncrypt *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREPubKeyEncrypt(soap, "WS1:SOF_PubKeyEncrypt", -1, &a->WS1__SOF_USCOREPubKeyEncrypt_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_get___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct __WS1__SOF_USCOREPubKeyEncrypt *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREPubKeyEncrypt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_in___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREPubKeyEncrypt *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREPubKeyEncrypt_ = 1;
	a = (struct __WS1__SOF_USCOREPubKeyEncrypt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREPubKeyEncrypt, sizeof(struct __WS1__SOF_USCOREPubKeyEncrypt), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREPubKeyEncrypt(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREPubKeyEncrypt_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREPubKeyEncrypt(soap, "WS1:SOF_PubKeyEncrypt", &a->WS1__SOF_USCOREPubKeyEncrypt_, "WS1:SOF_PubKeyEncrypt"))
				{	soap_flag_WS1__SOF_USCOREPubKeyEncrypt_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC6 soap_new___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREPubKeyEncrypt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, struct __WS1__SOF_USCOREPubKeyEncrypt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREPubKeyEncrypt * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREPubKeyEncrypt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREPubKeyEncrypt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREPubKeyEncrypt;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREPubKeyEncrypt);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREPubKeyEncrypt[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREPubKeyEncrypt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREPubKeyEncrypt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREPubKeyEncrypt %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREPubKeyEncrypt*)p = *(struct __WS1__SOF_USCOREPubKeyEncrypt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const struct __WS1__SOF_USCOREVerifySignedDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataByP7(soap, &a->WS1__SOF_USCOREVerifySignedDataByP7_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedDataByP7 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREVerifySignedDataByP7_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const struct __WS1__SOF_USCOREVerifySignedDataByP7 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREVerifySignedDataByP7(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREVerifySignedDataByP7 *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREVerifySignedDataByP7(soap, "WS1:SOF_VerifySignedDataByP7", -1, &a->WS1__SOF_USCOREVerifySignedDataByP7_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_get___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedDataByP7 *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREVerifySignedDataByP7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_in___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREVerifySignedDataByP7 *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREVerifySignedDataByP7_ = 1;
	a = (struct __WS1__SOF_USCOREVerifySignedDataByP7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataByP7, sizeof(struct __WS1__SOF_USCOREVerifySignedDataByP7), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREVerifySignedDataByP7(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREVerifySignedDataByP7_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREVerifySignedDataByP7(soap, "WS1:SOF_VerifySignedDataByP7", &a->WS1__SOF_USCOREVerifySignedDataByP7_, "WS1:SOF_VerifySignedDataByP7"))
				{	soap_flag_WS1__SOF_USCOREVerifySignedDataByP7_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC6 soap_new___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREVerifySignedDataByP7(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedDataByP7 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedDataByP7 * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREVerifySignedDataByP7(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREVerifySignedDataByP7, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifySignedDataByP7;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREVerifySignedDataByP7);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifySignedDataByP7[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREVerifySignedDataByP7);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREVerifySignedDataByP7*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREVerifySignedDataByP7 %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREVerifySignedDataByP7*)p = *(struct __WS1__SOF_USCOREVerifySignedDataByP7*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCORESetCertTrustList(struct soap *soap, const struct __WS1__SOF_USCORESetCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCORESetCertTrustList(soap, &a->WS1__SOF_USCORESetCertTrustList_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCORESetCertTrustList(struct soap *soap, struct __WS1__SOF_USCORESetCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCORESetCertTrustList_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCORESetCertTrustList(struct soap *soap, const struct __WS1__SOF_USCORESetCertTrustList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCORESetCertTrustList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCORESetCertTrustList *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCORESetCertTrustList(soap, "WS1:SOF_SetCertTrustList", -1, &a->WS1__SOF_USCORESetCertTrustList_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_get___WS1__SOF_USCORESetCertTrustList(struct soap *soap, struct __WS1__SOF_USCORESetCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCORESetCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_in___WS1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, struct __WS1__SOF_USCORESetCertTrustList *a, const char *type)
{
	short soap_flag_WS1__SOF_USCORESetCertTrustList_ = 1;
	a = (struct __WS1__SOF_USCORESetCertTrustList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCORESetCertTrustList, sizeof(struct __WS1__SOF_USCORESetCertTrustList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCORESetCertTrustList(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCORESetCertTrustList_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCORESetCertTrustList(soap, "WS1:SOF_SetCertTrustList", &a->WS1__SOF_USCORESetCertTrustList_, "WS1:SOF_SetCertTrustList"))
				{	soap_flag_WS1__SOF_USCORESetCertTrustList_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCORESetCertTrustList * SOAP_FMAC6 soap_new___WS1__SOF_USCORESetCertTrustList(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCORESetCertTrustList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCORESetCertTrustList(struct soap *soap, struct __WS1__SOF_USCORESetCertTrustList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCORESetCertTrustList * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCORESetCertTrustList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCORESetCertTrustList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCORESetCertTrustList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESetCertTrustList;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCORESetCertTrustList);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCORESetCertTrustList[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCORESetCertTrustList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCORESetCertTrustList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCORESetCertTrustList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCORESetCertTrustList %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCORESetCertTrustList*)p = *(struct __WS1__SOF_USCORESetCertTrustList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const struct __WS1__SOF_USCOREGetP7SignDataInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREGetP7SignDataInfo(soap, &a->WS1__SOF_USCOREGetP7SignDataInfo_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct __WS1__SOF_USCOREGetP7SignDataInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREGetP7SignDataInfo_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const struct __WS1__SOF_USCOREGetP7SignDataInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREGetP7SignDataInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREGetP7SignDataInfo *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREGetP7SignDataInfo(soap, "WS1:SOF_GetP7SignDataInfo", -1, &a->WS1__SOF_USCOREGetP7SignDataInfo_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_get___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct __WS1__SOF_USCOREGetP7SignDataInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREGetP7SignDataInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_in___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREGetP7SignDataInfo *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREGetP7SignDataInfo_ = 1;
	a = (struct __WS1__SOF_USCOREGetP7SignDataInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREGetP7SignDataInfo, sizeof(struct __WS1__SOF_USCOREGetP7SignDataInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREGetP7SignDataInfo(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREGetP7SignDataInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREGetP7SignDataInfo(soap, "WS1:SOF_GetP7SignDataInfo", &a->WS1__SOF_USCOREGetP7SignDataInfo_, "WS1:SOF_GetP7SignDataInfo"))
				{	soap_flag_WS1__SOF_USCOREGetP7SignDataInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC6 soap_new___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREGetP7SignDataInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, struct __WS1__SOF_USCOREGetP7SignDataInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREGetP7SignDataInfo * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREGetP7SignDataInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREGetP7SignDataInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetP7SignDataInfo;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREGetP7SignDataInfo);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREGetP7SignDataInfo[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREGetP7SignDataInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREGetP7SignDataInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREGetP7SignDataInfo %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREGetP7SignDataInfo*)p = *(struct __WS1__SOF_USCOREGetP7SignDataInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, const struct __WS1__SOF_USCOREQueryCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustList(soap, &a->WS1__SOF_USCOREQueryCertTrustList_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct __WS1__SOF_USCOREQueryCertTrustList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREQueryCertTrustList_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, const struct __WS1__SOF_USCOREQueryCertTrustList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREQueryCertTrustList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREQueryCertTrustList *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREQueryCertTrustList(soap, "WS1:SOF_QueryCertTrustList", -1, &a->WS1__SOF_USCOREQueryCertTrustList_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_get___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct __WS1__SOF_USCOREQueryCertTrustList *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREQueryCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_in___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREQueryCertTrustList *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREQueryCertTrustList_ = 1;
	a = (struct __WS1__SOF_USCOREQueryCertTrustList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustList, sizeof(struct __WS1__SOF_USCOREQueryCertTrustList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREQueryCertTrustList(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREQueryCertTrustList_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREQueryCertTrustList(soap, "WS1:SOF_QueryCertTrustList", &a->WS1__SOF_USCOREQueryCertTrustList_, "WS1:SOF_QueryCertTrustList"))
				{	soap_flag_WS1__SOF_USCOREQueryCertTrustList_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREQueryCertTrustList * SOAP_FMAC6 soap_new___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREQueryCertTrustList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, struct __WS1__SOF_USCOREQueryCertTrustList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREQueryCertTrustList * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREQueryCertTrustList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREQueryCertTrustList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREQueryCertTrustList;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREQueryCertTrustList);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREQueryCertTrustList[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREQueryCertTrustList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREQueryCertTrustList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREQueryCertTrustList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREQueryCertTrustList %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREQueryCertTrustList*)p = *(struct __WS1__SOF_USCOREQueryCertTrustList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___WS1__SOF_USCOREVerifySignedData(struct soap *soap, const struct __WS1__SOF_USCOREVerifySignedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToWS1__SOF_USCOREVerifySignedData(soap, &a->WS1__SOF_USCOREVerifySignedData_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___WS1__SOF_USCOREVerifySignedData(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WS1__SOF_USCOREVerifySignedData_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___WS1__SOF_USCOREVerifySignedData(struct soap *soap, const struct __WS1__SOF_USCOREVerifySignedData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___WS1__SOF_USCOREVerifySignedData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___WS1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, int id, const struct __WS1__SOF_USCOREVerifySignedData *a, const char *type)
{
	soap_out_PointerToWS1__SOF_USCOREVerifySignedData(soap, "WS1:SOF_VerifySignedData", -1, &a->WS1__SOF_USCOREVerifySignedData_, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_get___WS1__SOF_USCOREVerifySignedData(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedData *p, const char *tag, const char *type)
{
	if ((p = soap_in___WS1__SOF_USCOREVerifySignedData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_in___WS1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, struct __WS1__SOF_USCOREVerifySignedData *a, const char *type)
{
	short soap_flag_WS1__SOF_USCOREVerifySignedData_ = 1;
	a = (struct __WS1__SOF_USCOREVerifySignedData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___WS1__SOF_USCOREVerifySignedData, sizeof(struct __WS1__SOF_USCOREVerifySignedData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___WS1__SOF_USCOREVerifySignedData(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WS1__SOF_USCOREVerifySignedData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToWS1__SOF_USCOREVerifySignedData(soap, "WS1:SOF_VerifySignedData", &a->WS1__SOF_USCOREVerifySignedData_, "WS1:SOF_VerifySignedData"))
				{	soap_flag_WS1__SOF_USCOREVerifySignedData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __WS1__SOF_USCOREVerifySignedData * SOAP_FMAC6 soap_new___WS1__SOF_USCOREVerifySignedData(struct soap *soap, int n)
{	return soap_instantiate___WS1__SOF_USCOREVerifySignedData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___WS1__SOF_USCOREVerifySignedData(struct soap *soap, struct __WS1__SOF_USCOREVerifySignedData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __WS1__SOF_USCOREVerifySignedData * SOAP_FMAC4 soap_instantiate___WS1__SOF_USCOREVerifySignedData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___WS1__SOF_USCOREVerifySignedData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___WS1__SOF_USCOREVerifySignedData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifySignedData;
		if (size)
			*size = sizeof(struct __WS1__SOF_USCOREVerifySignedData);
	}
	else
	{	cp->ptr = (void*)new struct __WS1__SOF_USCOREVerifySignedData[n];
		if (size)
			*size = n * sizeof(struct __WS1__SOF_USCOREVerifySignedData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __WS1__SOF_USCOREVerifySignedData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___WS1__SOF_USCOREVerifySignedData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __WS1__SOF_USCOREVerifySignedData %p -> %p\n", q, p));
	*(struct __WS1__SOF_USCOREVerifySignedData*)p = *(struct __WS1__SOF_USCOREVerifySignedData*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREEncryptDataResponse(struct soap *soap, WS1__SOF_USCOREEncryptDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREEncryptDataResponse(struct soap *soap, WS1__SOF_USCOREEncryptDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptDataResponse);
	if (soap_out_PointerToWS1__SOF_USCOREEncryptDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREEncryptDataResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREEncryptDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptDataResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREEncryptDataResponse(struct soap *soap, WS1__SOF_USCOREEncryptDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREEncryptDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptDataResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREEncryptDataResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREEncryptDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREEncryptDataResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREEncryptDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREEncryptDataResponse *)soap_instantiate_WS1__SOF_USCOREEncryptDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREEncryptDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREEncryptDataResponse, sizeof(WS1__SOF_USCOREEncryptDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREEncryptData(struct soap *soap, WS1__SOF_USCOREEncryptData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREEncryptData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREEncryptData(struct soap *soap, WS1__SOF_USCOREEncryptData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptData);
	if (soap_out_PointerToWS1__SOF_USCOREEncryptData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREEncryptData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREEncryptData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptData ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREEncryptData(struct soap *soap, WS1__SOF_USCOREEncryptData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREEncryptData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptData ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREEncryptData(struct soap *soap, const char *tag, WS1__SOF_USCOREEncryptData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREEncryptData **)soap_malloc(soap, sizeof(WS1__SOF_USCOREEncryptData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREEncryptData *)soap_instantiate_WS1__SOF_USCOREEncryptData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREEncryptData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREEncryptData, sizeof(WS1__SOF_USCOREEncryptData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse);
	if (soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNamesResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNamesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNamesResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListAltNamesResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREQueryCertTrustListAltNamesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse *)soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREQueryCertTrustListAltNamesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNamesResponse, sizeof(WS1__SOF_USCOREQueryCertTrustListAltNamesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNames *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNames *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames);
	if (soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREQueryCertTrustListAltNames *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNames ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListAltNames **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListAltNames ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListAltNames(struct soap *soap, const char *tag, WS1__SOF_USCOREQueryCertTrustListAltNames **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREQueryCertTrustListAltNames **)soap_malloc(soap, sizeof(WS1__SOF_USCOREQueryCertTrustListAltNames *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREQueryCertTrustListAltNames *)soap_instantiate_WS1__SOF_USCOREQueryCertTrustListAltNames(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREQueryCertTrustListAltNames **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListAltNames, sizeof(WS1__SOF_USCOREQueryCertTrustListAltNames), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetCertInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetCertInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetCertInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetCertInfoResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetCertInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetCertInfoResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetCertInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetCertInfoResponse *)soap_instantiate_WS1__SOF_USCOREGetCertInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetCertInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoResponse, sizeof(WS1__SOF_USCOREGetCertInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetCertInfo(struct soap *soap, WS1__SOF_USCOREGetCertInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetCertInfo(struct soap *soap, WS1__SOF_USCOREGetCertInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfo);
	if (soap_out_PointerToWS1__SOF_USCOREGetCertInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetCertInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetCertInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfo ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetCertInfo(struct soap *soap, WS1__SOF_USCOREGetCertInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetCertInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfo ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetCertInfo(struct soap *soap, const char *tag, WS1__SOF_USCOREGetCertInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetCertInfo **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetCertInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetCertInfo *)soap_instantiate_WS1__SOF_USCOREGetCertInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetCertInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfo, sizeof(WS1__SOF_USCOREGetCertInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESignDataXMLResponse(struct soap *soap, WS1__SOF_USCORESignDataXMLResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESignDataXMLResponse(struct soap *soap, WS1__SOF_USCORESignDataXMLResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESignDataXMLResponse);
	if (soap_out_PointerToWS1__SOF_USCORESignDataXMLResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESignDataXMLResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESignDataXMLResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXMLResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESignDataXMLResponse(struct soap *soap, WS1__SOF_USCORESignDataXMLResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESignDataXMLResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXMLResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESignDataXMLResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataXMLResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESignDataXMLResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORESignDataXMLResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESignDataXMLResponse *)soap_instantiate_WS1__SOF_USCORESignDataXMLResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataXMLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESignDataXMLResponse, sizeof(WS1__SOF_USCORESignDataXMLResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESignDataXML(struct soap *soap, WS1__SOF_USCORESignDataXML *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESignDataXML))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESignDataXML(struct soap *soap, WS1__SOF_USCORESignDataXML *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESignDataXML);
	if (soap_out_PointerToWS1__SOF_USCORESignDataXML(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESignDataXML *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESignDataXML);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXML ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESignDataXML(struct soap *soap, WS1__SOF_USCORESignDataXML **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESignDataXML(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESignDataXML ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESignDataXML(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataXML **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESignDataXML **)soap_malloc(soap, sizeof(WS1__SOF_USCORESignDataXML *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESignDataXML *)soap_instantiate_WS1__SOF_USCORESignDataXML(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataXML **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESignDataXML, sizeof(WS1__SOF_USCORESignDataXML), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREDecryptDataResponse(struct soap *soap, WS1__SOF_USCOREDecryptDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREDecryptDataResponse(struct soap *soap, WS1__SOF_USCOREDecryptDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptDataResponse);
	if (soap_out_PointerToWS1__SOF_USCOREDecryptDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREDecryptDataResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREDecryptDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptDataResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREDecryptDataResponse(struct soap *soap, WS1__SOF_USCOREDecryptDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREDecryptDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptDataResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREDecryptDataResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREDecryptDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREDecryptDataResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREDecryptDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREDecryptDataResponse *)soap_instantiate_WS1__SOF_USCOREDecryptDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDecryptDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREDecryptDataResponse, sizeof(WS1__SOF_USCOREDecryptDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREDecryptData(struct soap *soap, WS1__SOF_USCOREDecryptData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREDecryptData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREDecryptData(struct soap *soap, WS1__SOF_USCOREDecryptData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptData);
	if (soap_out_PointerToWS1__SOF_USCOREDecryptData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREDecryptData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREDecryptData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptData ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREDecryptData(struct soap *soap, WS1__SOF_USCOREDecryptData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREDecryptData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptData ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREDecryptData(struct soap *soap, const char *tag, WS1__SOF_USCOREDecryptData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREDecryptData **)soap_malloc(soap, sizeof(WS1__SOF_USCOREDecryptData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREDecryptData *)soap_instantiate_WS1__SOF_USCOREDecryptData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDecryptData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREDecryptData, sizeof(WS1__SOF_USCOREDecryptData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESignDataByP7Response(struct soap *soap, WS1__SOF_USCORESignDataByP7Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESignDataByP7Response(struct soap *soap, WS1__SOF_USCORESignDataByP7Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESignDataByP7Response);
	if (soap_out_PointerToWS1__SOF_USCORESignDataByP7Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESignDataByP7Response(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESignDataByP7Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7Response ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESignDataByP7Response(struct soap *soap, WS1__SOF_USCORESignDataByP7Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESignDataByP7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7Response ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESignDataByP7Response(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataByP7Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESignDataByP7Response **)soap_malloc(soap, sizeof(WS1__SOF_USCORESignDataByP7Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESignDataByP7Response *)soap_instantiate_WS1__SOF_USCORESignDataByP7Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataByP7Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESignDataByP7Response, sizeof(WS1__SOF_USCORESignDataByP7Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESignDataByP7(struct soap *soap, WS1__SOF_USCORESignDataByP7 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESignDataByP7))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESignDataByP7(struct soap *soap, WS1__SOF_USCORESignDataByP7 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESignDataByP7);
	if (soap_out_PointerToWS1__SOF_USCORESignDataByP7(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESignDataByP7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESignDataByP7);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7 ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESignDataByP7(struct soap *soap, WS1__SOF_USCORESignDataByP7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESignDataByP7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESignDataByP7 ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESignDataByP7(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataByP7 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESignDataByP7 **)soap_malloc(soap, sizeof(WS1__SOF_USCORESignDataByP7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESignDataByP7 *)soap_instantiate_WS1__SOF_USCORESignDataByP7(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataByP7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESignDataByP7, sizeof(WS1__SOF_USCORESignDataByP7), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREEncryptFileResponse(struct soap *soap, WS1__SOF_USCOREEncryptFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREEncryptFileResponse(struct soap *soap, WS1__SOF_USCOREEncryptFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptFileResponse);
	if (soap_out_PointerToWS1__SOF_USCOREEncryptFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREEncryptFileResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREEncryptFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFileResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREEncryptFileResponse(struct soap *soap, WS1__SOF_USCOREEncryptFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREEncryptFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFileResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREEncryptFileResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREEncryptFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREEncryptFileResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREEncryptFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREEncryptFileResponse *)soap_instantiate_WS1__SOF_USCOREEncryptFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREEncryptFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREEncryptFileResponse, sizeof(WS1__SOF_USCOREEncryptFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREEncryptFile(struct soap *soap, WS1__SOF_USCOREEncryptFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREEncryptFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREEncryptFile(struct soap *soap, WS1__SOF_USCOREEncryptFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREEncryptFile);
	if (soap_out_PointerToWS1__SOF_USCOREEncryptFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREEncryptFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREEncryptFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFile ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREEncryptFile(struct soap *soap, WS1__SOF_USCOREEncryptFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREEncryptFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREEncryptFile ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREEncryptFile(struct soap *soap, const char *tag, WS1__SOF_USCOREEncryptFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREEncryptFile **)soap_malloc(soap, sizeof(WS1__SOF_USCOREEncryptFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREEncryptFile *)soap_instantiate_WS1__SOF_USCOREEncryptFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREEncryptFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREEncryptFile, sizeof(WS1__SOF_USCOREEncryptFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetTimeStampInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfoResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfoResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetTimeStampInfoResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetTimeStampInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetTimeStampInfoResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetTimeStampInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetTimeStampInfoResponse *)soap_instantiate_WS1__SOF_USCOREGetTimeStampInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetTimeStampInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfoResponse, sizeof(WS1__SOF_USCOREGetTimeStampInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetTimeStampInfo);
	if (soap_out_PointerToWS1__SOF_USCOREGetTimeStampInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetTimeStampInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfo ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, WS1__SOF_USCOREGetTimeStampInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetTimeStampInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetTimeStampInfo ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetTimeStampInfo(struct soap *soap, const char *tag, WS1__SOF_USCOREGetTimeStampInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetTimeStampInfo **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetTimeStampInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetTimeStampInfo *)soap_instantiate_WS1__SOF_USCOREGetTimeStampInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetTimeStampInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetTimeStampInfo, sizeof(WS1__SOF_USCOREGetTimeStampInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESetSignMethodResponse(struct soap *soap, WS1__SOF_USCORESetSignMethodResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESetSignMethodResponse(struct soap *soap, WS1__SOF_USCORESetSignMethodResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESetSignMethodResponse);
	if (soap_out_PointerToWS1__SOF_USCORESetSignMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESetSignMethodResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESetSignMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethodResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESetSignMethodResponse(struct soap *soap, WS1__SOF_USCORESetSignMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESetSignMethodResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethodResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESetSignMethodResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESetSignMethodResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESetSignMethodResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORESetSignMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESetSignMethodResponse *)soap_instantiate_WS1__SOF_USCORESetSignMethodResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetSignMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESetSignMethodResponse, sizeof(WS1__SOF_USCORESetSignMethodResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESetSignMethod(struct soap *soap, WS1__SOF_USCORESetSignMethod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESetSignMethod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESetSignMethod(struct soap *soap, WS1__SOF_USCORESetSignMethod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESetSignMethod);
	if (soap_out_PointerToWS1__SOF_USCORESetSignMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESetSignMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESetSignMethod);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethod ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESetSignMethod(struct soap *soap, WS1__SOF_USCORESetSignMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESetSignMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESetSignMethod ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESetSignMethod(struct soap *soap, const char *tag, WS1__SOF_USCORESetSignMethod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESetSignMethod **)soap_malloc(soap, sizeof(WS1__SOF_USCORESetSignMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESetSignMethod *)soap_instantiate_WS1__SOF_USCORESetSignMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetSignMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESetSignMethod, sizeof(WS1__SOF_USCORESetSignMethod), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREDecryptFileResponse(struct soap *soap, WS1__SOF_USCOREDecryptFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREDecryptFileResponse(struct soap *soap, WS1__SOF_USCOREDecryptFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptFileResponse);
	if (soap_out_PointerToWS1__SOF_USCOREDecryptFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREDecryptFileResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREDecryptFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFileResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREDecryptFileResponse(struct soap *soap, WS1__SOF_USCOREDecryptFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREDecryptFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFileResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREDecryptFileResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREDecryptFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREDecryptFileResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREDecryptFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREDecryptFileResponse *)soap_instantiate_WS1__SOF_USCOREDecryptFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDecryptFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREDecryptFileResponse, sizeof(WS1__SOF_USCOREDecryptFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREDecryptFile(struct soap *soap, WS1__SOF_USCOREDecryptFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREDecryptFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREDecryptFile(struct soap *soap, WS1__SOF_USCOREDecryptFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREDecryptFile);
	if (soap_out_PointerToWS1__SOF_USCOREDecryptFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREDecryptFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREDecryptFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFile ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREDecryptFile(struct soap *soap, WS1__SOF_USCOREDecryptFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREDecryptFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREDecryptFile ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREDecryptFile(struct soap *soap, const char *tag, WS1__SOF_USCOREDecryptFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREDecryptFile **)soap_malloc(soap, sizeof(WS1__SOF_USCOREDecryptFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREDecryptFile *)soap_instantiate_WS1__SOF_USCOREDecryptFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDecryptFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREDecryptFile, sizeof(WS1__SOF_USCOREDecryptFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__GetFileResponse(struct soap *soap, WS1__GetFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__GetFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__GetFileResponse(struct soap *soap, WS1__GetFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__GetFileResponse);
	if (soap_out_PointerToWS1__GetFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__GetFileResponse(struct soap *soap, const char *tag, int id, WS1__GetFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__GetFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__GetFileResponse ** SOAP_FMAC4 soap_get_PointerToWS1__GetFileResponse(struct soap *soap, WS1__GetFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__GetFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__GetFileResponse ** SOAP_FMAC4 soap_in_PointerToWS1__GetFileResponse(struct soap *soap, const char *tag, WS1__GetFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__GetFileResponse **)soap_malloc(soap, sizeof(WS1__GetFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__GetFileResponse *)soap_instantiate_WS1__GetFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__GetFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__GetFileResponse, sizeof(WS1__GetFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__GetFile(struct soap *soap, WS1__GetFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__GetFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__GetFile(struct soap *soap, WS1__GetFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__GetFile);
	if (soap_out_PointerToWS1__GetFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__GetFile(struct soap *soap, const char *tag, int id, WS1__GetFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__GetFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__GetFile ** SOAP_FMAC4 soap_get_PointerToWS1__GetFile(struct soap *soap, WS1__GetFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__GetFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__GetFile ** SOAP_FMAC4 soap_in_PointerToWS1__GetFile(struct soap *soap, const char *tag, WS1__GetFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__GetFile **)soap_malloc(soap, sizeof(WS1__GetFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__GetFile *)soap_instantiate_WS1__GetFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__GetFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__GetFile, sizeof(WS1__GetFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__DeleteFileResponse(struct soap *soap, WS1__DeleteFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__DeleteFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__DeleteFileResponse(struct soap *soap, WS1__DeleteFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__DeleteFileResponse);
	if (soap_out_PointerToWS1__DeleteFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__DeleteFileResponse(struct soap *soap, const char *tag, int id, WS1__DeleteFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__DeleteFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__DeleteFileResponse ** SOAP_FMAC4 soap_get_PointerToWS1__DeleteFileResponse(struct soap *soap, WS1__DeleteFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__DeleteFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__DeleteFileResponse ** SOAP_FMAC4 soap_in_PointerToWS1__DeleteFileResponse(struct soap *soap, const char *tag, WS1__DeleteFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__DeleteFileResponse **)soap_malloc(soap, sizeof(WS1__DeleteFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__DeleteFileResponse *)soap_instantiate_WS1__DeleteFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__DeleteFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__DeleteFileResponse, sizeof(WS1__DeleteFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__DeleteFile(struct soap *soap, WS1__DeleteFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__DeleteFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__DeleteFile(struct soap *soap, WS1__DeleteFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__DeleteFile);
	if (soap_out_PointerToWS1__DeleteFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__DeleteFile(struct soap *soap, const char *tag, int id, WS1__DeleteFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__DeleteFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__DeleteFile ** SOAP_FMAC4 soap_get_PointerToWS1__DeleteFile(struct soap *soap, WS1__DeleteFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__DeleteFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__DeleteFile ** SOAP_FMAC4 soap_in_PointerToWS1__DeleteFile(struct soap *soap, const char *tag, WS1__DeleteFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__DeleteFile **)soap_malloc(soap, sizeof(WS1__DeleteFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__DeleteFile *)soap_instantiate_WS1__DeleteFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__DeleteFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__DeleteFile, sizeof(WS1__DeleteFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREValidateCertResponse(struct soap *soap, WS1__SOF_USCOREValidateCertResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREValidateCertResponse(struct soap *soap, WS1__SOF_USCOREValidateCertResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREValidateCertResponse);
	if (soap_out_PointerToWS1__SOF_USCOREValidateCertResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREValidateCertResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREValidateCertResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCertResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREValidateCertResponse(struct soap *soap, WS1__SOF_USCOREValidateCertResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREValidateCertResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCertResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREValidateCertResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREValidateCertResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREValidateCertResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREValidateCertResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREValidateCertResponse *)soap_instantiate_WS1__SOF_USCOREValidateCertResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREValidateCertResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREValidateCertResponse, sizeof(WS1__SOF_USCOREValidateCertResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREValidateCert(struct soap *soap, WS1__SOF_USCOREValidateCert *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREValidateCert))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREValidateCert(struct soap *soap, WS1__SOF_USCOREValidateCert *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREValidateCert);
	if (soap_out_PointerToWS1__SOF_USCOREValidateCert(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREValidateCert *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREValidateCert);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCert ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREValidateCert(struct soap *soap, WS1__SOF_USCOREValidateCert **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREValidateCert(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREValidateCert ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREValidateCert(struct soap *soap, const char *tag, WS1__SOF_USCOREValidateCert **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREValidateCert **)soap_malloc(soap, sizeof(WS1__SOF_USCOREValidateCert *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREValidateCert *)soap_instantiate_WS1__SOF_USCOREValidateCert(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREValidateCert **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREValidateCert, sizeof(WS1__SOF_USCOREValidateCert), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponseResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse);
	if (soap_out_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORECreateTimeStampResponseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponseResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponseResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORECreateTimeStampResponseResponse(struct soap *soap, const char *tag, WS1__SOF_USCORECreateTimeStampResponseResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORECreateTimeStampResponseResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORECreateTimeStampResponseResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORECreateTimeStampResponseResponse *)soap_instantiate_WS1__SOF_USCORECreateTimeStampResponseResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORECreateTimeStampResponseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponseResponse, sizeof(WS1__SOF_USCORECreateTimeStampResponseResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampResponse);
	if (soap_out_PointerToWS1__SOF_USCORECreateTimeStampResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORECreateTimeStampResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORECreateTimeStampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORECreateTimeStampResponse(struct soap *soap, const char *tag, WS1__SOF_USCORECreateTimeStampResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORECreateTimeStampResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORECreateTimeStampResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORECreateTimeStampResponse *)soap_instantiate_WS1__SOF_USCORECreateTimeStampResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORECreateTimeStampResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampResponse, sizeof(WS1__SOF_USCORECreateTimeStampResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCOREGetEncryptMethodResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCOREGetEncryptMethodResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetEncryptMethodResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetEncryptMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethodResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCOREGetEncryptMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethodResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetEncryptMethodResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetEncryptMethodResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetEncryptMethodResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetEncryptMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetEncryptMethodResponse *)soap_instantiate_WS1__SOF_USCOREGetEncryptMethodResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetEncryptMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethodResponse, sizeof(WS1__SOF_USCOREGetEncryptMethodResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetEncryptMethod(struct soap *soap, WS1__SOF_USCOREGetEncryptMethod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetEncryptMethod(struct soap *soap, WS1__SOF_USCOREGetEncryptMethod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetEncryptMethod);
	if (soap_out_PointerToWS1__SOF_USCOREGetEncryptMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetEncryptMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethod ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetEncryptMethod(struct soap *soap, WS1__SOF_USCOREGetEncryptMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetEncryptMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetEncryptMethod ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetEncryptMethod(struct soap *soap, const char *tag, WS1__SOF_USCOREGetEncryptMethod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetEncryptMethod **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetEncryptMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetEncryptMethod *)soap_instantiate_WS1__SOF_USCOREGetEncryptMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetEncryptMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetEncryptMethod, sizeof(WS1__SOF_USCOREGetEncryptMethod), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse);
	if (soap_out_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORECreateTimeStampRequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequestResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequestResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORECreateTimeStampRequestResponse(struct soap *soap, const char *tag, WS1__SOF_USCORECreateTimeStampRequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORECreateTimeStampRequestResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORECreateTimeStampRequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORECreateTimeStampRequestResponse *)soap_instantiate_WS1__SOF_USCORECreateTimeStampRequestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORECreateTimeStampRequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequestResponse, sizeof(WS1__SOF_USCORECreateTimeStampRequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORECreateTimeStampRequest);
	if (soap_out_PointerToWS1__SOF_USCORECreateTimeStampRequest(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, int id, WS1__SOF_USCORECreateTimeStampRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequest ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, WS1__SOF_USCORECreateTimeStampRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORECreateTimeStampRequest(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORECreateTimeStampRequest ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORECreateTimeStampRequest(struct soap *soap, const char *tag, WS1__SOF_USCORECreateTimeStampRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORECreateTimeStampRequest **)soap_malloc(soap, sizeof(WS1__SOF_USCORECreateTimeStampRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORECreateTimeStampRequest *)soap_instantiate_WS1__SOF_USCORECreateTimeStampRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORECreateTimeStampRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORECreateTimeStampRequest, sizeof(WS1__SOF_USCORECreateTimeStampRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCORESetEncryptMethodResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCORESetEncryptMethodResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESetEncryptMethodResponse);
	if (soap_out_PointerToWS1__SOF_USCORESetEncryptMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESetEncryptMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethodResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, WS1__SOF_USCORESetEncryptMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESetEncryptMethodResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethodResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESetEncryptMethodResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESetEncryptMethodResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESetEncryptMethodResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORESetEncryptMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESetEncryptMethodResponse *)soap_instantiate_WS1__SOF_USCORESetEncryptMethodResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetEncryptMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethodResponse, sizeof(WS1__SOF_USCORESetEncryptMethodResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESetEncryptMethod(struct soap *soap, WS1__SOF_USCORESetEncryptMethod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESetEncryptMethod(struct soap *soap, WS1__SOF_USCORESetEncryptMethod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESetEncryptMethod);
	if (soap_out_PointerToWS1__SOF_USCORESetEncryptMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESetEncryptMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethod ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESetEncryptMethod(struct soap *soap, WS1__SOF_USCORESetEncryptMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESetEncryptMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESetEncryptMethod ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESetEncryptMethod(struct soap *soap, const char *tag, WS1__SOF_USCORESetEncryptMethod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESetEncryptMethod **)soap_malloc(soap, sizeof(WS1__SOF_USCORESetEncryptMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESetEncryptMethod *)soap_instantiate_WS1__SOF_USCORESetEncryptMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetEncryptMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESetEncryptMethod, sizeof(WS1__SOF_USCORESetEncryptMethod), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, WS1__SOF_USCORESetWebAppNameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, WS1__SOF_USCORESetWebAppNameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESetWebAppNameResponse);
	if (soap_out_PointerToWS1__SOF_USCORESetWebAppNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESetWebAppNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppNameResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, WS1__SOF_USCORESetWebAppNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESetWebAppNameResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppNameResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESetWebAppNameResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESetWebAppNameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESetWebAppNameResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORESetWebAppNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESetWebAppNameResponse *)soap_instantiate_WS1__SOF_USCORESetWebAppNameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetWebAppNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESetWebAppNameResponse, sizeof(WS1__SOF_USCORESetWebAppNameResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESetWebAppName(struct soap *soap, WS1__SOF_USCORESetWebAppName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESetWebAppName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESetWebAppName(struct soap *soap, WS1__SOF_USCORESetWebAppName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESetWebAppName);
	if (soap_out_PointerToWS1__SOF_USCORESetWebAppName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESetWebAppName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESetWebAppName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppName ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESetWebAppName(struct soap *soap, WS1__SOF_USCORESetWebAppName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESetWebAppName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESetWebAppName ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESetWebAppName(struct soap *soap, const char *tag, WS1__SOF_USCORESetWebAppName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESetWebAppName **)soap_malloc(soap, sizeof(WS1__SOF_USCORESetWebAppName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESetWebAppName *)soap_instantiate_WS1__SOF_USCORESetWebAppName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetWebAppName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESetWebAppName, sizeof(WS1__SOF_USCORESetWebAppName), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, WS1__SOF_USCOREGetSignMethodResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, WS1__SOF_USCOREGetSignMethodResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetSignMethodResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetSignMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetSignMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethodResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, WS1__SOF_USCOREGetSignMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetSignMethodResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethodResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetSignMethodResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetSignMethodResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetSignMethodResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetSignMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetSignMethodResponse *)soap_instantiate_WS1__SOF_USCOREGetSignMethodResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetSignMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetSignMethodResponse, sizeof(WS1__SOF_USCOREGetSignMethodResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetSignMethod(struct soap *soap, WS1__SOF_USCOREGetSignMethod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetSignMethod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetSignMethod(struct soap *soap, WS1__SOF_USCOREGetSignMethod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetSignMethod);
	if (soap_out_PointerToWS1__SOF_USCOREGetSignMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetSignMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetSignMethod);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethod ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetSignMethod(struct soap *soap, WS1__SOF_USCOREGetSignMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetSignMethod(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetSignMethod ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetSignMethod(struct soap *soap, const char *tag, WS1__SOF_USCOREGetSignMethod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetSignMethod **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetSignMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetSignMethod *)soap_instantiate_WS1__SOF_USCOREGetSignMethod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetSignMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetSignMethod, sizeof(WS1__SOF_USCOREGetSignMethod), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGenRandomResponse(struct soap *soap, WS1__SOF_USCOREGenRandomResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGenRandomResponse(struct soap *soap, WS1__SOF_USCOREGenRandomResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGenRandomResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGenRandomResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGenRandomResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGenRandomResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandomResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGenRandomResponse(struct soap *soap, WS1__SOF_USCOREGenRandomResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGenRandomResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandomResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGenRandomResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGenRandomResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGenRandomResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGenRandomResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGenRandomResponse *)soap_instantiate_WS1__SOF_USCOREGenRandomResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGenRandomResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGenRandomResponse, sizeof(WS1__SOF_USCOREGenRandomResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGenRandom(struct soap *soap, WS1__SOF_USCOREGenRandom *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGenRandom))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGenRandom(struct soap *soap, WS1__SOF_USCOREGenRandom *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGenRandom);
	if (soap_out_PointerToWS1__SOF_USCOREGenRandom(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGenRandom *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGenRandom);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandom ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGenRandom(struct soap *soap, WS1__SOF_USCOREGenRandom **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGenRandom(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGenRandom ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGenRandom(struct soap *soap, const char *tag, WS1__SOF_USCOREGenRandom **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGenRandom **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGenRandom *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGenRandom *)soap_instantiate_WS1__SOF_USCOREGenRandom(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGenRandom **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGenRandom, sizeof(WS1__SOF_USCOREGenRandom), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, WS1__SOF_USCOREPriKeyDecryptResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, WS1__SOF_USCOREPriKeyDecryptResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREPriKeyDecryptResponse);
	if (soap_out_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREPriKeyDecryptResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecryptResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, WS1__SOF_USCOREPriKeyDecryptResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecryptResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREPriKeyDecryptResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREPriKeyDecryptResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREPriKeyDecryptResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREPriKeyDecryptResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREPriKeyDecryptResponse *)soap_instantiate_WS1__SOF_USCOREPriKeyDecryptResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREPriKeyDecryptResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecryptResponse, sizeof(WS1__SOF_USCOREPriKeyDecryptResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, WS1__SOF_USCOREPriKeyDecrypt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, WS1__SOF_USCOREPriKeyDecrypt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREPriKeyDecrypt);
	if (soap_out_PointerToWS1__SOF_USCOREPriKeyDecrypt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREPriKeyDecrypt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecrypt ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, WS1__SOF_USCOREPriKeyDecrypt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREPriKeyDecrypt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREPriKeyDecrypt ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREPriKeyDecrypt(struct soap *soap, const char *tag, WS1__SOF_USCOREPriKeyDecrypt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREPriKeyDecrypt **)soap_malloc(soap, sizeof(WS1__SOF_USCOREPriKeyDecrypt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREPriKeyDecrypt *)soap_instantiate_WS1__SOF_USCOREPriKeyDecrypt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREPriKeyDecrypt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREPriKeyDecrypt, sizeof(WS1__SOF_USCOREPriKeyDecrypt), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetInstanceResponse(struct soap *soap, WS1__SOF_USCOREGetInstanceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetInstanceResponse(struct soap *soap, WS1__SOF_USCOREGetInstanceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetInstanceResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetInstanceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetInstanceResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetInstanceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstanceResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetInstanceResponse(struct soap *soap, WS1__SOF_USCOREGetInstanceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetInstanceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstanceResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetInstanceResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetInstanceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetInstanceResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetInstanceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetInstanceResponse *)soap_instantiate_WS1__SOF_USCOREGetInstanceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetInstanceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetInstanceResponse, sizeof(WS1__SOF_USCOREGetInstanceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetInstance(struct soap *soap, WS1__SOF_USCOREGetInstance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetInstance))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetInstance(struct soap *soap, WS1__SOF_USCOREGetInstance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetInstance);
	if (soap_out_PointerToWS1__SOF_USCOREGetInstance(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetInstance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetInstance);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstance ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetInstance(struct soap *soap, WS1__SOF_USCOREGetInstance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetInstance(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetInstance ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetInstance(struct soap *soap, const char *tag, WS1__SOF_USCOREGetInstance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetInstance **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetInstance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetInstance *)soap_instantiate_WS1__SOF_USCOREGetInstance(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetInstance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetInstance, sizeof(WS1__SOF_USCOREGetInstance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESignFileResponse(struct soap *soap, WS1__SOF_USCORESignFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESignFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESignFileResponse(struct soap *soap, WS1__SOF_USCORESignFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESignFileResponse);
	if (soap_out_PointerToWS1__SOF_USCORESignFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESignFileResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESignFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESignFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignFileResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESignFileResponse(struct soap *soap, WS1__SOF_USCORESignFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESignFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESignFileResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESignFileResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESignFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESignFileResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORESignFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESignFileResponse *)soap_instantiate_WS1__SOF_USCORESignFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESignFileResponse, sizeof(WS1__SOF_USCORESignFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESignFile(struct soap *soap, WS1__SOF_USCORESignFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESignFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESignFile(struct soap *soap, WS1__SOF_USCORESignFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESignFile);
	if (soap_out_PointerToWS1__SOF_USCORESignFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESignFile(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESignFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESignFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignFile ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESignFile(struct soap *soap, WS1__SOF_USCORESignFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESignFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESignFile ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESignFile(struct soap *soap, const char *tag, WS1__SOF_USCORESignFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESignFile **)soap_malloc(soap, sizeof(WS1__SOF_USCORESignFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESignFile *)soap_instantiate_WS1__SOF_USCORESignFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESignFile, sizeof(WS1__SOF_USCORESignFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXMLResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXMLResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse);
	if (soap_out_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifySignedDataXMLResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXMLResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXMLResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXMLResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifySignedDataXMLResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataXMLResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifySignedDataXMLResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifySignedDataXMLResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifySignedDataXMLResponse *)soap_instantiate_WS1__SOF_USCOREVerifySignedDataXMLResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataXMLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXMLResponse, sizeof(WS1__SOF_USCOREVerifySignedDataXMLResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXML *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXML *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataXML);
	if (soap_out_PointerToWS1__SOF_USCOREVerifySignedDataXML(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifySignedDataXML *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXML ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, WS1__SOF_USCOREVerifySignedDataXML **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifySignedDataXML(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataXML ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifySignedDataXML(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataXML **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifySignedDataXML **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifySignedDataXML *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifySignedDataXML *)soap_instantiate_WS1__SOF_USCOREVerifySignedDataXML(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataXML **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataXML, sizeof(WS1__SOF_USCOREVerifySignedDataXML), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESignDataResponse(struct soap *soap, WS1__SOF_USCORESignDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESignDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESignDataResponse(struct soap *soap, WS1__SOF_USCORESignDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESignDataResponse);
	if (soap_out_PointerToWS1__SOF_USCORESignDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESignDataResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESignDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESignDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignDataResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESignDataResponse(struct soap *soap, WS1__SOF_USCORESignDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESignDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESignDataResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESignDataResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESignDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESignDataResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORESignDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESignDataResponse *)soap_instantiate_WS1__SOF_USCORESignDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESignDataResponse, sizeof(WS1__SOF_USCORESignDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESignData(struct soap *soap, WS1__SOF_USCORESignData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESignData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESignData(struct soap *soap, WS1__SOF_USCORESignData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESignData);
	if (soap_out_PointerToWS1__SOF_USCORESignData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESignData(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESignData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESignData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESignData ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESignData(struct soap *soap, WS1__SOF_USCORESignData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESignData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESignData ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESignData(struct soap *soap, const char *tag, WS1__SOF_USCORESignData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESignData **)soap_malloc(soap, sizeof(WS1__SOF_USCORESignData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESignData *)soap_instantiate_WS1__SOF_USCORESignData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESignData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESignData, sizeof(WS1__SOF_USCORESignData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetXMLSignatureInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfoResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfoResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetXMLSignatureInfoResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetXMLSignatureInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetXMLSignatureInfoResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetXMLSignatureInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetXMLSignatureInfoResponse *)soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetXMLSignatureInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfoResponse, sizeof(WS1__SOF_USCOREGetXMLSignatureInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetXMLSignatureInfo);
	if (soap_out_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetXMLSignatureInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfo ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, WS1__SOF_USCOREGetXMLSignatureInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetXMLSignatureInfo ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetXMLSignatureInfo(struct soap *soap, const char *tag, WS1__SOF_USCOREGetXMLSignatureInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetXMLSignatureInfo **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetXMLSignatureInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetXMLSignatureInfo *)soap_instantiate_WS1__SOF_USCOREGetXMLSignatureInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetXMLSignatureInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetXMLSignatureInfo, sizeof(WS1__SOF_USCOREGetXMLSignatureInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREDelCertTrustListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREDelCertTrustListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREDelCertTrustListResponse);
	if (soap_out_PointerToWS1__SOF_USCOREDelCertTrustListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREDelCertTrustListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustListResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREDelCertTrustListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREDelCertTrustListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustListResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREDelCertTrustListResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREDelCertTrustListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREDelCertTrustListResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREDelCertTrustListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREDelCertTrustListResponse *)soap_instantiate_WS1__SOF_USCOREDelCertTrustListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDelCertTrustListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustListResponse, sizeof(WS1__SOF_USCOREDelCertTrustListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREDelCertTrustList(struct soap *soap, WS1__SOF_USCOREDelCertTrustList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREDelCertTrustList(struct soap *soap, WS1__SOF_USCOREDelCertTrustList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREDelCertTrustList);
	if (soap_out_PointerToWS1__SOF_USCOREDelCertTrustList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREDelCertTrustList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustList ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREDelCertTrustList(struct soap *soap, WS1__SOF_USCOREDelCertTrustList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREDelCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREDelCertTrustList ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREDelCertTrustList(struct soap *soap, const char *tag, WS1__SOF_USCOREDelCertTrustList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREDelCertTrustList **)soap_malloc(soap, sizeof(WS1__SOF_USCOREDelCertTrustList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREDelCertTrustList *)soap_instantiate_WS1__SOF_USCOREDelCertTrustList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREDelCertTrustList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREDelCertTrustList, sizeof(WS1__SOF_USCOREDelCertTrustList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, WS1__SOF_USCOREGetServerCertificateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, WS1__SOF_USCOREGetServerCertificateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetServerCertificateResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetServerCertificateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetServerCertificateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificateResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, WS1__SOF_USCOREGetServerCertificateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetServerCertificateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificateResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetServerCertificateResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetServerCertificateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetServerCertificateResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetServerCertificateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetServerCertificateResponse *)soap_instantiate_WS1__SOF_USCOREGetServerCertificateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetServerCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificateResponse, sizeof(WS1__SOF_USCOREGetServerCertificateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetServerCertificate(struct soap *soap, WS1__SOF_USCOREGetServerCertificate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetServerCertificate(struct soap *soap, WS1__SOF_USCOREGetServerCertificate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetServerCertificate);
	if (soap_out_PointerToWS1__SOF_USCOREGetServerCertificate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetServerCertificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificate ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetServerCertificate(struct soap *soap, WS1__SOF_USCOREGetServerCertificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetServerCertificate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetServerCertificate ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetServerCertificate(struct soap *soap, const char *tag, WS1__SOF_USCOREGetServerCertificate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetServerCertificate **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetServerCertificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetServerCertificate *)soap_instantiate_WS1__SOF_USCOREGetServerCertificate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetServerCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetServerCertificate, sizeof(WS1__SOF_USCOREGetServerCertificate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetCertInfoByOidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOidResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOidResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetCertInfoByOidResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetCertInfoByOidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetCertInfoByOidResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetCertInfoByOidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetCertInfoByOidResponse *)soap_instantiate_WS1__SOF_USCOREGetCertInfoByOidResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetCertInfoByOidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOidResponse, sizeof(WS1__SOF_USCOREGetCertInfoByOidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOid *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOid *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetCertInfoByOid);
	if (soap_out_PointerToWS1__SOF_USCOREGetCertInfoByOid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetCertInfoByOid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOid ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, WS1__SOF_USCOREGetCertInfoByOid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetCertInfoByOid(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetCertInfoByOid ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetCertInfoByOid(struct soap *soap, const char *tag, WS1__SOF_USCOREGetCertInfoByOid **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetCertInfoByOid **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetCertInfoByOid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetCertInfoByOid *)soap_instantiate_WS1__SOF_USCOREGetCertInfoByOid(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetCertInfoByOid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetCertInfoByOid, sizeof(WS1__SOF_USCOREGetCertInfoByOid), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedFileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedFileResponse);
	if (soap_out_PointerToWS1__SOF_USCOREVerifySignedFileResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifySignedFileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFileResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifySignedFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFileResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifySignedFileResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifySignedFileResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifySignedFileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifySignedFileResponse *)soap_instantiate_WS1__SOF_USCOREVerifySignedFileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedFileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFileResponse, sizeof(WS1__SOF_USCOREVerifySignedFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifySignedFile(struct soap *soap, WS1__SOF_USCOREVerifySignedFile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifySignedFile(struct soap *soap, WS1__SOF_USCOREVerifySignedFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedFile);
	if (soap_out_PointerToWS1__SOF_USCOREVerifySignedFile(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifySignedFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFile ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifySignedFile(struct soap *soap, WS1__SOF_USCOREVerifySignedFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifySignedFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedFile ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifySignedFile(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifySignedFile **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifySignedFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifySignedFile *)soap_instantiate_WS1__SOF_USCOREVerifySignedFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedFile, sizeof(WS1__SOF_USCOREVerifySignedFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, WS1__SOF_USCOREVerifyTimeStampResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, WS1__SOF_USCOREVerifyTimeStampResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifyTimeStampResponse);
	if (soap_out_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifyTimeStampResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStampResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, WS1__SOF_USCOREVerifyTimeStampResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStampResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifyTimeStampResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifyTimeStampResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifyTimeStampResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifyTimeStampResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifyTimeStampResponse *)soap_instantiate_WS1__SOF_USCOREVerifyTimeStampResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifyTimeStampResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStampResponse, sizeof(WS1__SOF_USCOREVerifyTimeStampResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, WS1__SOF_USCOREVerifyTimeStamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, WS1__SOF_USCOREVerifyTimeStamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifyTimeStamp);
	if (soap_out_PointerToWS1__SOF_USCOREVerifyTimeStamp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifyTimeStamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStamp ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, WS1__SOF_USCOREVerifyTimeStamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifyTimeStamp(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifyTimeStamp ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifyTimeStamp(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifyTimeStamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifyTimeStamp **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifyTimeStamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifyTimeStamp *)soap_instantiate_WS1__SOF_USCOREVerifyTimeStamp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifyTimeStamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifyTimeStamp, sizeof(WS1__SOF_USCOREVerifyTimeStamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, WS1__SOF_USCOREPubKeyEncryptResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, WS1__SOF_USCOREPubKeyEncryptResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREPubKeyEncryptResponse);
	if (soap_out_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREPubKeyEncryptResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncryptResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, WS1__SOF_USCOREPubKeyEncryptResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncryptResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREPubKeyEncryptResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREPubKeyEncryptResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREPubKeyEncryptResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREPubKeyEncryptResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREPubKeyEncryptResponse *)soap_instantiate_WS1__SOF_USCOREPubKeyEncryptResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREPubKeyEncryptResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncryptResponse, sizeof(WS1__SOF_USCOREPubKeyEncryptResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, WS1__SOF_USCOREPubKeyEncrypt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, WS1__SOF_USCOREPubKeyEncrypt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREPubKeyEncrypt);
	if (soap_out_PointerToWS1__SOF_USCOREPubKeyEncrypt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREPubKeyEncrypt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncrypt ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, WS1__SOF_USCOREPubKeyEncrypt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREPubKeyEncrypt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREPubKeyEncrypt ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREPubKeyEncrypt(struct soap *soap, const char *tag, WS1__SOF_USCOREPubKeyEncrypt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREPubKeyEncrypt **)soap_malloc(soap, sizeof(WS1__SOF_USCOREPubKeyEncrypt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREPubKeyEncrypt *)soap_instantiate_WS1__SOF_USCOREPubKeyEncrypt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREPubKeyEncrypt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREPubKeyEncrypt, sizeof(WS1__SOF_USCOREPubKeyEncrypt), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response);
	if (soap_out_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifySignedDataByP7Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7Response ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7Response ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifySignedDataByP7Response(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataByP7Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifySignedDataByP7Response **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifySignedDataByP7Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifySignedDataByP7Response *)soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataByP7Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7Response, sizeof(WS1__SOF_USCOREVerifySignedDataByP7Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataByP7);
	if (soap_out_PointerToWS1__SOF_USCOREVerifySignedDataByP7(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifySignedDataByP7 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7 ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, WS1__SOF_USCOREVerifySignedDataByP7 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifySignedDataByP7(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataByP7 ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifySignedDataByP7(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataByP7 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifySignedDataByP7 **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifySignedDataByP7 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifySignedDataByP7 *)soap_instantiate_WS1__SOF_USCOREVerifySignedDataByP7(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataByP7 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataByP7, sizeof(WS1__SOF_USCOREVerifySignedDataByP7), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, WS1__SOF_USCORESetCertTrustListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, WS1__SOF_USCORESetCertTrustListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESetCertTrustListResponse);
	if (soap_out_PointerToWS1__SOF_USCORESetCertTrustListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESetCertTrustListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustListResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, WS1__SOF_USCORESetCertTrustListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESetCertTrustListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustListResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESetCertTrustListResponse(struct soap *soap, const char *tag, WS1__SOF_USCORESetCertTrustListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESetCertTrustListResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCORESetCertTrustListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESetCertTrustListResponse *)soap_instantiate_WS1__SOF_USCORESetCertTrustListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetCertTrustListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESetCertTrustListResponse, sizeof(WS1__SOF_USCORESetCertTrustListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCORESetCertTrustList(struct soap *soap, WS1__SOF_USCORESetCertTrustList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCORESetCertTrustList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCORESetCertTrustList(struct soap *soap, WS1__SOF_USCORESetCertTrustList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCORESetCertTrustList);
	if (soap_out_PointerToWS1__SOF_USCORESetCertTrustList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, int id, WS1__SOF_USCORESetCertTrustList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCORESetCertTrustList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustList ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCORESetCertTrustList(struct soap *soap, WS1__SOF_USCORESetCertTrustList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCORESetCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCORESetCertTrustList ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCORESetCertTrustList(struct soap *soap, const char *tag, WS1__SOF_USCORESetCertTrustList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCORESetCertTrustList **)soap_malloc(soap, sizeof(WS1__SOF_USCORESetCertTrustList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCORESetCertTrustList *)soap_instantiate_WS1__SOF_USCORESetCertTrustList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCORESetCertTrustList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCORESetCertTrustList, sizeof(WS1__SOF_USCORESetCertTrustList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse);
	if (soap_out_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetP7SignDataInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfoResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfoResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetP7SignDataInfoResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREGetP7SignDataInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetP7SignDataInfoResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetP7SignDataInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetP7SignDataInfoResponse *)soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetP7SignDataInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfoResponse, sizeof(WS1__SOF_USCOREGetP7SignDataInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREGetP7SignDataInfo);
	if (soap_out_PointerToWS1__SOF_USCOREGetP7SignDataInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREGetP7SignDataInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfo ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, WS1__SOF_USCOREGetP7SignDataInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREGetP7SignDataInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREGetP7SignDataInfo ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREGetP7SignDataInfo(struct soap *soap, const char *tag, WS1__SOF_USCOREGetP7SignDataInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREGetP7SignDataInfo **)soap_malloc(soap, sizeof(WS1__SOF_USCOREGetP7SignDataInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREGetP7SignDataInfo *)soap_instantiate_WS1__SOF_USCOREGetP7SignDataInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREGetP7SignDataInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREGetP7SignDataInfo, sizeof(WS1__SOF_USCOREGetP7SignDataInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustListResponse);
	if (soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREQueryCertTrustListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, WS1__SOF_USCOREQueryCertTrustListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustListResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREQueryCertTrustListResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREQueryCertTrustListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREQueryCertTrustListResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREQueryCertTrustListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREQueryCertTrustListResponse *)soap_instantiate_WS1__SOF_USCOREQueryCertTrustListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREQueryCertTrustListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustListResponse, sizeof(WS1__SOF_USCOREQueryCertTrustListResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREQueryCertTrustList(struct soap *soap, WS1__SOF_USCOREQueryCertTrustList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREQueryCertTrustList(struct soap *soap, WS1__SOF_USCOREQueryCertTrustList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREQueryCertTrustList);
	if (soap_out_PointerToWS1__SOF_USCOREQueryCertTrustList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREQueryCertTrustList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustList ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREQueryCertTrustList(struct soap *soap, WS1__SOF_USCOREQueryCertTrustList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREQueryCertTrustList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREQueryCertTrustList ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREQueryCertTrustList(struct soap *soap, const char *tag, WS1__SOF_USCOREQueryCertTrustList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREQueryCertTrustList **)soap_malloc(soap, sizeof(WS1__SOF_USCOREQueryCertTrustList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREQueryCertTrustList *)soap_instantiate_WS1__SOF_USCOREQueryCertTrustList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREQueryCertTrustList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREQueryCertTrustList, sizeof(WS1__SOF_USCOREQueryCertTrustList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedDataResponse);
	if (soap_out_PointerToWS1__SOF_USCOREVerifySignedDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifySignedDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataResponse ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, WS1__SOF_USCOREVerifySignedDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifySignedDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedDataResponse ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifySignedDataResponse(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifySignedDataResponse **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifySignedDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifySignedDataResponse *)soap_instantiate_WS1__SOF_USCOREVerifySignedDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedDataResponse, sizeof(WS1__SOF_USCOREVerifySignedDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__SOF_USCOREVerifySignedData(struct soap *soap, WS1__SOF_USCOREVerifySignedData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__SOF_USCOREVerifySignedData(struct soap *soap, WS1__SOF_USCOREVerifySignedData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__SOF_USCOREVerifySignedData);
	if (soap_out_PointerToWS1__SOF_USCOREVerifySignedData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, int id, WS1__SOF_USCOREVerifySignedData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__SOF_USCOREVerifySignedData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedData ** SOAP_FMAC4 soap_get_PointerToWS1__SOF_USCOREVerifySignedData(struct soap *soap, WS1__SOF_USCOREVerifySignedData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__SOF_USCOREVerifySignedData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__SOF_USCOREVerifySignedData ** SOAP_FMAC4 soap_in_PointerToWS1__SOF_USCOREVerifySignedData(struct soap *soap, const char *tag, WS1__SOF_USCOREVerifySignedData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__SOF_USCOREVerifySignedData **)soap_malloc(soap, sizeof(WS1__SOF_USCOREVerifySignedData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__SOF_USCOREVerifySignedData *)soap_instantiate_WS1__SOF_USCOREVerifySignedData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__SOF_USCOREVerifySignedData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__SOF_USCOREVerifySignedData, sizeof(WS1__SOF_USCOREVerifySignedData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToWS1__sofSecurityEngineDeal(struct soap *soap, WS1__sofSecurityEngineDeal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_WS1__sofSecurityEngineDeal))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToWS1__sofSecurityEngineDeal(struct soap *soap, WS1__sofSecurityEngineDeal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToWS1__sofSecurityEngineDeal);
	if (soap_out_PointerToWS1__sofSecurityEngineDeal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToWS1__sofSecurityEngineDeal(struct soap *soap, const char *tag, int id, WS1__sofSecurityEngineDeal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_WS1__sofSecurityEngineDeal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 WS1__sofSecurityEngineDeal ** SOAP_FMAC4 soap_get_PointerToWS1__sofSecurityEngineDeal(struct soap *soap, WS1__sofSecurityEngineDeal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToWS1__sofSecurityEngineDeal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 WS1__sofSecurityEngineDeal ** SOAP_FMAC4 soap_in_PointerToWS1__sofSecurityEngineDeal(struct soap *soap, const char *tag, WS1__sofSecurityEngineDeal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (WS1__sofSecurityEngineDeal **)soap_malloc(soap, sizeof(WS1__sofSecurityEngineDeal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (WS1__sofSecurityEngineDeal *)soap_instantiate_WS1__sofSecurityEngineDeal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (WS1__sofSecurityEngineDeal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_WS1__sofSecurityEngineDeal, sizeof(WS1__sofSecurityEngineDeal), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
		soap_serialize_std__wstring(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__wstring);
	if (soap_out_PointerTostd__wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of soapC.cpp */
